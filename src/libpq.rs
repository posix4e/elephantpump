/* automatically generated by rust-bindgen */
// commented out by Jason // extern crate libc;
pub type Oid = ::libc::c_uint;
pub type pg_int64 = ::libc::c_long;
pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __darwin_intptr_t = ::libc::c_long;
pub type __darwin_natural_t = ::libc::c_uint;
pub type __darwin_ct_rune_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed1 {
    pub _bindgen_data_: [u64; 16usize],
}
impl Union_Unnamed1 {
    pub unsafe fn __mbstate8(&mut self) -> *mut [::libc::c_char; 128usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _mbstateL(&mut self) -> *mut ::libc::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __mbstate_t = Union_Unnamed1;
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::libc::c_long;
pub type __darwin_size_t = ::libc::c_ulong;
pub type __darwin_wchar_t = ::libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::libc::c_int;
pub type __darwin_clock_t = ::libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::libc::c_long;
pub type __darwin_time_t = ::libc::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::libc::c_uint;
pub type __darwin_fsfilcnt_t = ::libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::libc::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::libc::c_char; 37usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<extern "C" fn(arg1:
                                                           *mut ::libc::c_void)
                                             -> ()>,
    pub __arg: *mut ::libc::c_void,
    pub __next: *mut Struct___darwin_pthread_handler_rec,
}
impl ::std::clone::Clone for Struct___darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_pthread_handler_rec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_attr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 56usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_cond_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 40usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_cond_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_condattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_condattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_mutex_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 56usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_mutex_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_mutexattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_mutexattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_once_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_once_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_rwlock_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 192usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_rwlock_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_rwlockattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 16usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_rwlockattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_t {
    pub __sig: ::libc::c_long,
    pub __cleanup_stack: *mut Struct___darwin_pthread_handler_rec,
    pub __opaque: [::libc::c_char; 8176usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_pthread_attr_t = Struct__opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = Struct__opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = Struct__opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::libc::c_ulong;
pub type __darwin_pthread_mutex_t = Struct__opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = Struct__opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = Struct__opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = Struct__opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = Struct__opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut Struct__opaque_pthread_t;
pub type __darwin_nl_item = ::libc::c_int;
pub type __darwin_wctrans_t = ::libc::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type size_t = __darwin_size_t;
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___sbuf {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sbuf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct___sFILEX { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: Struct___sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _close: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                                          -> ::libc::c_int>,
    pub _read: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void,
                                                   arg2: *mut ::libc::c_char,
                                                   arg3: ::libc::c_int)
                                         -> ::libc::c_int>,
    pub _seek: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void,
                                                   arg2: fpos_t,
                                                   arg3: ::libc::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void,
                                                    arg2:
                                                        *const ::libc::c_char,
                                                    arg3: ::libc::c_int)
                                          -> ::libc::c_int>,
    pub _ub: Struct___sbuf,
    pub _extra: *mut Struct___sFILEX,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: Struct___sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: fpos_t,
}
impl ::std::clone::Clone for Struct___sFILE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sFILE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FILE = Struct___sFILE;
pub type off_t = __darwin_off_t;
pub type ssize_t = __darwin_ssize_t;
pub type Enum_Unnamed2 = ::libc::c_uint;
pub const P_ALL: ::libc::c_uint = 0;
pub const P_PID: ::libc::c_uint = 1;
pub const P_PGID: ::libc::c_uint = 2;
pub type idtype_t = Enum_Unnamed2;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_thread_state {
    pub __eax: ::libc::c_uint,
    pub __ebx: ::libc::c_uint,
    pub __ecx: ::libc::c_uint,
    pub __edx: ::libc::c_uint,
    pub __edi: ::libc::c_uint,
    pub __esi: ::libc::c_uint,
    pub __ebp: ::libc::c_uint,
    pub __esp: ::libc::c_uint,
    pub __ss: ::libc::c_uint,
    pub __eflags: ::libc::c_uint,
    pub __eip: ::libc::c_uint,
    pub __cs: ::libc::c_uint,
    pub __ds: ::libc::c_uint,
    pub __es: ::libc::c_uint,
    pub __fs: ::libc::c_uint,
    pub __gs: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct___darwin_i386_thread_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_thread_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_fp_control {
    pub _bindgen_bitfield_1_: ::libc::c_ushort,
}
impl ::std::clone::Clone for Struct___darwin_fp_control {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_fp_control {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_fp_control_t = Struct___darwin_fp_control;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_fp_status {
    pub _bindgen_bitfield_1_: ::libc::c_ushort,
}
impl ::std::clone::Clone for Struct___darwin_fp_status {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_fp_status {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_fp_status_t = Struct___darwin_fp_status;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mmst_reg {
    pub __mmst_reg: [::libc::c_char; 10usize],
    pub __mmst_rsrv: [::libc::c_char; 6usize],
}
impl ::std::clone::Clone for Struct___darwin_mmst_reg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mmst_reg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_xmm_reg {
    pub __xmm_reg: [::libc::c_char; 16usize],
}
impl ::std::clone::Clone for Struct___darwin_xmm_reg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_xmm_reg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_float_state {
    pub __fpu_reserved: [::libc::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char; 224usize],
    pub __fpu_reserved1: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___darwin_i386_float_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_float_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_avx_state {
    pub __fpu_reserved: [::libc::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char; 224usize],
    pub __fpu_reserved1: ::libc::c_int,
    pub __avx_reserved1: [::libc::c_char; 64usize],
    pub __fpu_ymmh0: Struct___darwin_xmm_reg,
    pub __fpu_ymmh1: Struct___darwin_xmm_reg,
    pub __fpu_ymmh2: Struct___darwin_xmm_reg,
    pub __fpu_ymmh3: Struct___darwin_xmm_reg,
    pub __fpu_ymmh4: Struct___darwin_xmm_reg,
    pub __fpu_ymmh5: Struct___darwin_xmm_reg,
    pub __fpu_ymmh6: Struct___darwin_xmm_reg,
    pub __fpu_ymmh7: Struct___darwin_xmm_reg,
}
impl ::std::clone::Clone for Struct___darwin_i386_avx_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_avx_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
impl ::std::clone::Clone for Struct___darwin_i386_exception_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_exception_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_debug_state32 {
    pub __dr0: ::libc::c_uint,
    pub __dr1: ::libc::c_uint,
    pub __dr2: ::libc::c_uint,
    pub __dr3: ::libc::c_uint,
    pub __dr4: ::libc::c_uint,
    pub __dr5: ::libc::c_uint,
    pub __dr6: ::libc::c_uint,
    pub __dr7: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct___darwin_x86_debug_state32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_debug_state32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_thread_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_thread_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_float_state64 {
    pub __fpu_reserved: [::libc::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_xmm8: Struct___darwin_xmm_reg,
    pub __fpu_xmm9: Struct___darwin_xmm_reg,
    pub __fpu_xmm10: Struct___darwin_xmm_reg,
    pub __fpu_xmm11: Struct___darwin_xmm_reg,
    pub __fpu_xmm12: Struct___darwin_xmm_reg,
    pub __fpu_xmm13: Struct___darwin_xmm_reg,
    pub __fpu_xmm14: Struct___darwin_xmm_reg,
    pub __fpu_xmm15: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char; 96usize],
    pub __fpu_reserved1: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___darwin_x86_float_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_float_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_avx_state64 {
    pub __fpu_reserved: [::libc::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_xmm8: Struct___darwin_xmm_reg,
    pub __fpu_xmm9: Struct___darwin_xmm_reg,
    pub __fpu_xmm10: Struct___darwin_xmm_reg,
    pub __fpu_xmm11: Struct___darwin_xmm_reg,
    pub __fpu_xmm12: Struct___darwin_xmm_reg,
    pub __fpu_xmm13: Struct___darwin_xmm_reg,
    pub __fpu_xmm14: Struct___darwin_xmm_reg,
    pub __fpu_xmm15: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::libc::c_char; 96usize],
    pub __fpu_reserved1: ::libc::c_int,
    pub __avx_reserved1: [::libc::c_char; 64usize],
    pub __fpu_ymmh0: Struct___darwin_xmm_reg,
    pub __fpu_ymmh1: Struct___darwin_xmm_reg,
    pub __fpu_ymmh2: Struct___darwin_xmm_reg,
    pub __fpu_ymmh3: Struct___darwin_xmm_reg,
    pub __fpu_ymmh4: Struct___darwin_xmm_reg,
    pub __fpu_ymmh5: Struct___darwin_xmm_reg,
    pub __fpu_ymmh6: Struct___darwin_xmm_reg,
    pub __fpu_ymmh7: Struct___darwin_xmm_reg,
    pub __fpu_ymmh8: Struct___darwin_xmm_reg,
    pub __fpu_ymmh9: Struct___darwin_xmm_reg,
    pub __fpu_ymmh10: Struct___darwin_xmm_reg,
    pub __fpu_ymmh11: Struct___darwin_xmm_reg,
    pub __fpu_ymmh12: Struct___darwin_xmm_reg,
    pub __fpu_ymmh13: Struct___darwin_xmm_reg,
    pub __fpu_ymmh14: Struct___darwin_xmm_reg,
    pub __fpu_ymmh15: Struct___darwin_xmm_reg,
}
impl ::std::clone::Clone for Struct___darwin_x86_avx_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_avx_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_exception_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_exception_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_debug_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_debug_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext32 {
    pub __es: Struct___darwin_i386_exception_state,
    pub __ss: Struct___darwin_i386_thread_state,
    pub __fs: Struct___darwin_i386_float_state,
}
impl ::std::clone::Clone for Struct___darwin_mcontext32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext_avx32 {
    pub __es: Struct___darwin_i386_exception_state,
    pub __ss: Struct___darwin_i386_thread_state,
    pub __fs: Struct___darwin_i386_avx_state,
}
impl ::std::clone::Clone for Struct___darwin_mcontext_avx32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext_avx32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext64 {
    pub __es: Struct___darwin_x86_exception_state64,
    pub __ss: Struct___darwin_x86_thread_state64,
    pub __fs: Struct___darwin_x86_float_state64,
}
impl ::std::clone::Clone for Struct___darwin_mcontext64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext_avx64 {
    pub __es: Struct___darwin_x86_exception_state64,
    pub __ss: Struct___darwin_x86_thread_state64,
    pub __fs: Struct___darwin_x86_avx_state64,
}
impl ::std::clone::Clone for Struct___darwin_mcontext_avx64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext_avx64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mcontext_t = *mut Struct___darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___darwin_sigaltstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_sigaltstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type stack_t = Struct___darwin_sigaltstack;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_ucontext {
    pub uc_onstack: ::libc::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: Struct___darwin_sigaltstack,
    pub uc_link: *mut Struct___darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut Struct___darwin_mcontext64,
}
impl ::std::clone::Clone for Struct___darwin_ucontext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_ucontext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ucontext_t = Struct___darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy)]
pub struct Union_sigval {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_sigval {
    pub unsafe fn sival_int(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sival_ptr(&mut self) -> *mut *mut ::libc::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_sigval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_sigval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: Union_sigval,
    pub sigev_notify_function:
        ::std::option::Option<extern "C" fn(arg1: Union_sigval) -> ()>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
impl ::std::clone::Clone for Struct_sigevent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigevent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___siginfo {
    pub si_signo: ::libc::c_int,
    pub si_errno: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::libc::c_int,
    pub si_addr: *mut ::libc::c_void,
    pub si_value: Union_sigval,
    pub si_band: ::libc::c_long,
    pub __pad: [::libc::c_ulong; 7usize],
}
impl ::std::clone::Clone for Struct___siginfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___siginfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type siginfo_t = Struct___siginfo;
#[repr(C)]
#[derive(Copy)]
pub struct Union___sigaction_u {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union___sigaction_u {
    pub unsafe fn __sa_handler(&mut self)
     -> *mut ::std::option::Option<extern "C" fn(arg1: ::libc::c_int) -> ()> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __sa_sigaction(&mut self)
     ->
         *mut ::std::option::Option<extern "C" fn(arg1: ::libc::c_int,
                                                  arg2: *mut Struct___siginfo,
                                                  arg3: *mut ::libc::c_void)
                                        -> ()> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union___sigaction_u {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union___sigaction_u {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sigaction {
    pub __sigaction_u: Union___sigaction_u,
    pub sa_tramp: ::std::option::Option<extern "C" fn(arg1:
                                                          *mut ::libc::c_void,
                                                      arg2: ::libc::c_int,
                                                      arg3: ::libc::c_int,
                                                      arg4: *mut siginfo_t,
                                                      arg5:
                                                          *mut ::libc::c_void)
                                            -> ()>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct___sigaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sigaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaction {
    pub __sigaction_u: Union___sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_sigaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sig_t =
    ::std::option::Option<extern "C" fn(arg1: ::libc::c_int) -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigvec {
    pub sv_handler: ::std::option::Option<extern "C" fn(arg1: ::libc::c_int)
                                              -> ()>,
    pub sv_mask: ::libc::c_int,
    pub sv_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_sigvec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigvec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigstack {
    pub ss_sp: *mut ::libc::c_char,
    pub ss_onstack: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_sigstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type int8_t = ::libc::c_char;
pub type int16_t = ::libc::c_short;
pub type int32_t = ::libc::c_int;
pub type int64_t = ::libc::c_longlong;
pub type uint8_t = ::libc::c_uchar;
pub type uint16_t = ::libc::c_ushort;
pub type uint32_t = ::libc::c_uint;
pub type uint64_t = ::libc::c_ulonglong;
pub type int_least8_t = int8_t;
pub type int_least16_t = int16_t;
pub type int_least32_t = int32_t;
pub type int_least64_t = int64_t;
pub type uint_least8_t = uint8_t;
pub type uint_least16_t = uint16_t;
pub type uint_least32_t = uint32_t;
pub type uint_least64_t = uint64_t;
pub type int_fast8_t = int8_t;
pub type int_fast16_t = int16_t;
pub type int_fast32_t = int32_t;
pub type int_fast64_t = int64_t;
pub type uint_fast8_t = uint8_t;
pub type uint_fast16_t = uint16_t;
pub type uint_fast32_t = uint32_t;
pub type uint_fast64_t = uint64_t;
pub type intptr_t = __darwin_intptr_t;
pub type uintptr_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
impl ::std::clone::Clone for Struct_timeval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage {
    pub ru_utime: Struct_timeval,
    pub ru_stime: Struct_timeval,
    pub ru_maxrss: ::libc::c_long,
    pub ru_ixrss: ::libc::c_long,
    pub ru_idrss: ::libc::c_long,
    pub ru_isrss: ::libc::c_long,
    pub ru_minflt: ::libc::c_long,
    pub ru_majflt: ::libc::c_long,
    pub ru_nswap: ::libc::c_long,
    pub ru_inblock: ::libc::c_long,
    pub ru_oublock: ::libc::c_long,
    pub ru_msgsnd: ::libc::c_long,
    pub ru_msgrcv: ::libc::c_long,
    pub ru_nsignals: ::libc::c_long,
    pub ru_nvcsw: ::libc::c_long,
    pub ru_nivcsw: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_rusage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rusage_info_t = *mut ::libc::c_void;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v0 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v0 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v0 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v1 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v2 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
    pub ri_diskio_bytesread: uint64_t,
    pub ri_diskio_byteswritten: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v3 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
    pub ri_diskio_bytesread: uint64_t,
    pub ri_diskio_byteswritten: uint64_t,
    pub ri_cpu_time_qos_default: uint64_t,
    pub ri_cpu_time_qos_maintenance: uint64_t,
    pub ri_cpu_time_qos_background: uint64_t,
    pub ri_cpu_time_qos_utility: uint64_t,
    pub ri_cpu_time_qos_legacy: uint64_t,
    pub ri_cpu_time_qos_user_initiated: uint64_t,
    pub ri_cpu_time_qos_user_interactive: uint64_t,
    pub ri_billed_system_time: uint64_t,
    pub ri_serviced_system_time: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rusage_info_current = Struct_rusage_info_v3;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
impl ::std::clone::Clone for Struct_rlimit {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rlimit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_proc_rlimit_control_wakeupmon {
    pub wm_flags: uint32_t,
    pub wm_rate: int32_t,
}
impl ::std::clone::Clone for Struct_proc_rlimit_control_wakeupmon {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_proc_rlimit_control_wakeupmon {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_wait {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_wait {
    pub unsafe fn w_status(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w_T(&mut self) -> *mut Struct_Unnamed3 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w_S(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_wait {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_wait {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub _bindgen_bitfield_1_: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub _bindgen_bitfield_1_: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed5 {
    pub quot: ::libc::c_int,
    pub rem: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type div_t = Struct_Unnamed5;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub quot: ::libc::c_long,
    pub rem: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ldiv_t = Struct_Unnamed6;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub quot: ::libc::c_longlong,
    pub rem: ::libc::c_longlong,
}
impl ::std::clone::Clone for Struct_Unnamed7 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type lldiv_t = Struct_Unnamed7;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulonglong;
pub type register_t = int64_t;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = int64_t;
pub type user_long_t = int64_t;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = int64_t;
pub type user_off_t = int64_t;
pub type syscall_arg_t = u_int64_t;
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::libc::c_int;
pub type ptrdiff_t = ::libc::c_long;
pub type max_align_t = ::libc::c_double;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type _uint = ::libc::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::libc::c_char;
pub type daddr_t = int32_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = int32_t;
pub type swblk_t = int32_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
impl ::std::clone::Clone for Struct_fd_set {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_set = Struct_fd_set;
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_lconv {
    pub decimal_point: *mut ::libc::c_char,
    pub thousands_sep: *mut ::libc::c_char,
    pub grouping: *mut ::libc::c_char,
    pub int_curr_symbol: *mut ::libc::c_char,
    pub currency_symbol: *mut ::libc::c_char,
    pub mon_decimal_point: *mut ::libc::c_char,
    pub mon_thousands_sep: *mut ::libc::c_char,
    pub mon_grouping: *mut ::libc::c_char,
    pub positive_sign: *mut ::libc::c_char,
    pub negative_sign: *mut ::libc::c_char,
    pub int_frac_digits: ::libc::c_char,
    pub frac_digits: ::libc::c_char,
    pub p_cs_precedes: ::libc::c_char,
    pub p_sep_by_space: ::libc::c_char,
    pub n_cs_precedes: ::libc::c_char,
    pub n_sep_by_space: ::libc::c_char,
    pub p_sign_posn: ::libc::c_char,
    pub n_sign_posn: ::libc::c_char,
    pub int_p_cs_precedes: ::libc::c_char,
    pub int_n_cs_precedes: ::libc::c_char,
    pub int_p_sep_by_space: ::libc::c_char,
    pub int_n_sep_by_space: ::libc::c_char,
    pub int_p_sign_posn: ::libc::c_char,
    pub int_n_sign_posn: ::libc::c_char,
}
impl ::std::clone::Clone for Struct_lconv {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_lconv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _bool = ::libc::c_char;
pub type BoolPtr = *mut _bool;
pub type Pointer = *mut ::libc::c_char;
pub type int8 = ::libc::c_char;
pub type int16 = ::libc::c_short;
pub type int32 = ::libc::c_int;
pub type uint8 = ::libc::c_uchar;
pub type uint16 = ::libc::c_ushort;
pub type uint32 = ::libc::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::libc::c_long;
pub type uint64 = ::libc::c_ulong;
pub type Size = size_t;
pub type Index = ::libc::c_uint;
pub type Offset = ::libc::c_int;
pub type float4 = ::libc::c_float;
pub type float8 = ::libc::c_double;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed8 {
    pub indx: [::libc::c_int; 6usize],
}
impl ::std::clone::Clone for Struct_Unnamed8 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed8 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IntArray = Struct_Unnamed8;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varlena {
    pub vl_len_: [::libc::c_char; 4usize],
    pub vl_dat: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_varlena {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varlena {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bytea = Struct_varlena;
pub type text = Struct_varlena;
pub type BpChar = Struct_varlena;
pub type VarChar = Struct_varlena;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub vl_len_: int32,
    pub ndim: ::libc::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::libc::c_int,
    pub lbound1: ::libc::c_int,
    pub values: [int16; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed9 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type int2vector = Struct_Unnamed9;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed10 {
    pub vl_len_: int32,
    pub ndim: ::libc::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::libc::c_int,
    pub lbound1: ::libc::c_int,
    pub values: [Oid; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type oidvector = Struct_Unnamed10;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_nameData {
    pub data: [::libc::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_nameData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_nameData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NameData = Struct_nameData;
pub type Name = *mut NameData;
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
impl ::std::clone::Clone for Struct_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneEntry = Struct_Unnamed11;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed12 {
    pub __nranges: ::libc::c_int,
    pub __ranges: *mut _RuneEntry,
}
impl ::std::clone::Clone for Struct_Unnamed12 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneRange = Struct_Unnamed12;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub __name: [::libc::c_char; 14usize],
    pub __mask: __uint32_t,
}
impl ::std::clone::Clone for Struct_Unnamed13 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneCharClass = Struct_Unnamed13;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed14 {
    pub __magic: [::libc::c_char; 8usize],
    pub __encoding: [::libc::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<extern "C"
        fn(arg1: *const ::libc::c_char,
           arg2: __darwin_size_t,
           arg3: *mut *const ::libc::c_char) -> __darwin_rune_t>,
    pub __sputrune: ::std::option::Option<extern "C"
        fn(arg1: __darwin_rune_t,
           arg2: *mut ::libc::c_char,
           arg3: __darwin_size_t,
           arg4: *mut *mut ::libc::c_char) -> ::libc::c_int>,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::libc::c_void,
    pub __variable_len: ::libc::c_int,
    pub __ncharclasses: ::libc::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
impl ::std::clone::Clone for Struct_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneLocale = Struct_Unnamed14;
pub type socklen_t = __darwin_socklen_t;
pub type sa_family_t = __uint8_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_iovec {
    pub iov_base: *mut ::libc::c_void,
    pub iov_len: size_t,
}
impl ::std::clone::Clone for Struct_iovec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_iovec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sa_endpoints {
    pub sae_srcif: ::libc::c_uint,
    pub sae_srcaddr: *mut Struct_sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *mut Struct_sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
impl ::std::clone::Clone for Struct_sa_endpoints {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sa_endpoints {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sa_endpoints_t = Struct_sa_endpoints;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_linger {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_linger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
impl ::std::clone::Clone for Struct_so_np_extensions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_so_np_extensions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::libc::c_char; 14usize],
}
impl ::std::clone::Clone for Struct_sockaddr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
impl ::std::clone::Clone for Struct_sockproto {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockproto {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::libc::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::libc::c_char; 112usize],
}
impl ::std::clone::Clone for Struct_sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_msghdr {
    pub msg_name: *mut ::libc::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut Struct_iovec,
    pub msg_iovlen: ::libc::c_int,
    pub msg_control: *mut ::libc::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_msghdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_msghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::libc::c_int,
    pub cmsg_type: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_cmsghdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sf_hdtr {
    pub headers: *mut Struct_iovec,
    pub hdr_cnt: ::libc::c_int,
    pub trailers: *mut Struct_iovec,
    pub trl_cnt: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_sf_hdtr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sf_hdtr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in_addr {
    pub s_addr: in_addr_t,
}
impl ::std::clone::Clone for Struct_in_addr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: Struct_in_addr,
    pub sin_zero: [::libc::c_char; 8usize],
}
impl ::std::clone::Clone for Struct_sockaddr_in {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_in {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_opts {
    pub ip_dst: Struct_in_addr,
    pub ip_opts: [::libc::c_char; 40usize],
}
impl ::std::clone::Clone for Struct_ip_opts {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreq {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_ip_mreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreqn {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_address: Struct_in_addr,
    pub imr_ifindex: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ip_mreqn {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreqn {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreq_source {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_sourceaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreq_source {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_req {
    pub gr_interface: uint32_t,
    pub gr_group: Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct_group_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_source_req {
    pub gsr_interface: uint32_t,
    pub gsr_group: Struct_sockaddr_storage,
    pub gsr_source: Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct_group_source_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_source_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___msfilterreq {
    pub msfr_ifindex: uint32_t,
    pub msfr_fmode: uint32_t,
    pub msfr_nsrcs: uint32_t,
    pub __msfr_align: uint32_t,
    pub msfr_group: Struct_sockaddr_storage,
    pub msfr_srcs: *mut Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct___msfilterreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___msfilterreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in_pktinfo {
    pub ipi_ifindex: ::libc::c_uint,
    pub ipi_spec_dst: Struct_in_addr,
    pub ipi_addr: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_in_pktinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in6_addr {
    pub __u6_addr: Union_Unnamed15,
}
impl ::std::clone::Clone for Struct_in6_addr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in6_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed15 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed15 {
    pub unsafe fn __u6_addr8(&mut self) -> *mut [__uint8_t; 16usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr16(&mut self) -> *mut [__uint16_t; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr32(&mut self) -> *mut [__uint32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: Struct_in6_addr,
    pub sin6_scope_id: __uint32_t,
}
impl ::std::clone::Clone for Struct_sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_in6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ipv6_mreq {
    pub ipv6mr_multiaddr: Struct_in6_addr,
    pub ipv6mr_interface: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ipv6_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in6_pktinfo {
    pub ipi6_addr: Struct_in6_addr,
    pub ipi6_ifindex: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_in6_pktinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in6_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip6_mtuinfo {
    pub ip6m_addr: Struct_sockaddr_in6,
    pub ip6m_mtu: uint32_t,
}
impl ::std::clone::Clone for Struct_ip6_mtuinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip6_mtuinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_hostent {
    pub h_name: *mut ::libc::c_char,
    pub h_aliases: *mut *mut ::libc::c_char,
    pub h_addrtype: ::libc::c_int,
    pub h_length: ::libc::c_int,
    pub h_addr_list: *mut *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_hostent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_hostent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_netent {
    pub n_name: *mut ::libc::c_char,
    pub n_aliases: *mut *mut ::libc::c_char,
    pub n_addrtype: ::libc::c_int,
    pub n_net: uint32_t,
}
impl ::std::clone::Clone for Struct_netent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_netent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_servent {
    pub s_name: *mut ::libc::c_char,
    pub s_aliases: *mut *mut ::libc::c_char,
    pub s_port: ::libc::c_int,
    pub s_proto: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_servent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_servent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_protoent {
    pub p_name: *mut ::libc::c_char,
    pub p_aliases: *mut *mut ::libc::c_char,
    pub p_proto: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_protoent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_protoent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_addrinfo {
    pub ai_flags: ::libc::c_int,
    pub ai_family: ::libc::c_int,
    pub ai_socktype: ::libc::c_int,
    pub ai_protocol: ::libc::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::libc::c_char,
    pub ai_addr: *mut Struct_sockaddr,
    pub ai_next: *mut Struct_addrinfo,
}
impl ::std::clone::Clone for Struct_addrinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_addrinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rpcent {
    pub r_name: *mut ::libc::c_char,
    pub r_aliases: *mut *mut ::libc::c_char,
    pub r_number: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_rpcent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rpcent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_passwd {
    pub pw_name: *mut ::libc::c_char,
    pub pw_passwd: *mut ::libc::c_char,
    pub pw_uid: uid_t,
    pub pw_gid: gid_t,
    pub pw_change: __darwin_time_t,
    pub pw_class: *mut ::libc::c_char,
    pub pw_gecos: *mut ::libc::c_char,
    pub pw_dir: *mut ::libc::c_char,
    pub pw_shell: *mut ::libc::c_char,
    pub pw_expire: __darwin_time_t,
}
impl ::std::clone::Clone for Struct_passwd {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_passwd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type uuid_t = __darwin_uuid_t;
pub type uuid_string_t = __darwin_uuid_string_t;
pub type pgsocket = ::libc::c_int;
pub type qsort_arg_comparator =
    ::std::option::Option<extern "C" fn(a: *const ::libc::c_void,
                                        b: *const ::libc::c_void,
                                        arg: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub type pqsigfunc =
    ::std::option::Option<extern "C" fn(signo: ::libc::c_int) -> ()>;
pub type jmp_buf = [::libc::c_int; 37usize];
pub type sigjmp_buf = [::libc::c_int; 38usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ErrorContextCallback {
    pub previous: *mut Struct_ErrorContextCallback,
    pub callback: ::std::option::Option<extern "C" fn(arg:
                                                          *mut ::libc::c_void)
                                            -> ()>,
    pub arg: *mut ::libc::c_void,
}
impl ::std::clone::Clone for Struct_ErrorContextCallback {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ErrorContextCallback {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ErrorContextCallback = Struct_ErrorContextCallback;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ErrorData {
    pub elevel: ::libc::c_int,
    pub output_to_server: _bool,
    pub output_to_client: _bool,
    pub show_funcname: _bool,
    pub hide_stmt: _bool,
    pub filename: *const ::libc::c_char,
    pub lineno: ::libc::c_int,
    pub funcname: *const ::libc::c_char,
    pub domain: *const ::libc::c_char,
    pub context_domain: *const ::libc::c_char,
    pub sqlerrcode: ::libc::c_int,
    pub message: *mut ::libc::c_char,
    pub detail: *mut ::libc::c_char,
    pub detail_log: *mut ::libc::c_char,
    pub hint: *mut ::libc::c_char,
    pub context: *mut ::libc::c_char,
    pub schema_name: *mut ::libc::c_char,
    pub table_name: *mut ::libc::c_char,
    pub column_name: *mut ::libc::c_char,
    pub datatype_name: *mut ::libc::c_char,
    pub constraint_name: *mut ::libc::c_char,
    pub cursorpos: ::libc::c_int,
    pub internalpos: ::libc::c_int,
    pub internalquery: *mut ::libc::c_char,
    pub saved_errno: ::libc::c_int,
    pub assoc_context: *mut Struct_MemoryContextData,
}
impl ::std::clone::Clone for Struct_ErrorData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ErrorData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ErrorData = Struct_ErrorData;
pub type emit_log_hook_type =
    ::std::option::Option<extern "C" fn(edata: *mut ErrorData) -> ()>;
pub type Enum_Unnamed16 = ::libc::c_uint;
pub const PGERROR_TERSE: ::libc::c_uint = 0;
pub const PGERROR_DEFAULT: ::libc::c_uint = 1;
pub const PGERROR_VERBOSE: ::libc::c_uint = 2;
pub type PGErrorVerbosity = Enum_Unnamed16;
pub type MemoryContext = *mut Struct_MemoryContextData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
impl ::std::clone::Clone for Struct_varatt_external {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varatt_external {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_external = Struct_varatt_external;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varatt_indirect {
    pub pointer: *mut Struct_varlena,
}
impl ::std::clone::Clone for Struct_varatt_indirect {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varatt_indirect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_indirect = Struct_varatt_indirect;
pub type Enum_vartag_external = ::libc::c_uint;
pub const VARTAG_INDIRECT: ::libc::c_uint = 1;
pub const VARTAG_ONDISK: ::libc::c_uint = 18;
pub type vartag_external = Enum_vartag_external;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed17 {
    pub _bindgen_data_: [u32; 3usize],
}
impl Union_Unnamed17 {
    pub unsafe fn va_4byte(&mut self) -> *mut Struct_Unnamed18 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn va_compressed(&mut self) -> *mut Struct_Unnamed19 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed17 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed18 {
    pub va_header: uint32,
    pub va_data: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed18 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed18 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed19 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed19 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_4b = Union_Unnamed17;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed20 {
    pub va_header: uint8,
    pub va_data: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed20 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed20 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_1b = Struct_Unnamed20;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed21 {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: [::libc::c_char; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed21 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed21 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_1b_e = Struct_Unnamed21;
pub type Datum = uintptr_t;
pub type DatumPtr = *mut Datum;
pub type Enum_ScanDirection = ::libc::c_int;
pub const BackwardScanDirection: ::libc::c_int = -1;
pub const NoMovementScanDirection: ::libc::c_int = 0;
pub const ForwardScanDirection: ::libc::c_int = 1;
pub type ScanDirection = Enum_ScanDirection;
pub type AttrNumber = int16;
pub type fmNodePtr = *mut Struct_Node;
pub type fmAggrefPtr = *mut Struct_Aggref;
pub type fmExprContextCallbackFunction =
    ::std::option::Option<extern "C" fn(arg: Datum) -> ()>;
pub type fmStringInfo = *mut Struct_StringInfoData;
pub type FunctionCallInfo = *mut Struct_FunctionCallInfoData;
pub type PGFunction =
    ::std::option::Option<extern "C" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::libc::c_short,
    pub fn_strict: _bool,
    pub fn_retset: _bool,
    pub fn_stats: ::libc::c_uchar,
    pub fn_extra: *mut ::libc::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
impl ::std::clone::Clone for Struct_FmgrInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FmgrInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FmgrInfo = Struct_FmgrInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FunctionCallInfoData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: _bool,
    pub nargs: ::libc::c_short,
    pub arg: [Datum; 100usize],
    pub argnull: [_bool; 100usize],
}
impl ::std::clone::Clone for Struct_FunctionCallInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FunctionCallInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FunctionCallInfoData = Struct_FunctionCallInfoData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed22 {
    pub api_version: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed22 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed22 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Pg_finfo_record = Struct_Unnamed22;
pub type PGFInfoFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed23 {
    pub len: ::libc::c_int,
    pub version: ::libc::c_int,
    pub funcmaxargs: ::libc::c_int,
    pub indexmaxkeys: ::libc::c_int,
    pub namedatalen: ::libc::c_int,
    pub float4byval: ::libc::c_int,
    pub float8byval: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed23 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed23 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Pg_magic_struct = Struct_Unnamed23;
pub type PGModuleMagicFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_magic_struct>;
pub type Enum_FmgrHookEventType = ::libc::c_uint;
pub const FHET_START: ::libc::c_uint = 0;
pub const FHET_END: ::libc::c_uint = 1;
pub const FHET_ABORT: ::libc::c_uint = 2;
pub type FmgrHookEventType = Enum_FmgrHookEventType;
pub type needs_fmgr_hook_type =
    ::std::option::Option<extern "C" fn(fn_oid: Oid) -> _bool>;
pub type fmgr_hook_type =
    ::std::option::Option<extern "C" fn(event: FmgrHookEventType,
                                        flinfo: *mut FmgrInfo,
                                        arg: *mut Datum) -> ()>;
pub type StrategyNumber = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ScanKeyData {
    pub sk_flags: ::libc::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
impl ::std::clone::Clone for Struct_ScanKeyData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ScanKeyData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ScanKeyData = Struct_ScanKeyData;
pub type ScanKey = *mut ScanKeyData;
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
impl ::std::clone::Clone for Struct_BlockIdData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BlockIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BlockIdData = Struct_BlockIdData;
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ItemIdData {
    pub _bindgen_bitfield_1_: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_ItemIdData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ItemIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemIdData = Struct_ItemIdData;
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
impl ::std::clone::Clone for Struct_ItemPointerData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ItemPointerData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemPointerData = Struct_ItemPointerData;
pub type ItemPointer = *mut ItemPointerData;
pub enum Struct_TIDBitmap { }
pub type TIDBitmap = Struct_TIDBitmap;
pub enum Struct_TBMIterator { }
pub type TBMIterator = Struct_TBMIterator;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed24 {
    pub blockno: BlockNumber,
    pub ntuples: ::libc::c_int,
    pub recheck: _bool,
    pub offsets: [OffsetNumber; 1usize],
}
impl ::std::clone::Clone for Struct_Unnamed24 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed24 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TBMIterateResult = Struct_Unnamed24;
pub type BackendId = ::libc::c_int;
pub type slock_t = ::libc::c_uchar;
pub enum Struct_PGPROC { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LWLockTranche {
    pub name: *const ::libc::c_char,
    pub array_base: *mut ::libc::c_void,
    pub array_stride: Size,
}
impl ::std::clone::Clone for Struct_LWLockTranche {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LWLockTranche {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLockTranche = Struct_LWLockTranche;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LWLock {
    pub mutex: slock_t,
    pub releaseOK: _bool,
    pub exclusive: ::libc::c_char,
    pub shared: ::libc::c_int,
    pub tranche: ::libc::c_int,
    pub head: *mut Struct_PGPROC,
    pub tail: *mut Struct_PGPROC,
}
impl ::std::clone::Clone for Struct_LWLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LWLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLock = Struct_LWLock;
#[repr(C)]
#[derive(Copy)]
pub struct Union_LWLockPadded {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_LWLockPadded {
    pub unsafe fn lock(&mut self) -> *mut LWLock {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn pad(&mut self) -> *mut [::libc::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_LWLockPadded {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_LWLockPadded {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLockPadded = Union_LWLockPadded;
pub type Enum_LWLockMode = ::libc::c_uint;
pub const LW_EXCLUSIVE: ::libc::c_uint = 0;
pub const LW_SHARED: ::libc::c_uint = 1;
pub const LW_WAIT_UNTIL_FREE: ::libc::c_uint = 2;
pub type LWLockMode = Enum_LWLockMode;
pub type LWLockId = *mut LWLock;
pub type HashValueFunc =
    ::std::option::Option<extern "C" fn(key: *const ::libc::c_void,
                                        keysize: Size) -> uint32>;
pub type HashCompareFunc =
    ::std::option::Option<extern "C" fn(key1: *const ::libc::c_void,
                                        key2: *const ::libc::c_void,
                                        keysize: Size) -> ::libc::c_int>;
pub type HashCopyFunc =
    ::std::option::Option<extern "C" fn(dest: *mut ::libc::c_void,
                                        src: *const ::libc::c_void,
                                        keysize: Size)
                              -> *mut ::libc::c_void>;
pub type HashAllocFunc =
    ::std::option::Option<extern "C" fn(request: Size)
                              -> *mut ::libc::c_void>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HASHELEMENT {
    pub link: *mut Struct_HASHELEMENT,
    pub hashvalue: uint32,
}
impl ::std::clone::Clone for Struct_HASHELEMENT {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HASHELEMENT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASHELEMENT = Struct_HASHELEMENT;
pub enum Struct_HASHHDR { }
pub type HASHHDR = Struct_HASHHDR;
pub enum Struct_HTAB { }
pub type HTAB = Struct_HTAB;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HASHCTL {
    pub num_partitions: ::libc::c_long,
    pub ssize: ::libc::c_long,
    pub dsize: ::libc::c_long,
    pub max_dsize: ::libc::c_long,
    pub ffactor: ::libc::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub _match: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
impl ::std::clone::Clone for Struct_HASHCTL {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HASHCTL {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASHCTL = Struct_HASHCTL;
pub type Enum_Unnamed25 = ::libc::c_uint;
pub const HASH_FIND: ::libc::c_uint = 0;
pub const HASH_ENTER: ::libc::c_uint = 1;
pub const HASH_REMOVE: ::libc::c_uint = 2;
pub const HASH_ENTER_NULL: ::libc::c_uint = 3;
pub type HASHACTION = Enum_Unnamed25;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed26 {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
impl ::std::clone::Clone for Struct_Unnamed26 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed26 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASH_SEQ_STATUS = Struct_Unnamed26;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SHM_QUEUE {
    pub prev: *mut Struct_SHM_QUEUE,
    pub next: *mut Struct_SHM_QUEUE,
}
impl ::std::clone::Clone for Struct_SHM_QUEUE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SHM_QUEUE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SHM_QUEUE = Struct_SHM_QUEUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed27 {
    pub key: [::libc::c_char; 48usize],
    pub location: *mut ::libc::c_void,
    pub size: Size,
}
impl ::std::clone::Clone for Struct_Unnamed27 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed27 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ShmemIndexEnt = Struct_Unnamed27;
pub type PGPROC = Struct_PGPROC;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PROC_QUEUE {
    pub links: SHM_QUEUE,
    pub size: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_PROC_QUEUE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PROC_QUEUE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PROC_QUEUE = Struct_PROC_QUEUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed28 {
    pub backendId: BackendId,
    pub localTransactionId: LocalTransactionId,
}
impl ::std::clone::Clone for Struct_Unnamed28 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed28 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VirtualTransactionId = Struct_Unnamed28;
pub type LOCKMASK = ::libc::c_int;
pub type LOCKMODE = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockMethodData {
    pub numLockModes: ::libc::c_int,
    pub conflictTab: *const LOCKMASK,
    pub lockModeNames: *const *const ::libc::c_char,
    pub trace_flag: *const _bool,
}
impl ::std::clone::Clone for Struct_LockMethodData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockMethodData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockMethodData = Struct_LockMethodData;
pub type LockMethod = *const LockMethodData;
pub type LOCKMETHODID = uint16;
pub type Enum_LockTagType = ::libc::c_uint;
pub const LOCKTAG_RELATION: ::libc::c_uint = 0;
pub const LOCKTAG_RELATION_EXTEND: ::libc::c_uint = 1;
pub const LOCKTAG_PAGE: ::libc::c_uint = 2;
pub const LOCKTAG_TUPLE: ::libc::c_uint = 3;
pub const LOCKTAG_TRANSACTION: ::libc::c_uint = 4;
pub const LOCKTAG_VIRTUALTRANSACTION: ::libc::c_uint = 5;
pub const LOCKTAG_OBJECT: ::libc::c_uint = 6;
pub const LOCKTAG_USERLOCK: ::libc::c_uint = 7;
pub const LOCKTAG_ADVISORY: ::libc::c_uint = 8;
pub type LockTagType = Enum_LockTagType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LOCKTAG {
    pub locktag_field1: uint32,
    pub locktag_field2: uint32,
    pub locktag_field3: uint32,
    pub locktag_field4: uint16,
    pub locktag_type: uint8,
    pub locktag_lockmethodid: uint8,
}
impl ::std::clone::Clone for Struct_LOCKTAG {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LOCKTAG {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LOCKTAG = Struct_LOCKTAG;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LOCK {
    pub tag: LOCKTAG,
    pub grantMask: LOCKMASK,
    pub waitMask: LOCKMASK,
    pub procLocks: SHM_QUEUE,
    pub waitProcs: PROC_QUEUE,
    pub requested: [::libc::c_int; 10usize],
    pub nRequested: ::libc::c_int,
    pub granted: [::libc::c_int; 10usize],
    pub nGranted: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_LOCK {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LOCK {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LOCK = Struct_LOCK;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PROCLOCKTAG {
    pub myLock: *mut LOCK,
    pub myProc: *mut PGPROC,
}
impl ::std::clone::Clone for Struct_PROCLOCKTAG {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PROCLOCKTAG {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PROCLOCKTAG = Struct_PROCLOCKTAG;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PROCLOCK {
    pub tag: PROCLOCKTAG,
    pub holdMask: LOCKMASK,
    pub releaseMask: LOCKMASK,
    pub lockLink: SHM_QUEUE,
    pub procLink: SHM_QUEUE,
}
impl ::std::clone::Clone for Struct_PROCLOCK {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PROCLOCK {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PROCLOCK = Struct_PROCLOCK;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LOCALLOCKTAG {
    pub lock: LOCKTAG,
    pub mode: LOCKMODE,
}
impl ::std::clone::Clone for Struct_LOCALLOCKTAG {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LOCALLOCKTAG {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LOCALLOCKTAG = Struct_LOCALLOCKTAG;
pub enum Struct_ResourceOwnerData { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LOCALLOCKOWNER {
    pub owner: *mut Struct_ResourceOwnerData,
    pub nLocks: int64,
}
impl ::std::clone::Clone for Struct_LOCALLOCKOWNER {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LOCALLOCKOWNER {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LOCALLOCKOWNER = Struct_LOCALLOCKOWNER;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LOCALLOCK {
    pub tag: LOCALLOCKTAG,
    pub lock: *mut LOCK,
    pub proclock: *mut PROCLOCK,
    pub hashcode: uint32,
    pub nLocks: int64,
    pub numLockOwners: ::libc::c_int,
    pub maxLockOwners: ::libc::c_int,
    pub holdsStrongLockCount: _bool,
    pub lockOwners: *mut LOCALLOCKOWNER,
}
impl ::std::clone::Clone for Struct_LOCALLOCK {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LOCALLOCK {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LOCALLOCK = Struct_LOCALLOCK;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockInstanceData {
    pub locktag: LOCKTAG,
    pub holdMask: LOCKMASK,
    pub waitLockMode: LOCKMODE,
    pub backend: BackendId,
    pub lxid: LocalTransactionId,
    pub pid: ::libc::c_int,
    pub fastpath: _bool,
}
impl ::std::clone::Clone for Struct_LockInstanceData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockInstanceData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockInstanceData = Struct_LockInstanceData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockData {
    pub nelements: ::libc::c_int,
    pub locks: *mut LockInstanceData,
}
impl ::std::clone::Clone for Struct_LockData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockData = Struct_LockData;
pub type Enum_Unnamed29 = ::libc::c_uint;
pub const LOCKACQUIRE_NOT_AVAIL: ::libc::c_uint = 0;
pub const LOCKACQUIRE_OK: ::libc::c_uint = 1;
pub const LOCKACQUIRE_ALREADY_HELD: ::libc::c_uint = 2;
pub type LockAcquireResult = Enum_Unnamed29;
pub type Enum_Unnamed30 = ::libc::c_uint;
pub const DS_NOT_YET_CHECKED: ::libc::c_uint = 0;
pub const DS_NO_DEADLOCK: ::libc::c_uint = 1;
pub const DS_SOFT_DEADLOCK: ::libc::c_uint = 2;
pub const DS_HARD_DEADLOCK: ::libc::c_uint = 3;
pub const DS_BLOCKED_BY_AUTOVACUUM: ::libc::c_uint = 4;
pub type DeadLockState = Enum_Unnamed30;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
impl ::std::clone::Clone for Struct_xl_standby_lock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_xl_standby_lock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_standby_lock = Struct_xl_standby_lock;
pub type aclitem = ::libc::c_int;
pub type pg_node_tree = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: _bool,
    pub attstorage: ::libc::c_char,
    pub attalign: ::libc::c_char,
    pub attnotnull: _bool,
    pub atthasdef: _bool,
    pub attisdropped: _bool,
    pub attislocal: _bool,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
impl ::std::clone::Clone for Struct_FormData_pg_attribute {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_attribute {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_attribute = Struct_FormData_pg_attribute;
pub type Form_pg_attribute = *mut FormData_pg_attribute;
pub type Enum_NodeTag = ::libc::c_uint;
pub const T_Invalid: ::libc::c_uint = 0;
pub const T_IndexInfo: ::libc::c_uint = 10;
pub const T_ExprContext: ::libc::c_uint = 11;
pub const T_ProjectionInfo: ::libc::c_uint = 12;
pub const T_JunkFilter: ::libc::c_uint = 13;
pub const T_ResultRelInfo: ::libc::c_uint = 14;
pub const T_EState: ::libc::c_uint = 15;
pub const T_TupleTableSlot: ::libc::c_uint = 16;
pub const T_Plan: ::libc::c_uint = 100;
pub const T_Result: ::libc::c_uint = 101;
pub const T_ModifyTable: ::libc::c_uint = 102;
pub const T_Append: ::libc::c_uint = 103;
pub const T_MergeAppend: ::libc::c_uint = 104;
pub const T_RecursiveUnion: ::libc::c_uint = 105;
pub const T_BitmapAnd: ::libc::c_uint = 106;
pub const T_BitmapOr: ::libc::c_uint = 107;
pub const T_Scan: ::libc::c_uint = 108;
pub const T_SeqScan: ::libc::c_uint = 109;
pub const T_IndexScan: ::libc::c_uint = 110;
pub const T_IndexOnlyScan: ::libc::c_uint = 111;
pub const T_BitmapIndexScan: ::libc::c_uint = 112;
pub const T_BitmapHeapScan: ::libc::c_uint = 113;
pub const T_TidScan: ::libc::c_uint = 114;
pub const T_SubqueryScan: ::libc::c_uint = 115;
pub const T_FunctionScan: ::libc::c_uint = 116;
pub const T_ValuesScan: ::libc::c_uint = 117;
pub const T_CteScan: ::libc::c_uint = 118;
pub const T_WorkTableScan: ::libc::c_uint = 119;
pub const T_ForeignScan: ::libc::c_uint = 120;
pub const T_Join: ::libc::c_uint = 121;
pub const T_NestLoop: ::libc::c_uint = 122;
pub const T_MergeJoin: ::libc::c_uint = 123;
pub const T_HashJoin: ::libc::c_uint = 124;
pub const T_Material: ::libc::c_uint = 125;
pub const T_Sort: ::libc::c_uint = 126;
pub const T_Group: ::libc::c_uint = 127;
pub const T_Agg: ::libc::c_uint = 128;
pub const T_WindowAgg: ::libc::c_uint = 129;
pub const T_Unique: ::libc::c_uint = 130;
pub const T_Hash: ::libc::c_uint = 131;
pub const T_SetOp: ::libc::c_uint = 132;
pub const T_LockRows: ::libc::c_uint = 133;
pub const T_Limit: ::libc::c_uint = 134;
pub const T_NestLoopParam: ::libc::c_uint = 135;
pub const T_PlanRowMark: ::libc::c_uint = 136;
pub const T_PlanInvalItem: ::libc::c_uint = 137;
pub const T_PlanState: ::libc::c_uint = 200;
pub const T_ResultState: ::libc::c_uint = 201;
pub const T_ModifyTableState: ::libc::c_uint = 202;
pub const T_AppendState: ::libc::c_uint = 203;
pub const T_MergeAppendState: ::libc::c_uint = 204;
pub const T_RecursiveUnionState: ::libc::c_uint = 205;
pub const T_BitmapAndState: ::libc::c_uint = 206;
pub const T_BitmapOrState: ::libc::c_uint = 207;
pub const T_ScanState: ::libc::c_uint = 208;
pub const T_SeqScanState: ::libc::c_uint = 209;
pub const T_IndexScanState: ::libc::c_uint = 210;
pub const T_IndexOnlyScanState: ::libc::c_uint = 211;
pub const T_BitmapIndexScanState: ::libc::c_uint = 212;
pub const T_BitmapHeapScanState: ::libc::c_uint = 213;
pub const T_TidScanState: ::libc::c_uint = 214;
pub const T_SubqueryScanState: ::libc::c_uint = 215;
pub const T_FunctionScanState: ::libc::c_uint = 216;
pub const T_ValuesScanState: ::libc::c_uint = 217;
pub const T_CteScanState: ::libc::c_uint = 218;
pub const T_WorkTableScanState: ::libc::c_uint = 219;
pub const T_ForeignScanState: ::libc::c_uint = 220;
pub const T_JoinState: ::libc::c_uint = 221;
pub const T_NestLoopState: ::libc::c_uint = 222;
pub const T_MergeJoinState: ::libc::c_uint = 223;
pub const T_HashJoinState: ::libc::c_uint = 224;
pub const T_MaterialState: ::libc::c_uint = 225;
pub const T_SortState: ::libc::c_uint = 226;
pub const T_GroupState: ::libc::c_uint = 227;
pub const T_AggState: ::libc::c_uint = 228;
pub const T_WindowAggState: ::libc::c_uint = 229;
pub const T_UniqueState: ::libc::c_uint = 230;
pub const T_HashState: ::libc::c_uint = 231;
pub const T_SetOpState: ::libc::c_uint = 232;
pub const T_LockRowsState: ::libc::c_uint = 233;
pub const T_LimitState: ::libc::c_uint = 234;
pub const T_Alias: ::libc::c_uint = 300;
pub const T_RangeVar: ::libc::c_uint = 301;
pub const T_Expr: ::libc::c_uint = 302;
pub const T_Var: ::libc::c_uint = 303;
pub const T_Const: ::libc::c_uint = 304;
pub const T_Param: ::libc::c_uint = 305;
pub const T_Aggref: ::libc::c_uint = 306;
pub const T_WindowFunc: ::libc::c_uint = 307;
pub const T_ArrayRef: ::libc::c_uint = 308;
pub const T_FuncExpr: ::libc::c_uint = 309;
pub const T_NamedArgExpr: ::libc::c_uint = 310;
pub const T_OpExpr: ::libc::c_uint = 311;
pub const T_DistinctExpr: ::libc::c_uint = 312;
pub const T_NullIfExpr: ::libc::c_uint = 313;
pub const T_ScalarArrayOpExpr: ::libc::c_uint = 314;
pub const T_BoolExpr: ::libc::c_uint = 315;
pub const T_SubLink: ::libc::c_uint = 316;
pub const T_SubPlan: ::libc::c_uint = 317;
pub const T_AlternativeSubPlan: ::libc::c_uint = 318;
pub const T_FieldSelect: ::libc::c_uint = 319;
pub const T_FieldStore: ::libc::c_uint = 320;
pub const T_RelabelType: ::libc::c_uint = 321;
pub const T_CoerceViaIO: ::libc::c_uint = 322;
pub const T_ArrayCoerceExpr: ::libc::c_uint = 323;
pub const T_ConvertRowtypeExpr: ::libc::c_uint = 324;
pub const T_CollateExpr: ::libc::c_uint = 325;
pub const T_CaseExpr: ::libc::c_uint = 326;
pub const T_CaseWhen: ::libc::c_uint = 327;
pub const T_CaseTestExpr: ::libc::c_uint = 328;
pub const T_ArrayExpr: ::libc::c_uint = 329;
pub const T_RowExpr: ::libc::c_uint = 330;
pub const T_RowCompareExpr: ::libc::c_uint = 331;
pub const T_CoalesceExpr: ::libc::c_uint = 332;
pub const T_MinMaxExpr: ::libc::c_uint = 333;
pub const T_XmlExpr: ::libc::c_uint = 334;
pub const T_NullTest: ::libc::c_uint = 335;
pub const T_BooleanTest: ::libc::c_uint = 336;
pub const T_CoerceToDomain: ::libc::c_uint = 337;
pub const T_CoerceToDomainValue: ::libc::c_uint = 338;
pub const T_SetToDefault: ::libc::c_uint = 339;
pub const T_CurrentOfExpr: ::libc::c_uint = 340;
pub const T_TargetEntry: ::libc::c_uint = 341;
pub const T_RangeTblRef: ::libc::c_uint = 342;
pub const T_JoinExpr: ::libc::c_uint = 343;
pub const T_FromExpr: ::libc::c_uint = 344;
pub const T_IntoClause: ::libc::c_uint = 345;
pub const T_ExprState: ::libc::c_uint = 400;
pub const T_GenericExprState: ::libc::c_uint = 401;
pub const T_WholeRowVarExprState: ::libc::c_uint = 402;
pub const T_AggrefExprState: ::libc::c_uint = 403;
pub const T_WindowFuncExprState: ::libc::c_uint = 404;
pub const T_ArrayRefExprState: ::libc::c_uint = 405;
pub const T_FuncExprState: ::libc::c_uint = 406;
pub const T_ScalarArrayOpExprState: ::libc::c_uint = 407;
pub const T_BoolExprState: ::libc::c_uint = 408;
pub const T_SubPlanState: ::libc::c_uint = 409;
pub const T_AlternativeSubPlanState: ::libc::c_uint = 410;
pub const T_FieldSelectState: ::libc::c_uint = 411;
pub const T_FieldStoreState: ::libc::c_uint = 412;
pub const T_CoerceViaIOState: ::libc::c_uint = 413;
pub const T_ArrayCoerceExprState: ::libc::c_uint = 414;
pub const T_ConvertRowtypeExprState: ::libc::c_uint = 415;
pub const T_CaseExprState: ::libc::c_uint = 416;
pub const T_CaseWhenState: ::libc::c_uint = 417;
pub const T_ArrayExprState: ::libc::c_uint = 418;
pub const T_RowExprState: ::libc::c_uint = 419;
pub const T_RowCompareExprState: ::libc::c_uint = 420;
pub const T_CoalesceExprState: ::libc::c_uint = 421;
pub const T_MinMaxExprState: ::libc::c_uint = 422;
pub const T_XmlExprState: ::libc::c_uint = 423;
pub const T_NullTestState: ::libc::c_uint = 424;
pub const T_CoerceToDomainState: ::libc::c_uint = 425;
pub const T_DomainConstraintState: ::libc::c_uint = 426;
pub const T_PlannerInfo: ::libc::c_uint = 500;
pub const T_PlannerGlobal: ::libc::c_uint = 501;
pub const T_RelOptInfo: ::libc::c_uint = 502;
pub const T_IndexOptInfo: ::libc::c_uint = 503;
pub const T_ParamPathInfo: ::libc::c_uint = 504;
pub const T_Path: ::libc::c_uint = 505;
pub const T_IndexPath: ::libc::c_uint = 506;
pub const T_BitmapHeapPath: ::libc::c_uint = 507;
pub const T_BitmapAndPath: ::libc::c_uint = 508;
pub const T_BitmapOrPath: ::libc::c_uint = 509;
pub const T_NestPath: ::libc::c_uint = 510;
pub const T_MergePath: ::libc::c_uint = 511;
pub const T_HashPath: ::libc::c_uint = 512;
pub const T_TidPath: ::libc::c_uint = 513;
pub const T_ForeignPath: ::libc::c_uint = 514;
pub const T_AppendPath: ::libc::c_uint = 515;
pub const T_MergeAppendPath: ::libc::c_uint = 516;
pub const T_ResultPath: ::libc::c_uint = 517;
pub const T_MaterialPath: ::libc::c_uint = 518;
pub const T_UniquePath: ::libc::c_uint = 519;
pub const T_EquivalenceClass: ::libc::c_uint = 520;
pub const T_EquivalenceMember: ::libc::c_uint = 521;
pub const T_PathKey: ::libc::c_uint = 522;
pub const T_RestrictInfo: ::libc::c_uint = 523;
pub const T_PlaceHolderVar: ::libc::c_uint = 524;
pub const T_SpecialJoinInfo: ::libc::c_uint = 525;
pub const T_LateralJoinInfo: ::libc::c_uint = 526;
pub const T_AppendRelInfo: ::libc::c_uint = 527;
pub const T_PlaceHolderInfo: ::libc::c_uint = 528;
pub const T_MinMaxAggInfo: ::libc::c_uint = 529;
pub const T_PlannerParamItem: ::libc::c_uint = 530;
pub const T_MemoryContext: ::libc::c_uint = 600;
pub const T_AllocSetContext: ::libc::c_uint = 601;
pub const T_Value: ::libc::c_uint = 650;
pub const T_Integer: ::libc::c_uint = 651;
pub const T_Float: ::libc::c_uint = 652;
pub const T_String: ::libc::c_uint = 653;
pub const T_BitString: ::libc::c_uint = 654;
pub const T_Null: ::libc::c_uint = 655;
pub const T_List: ::libc::c_uint = 656;
pub const T_IntList: ::libc::c_uint = 657;
pub const T_OidList: ::libc::c_uint = 658;
pub const T_Query: ::libc::c_uint = 700;
pub const T_PlannedStmt: ::libc::c_uint = 701;
pub const T_InsertStmt: ::libc::c_uint = 702;
pub const T_DeleteStmt: ::libc::c_uint = 703;
pub const T_UpdateStmt: ::libc::c_uint = 704;
pub const T_SelectStmt: ::libc::c_uint = 705;
pub const T_AlterTableStmt: ::libc::c_uint = 706;
pub const T_AlterTableCmd: ::libc::c_uint = 707;
pub const T_AlterDomainStmt: ::libc::c_uint = 708;
pub const T_SetOperationStmt: ::libc::c_uint = 709;
pub const T_GrantStmt: ::libc::c_uint = 710;
pub const T_GrantRoleStmt: ::libc::c_uint = 711;
pub const T_AlterDefaultPrivilegesStmt: ::libc::c_uint = 712;
pub const T_ClosePortalStmt: ::libc::c_uint = 713;
pub const T_ClusterStmt: ::libc::c_uint = 714;
pub const T_CopyStmt: ::libc::c_uint = 715;
pub const T_CreateStmt: ::libc::c_uint = 716;
pub const T_DefineStmt: ::libc::c_uint = 717;
pub const T_DropStmt: ::libc::c_uint = 718;
pub const T_TruncateStmt: ::libc::c_uint = 719;
pub const T_CommentStmt: ::libc::c_uint = 720;
pub const T_FetchStmt: ::libc::c_uint = 721;
pub const T_IndexStmt: ::libc::c_uint = 722;
pub const T_CreateFunctionStmt: ::libc::c_uint = 723;
pub const T_AlterFunctionStmt: ::libc::c_uint = 724;
pub const T_DoStmt: ::libc::c_uint = 725;
pub const T_RenameStmt: ::libc::c_uint = 726;
pub const T_RuleStmt: ::libc::c_uint = 727;
pub const T_NotifyStmt: ::libc::c_uint = 728;
pub const T_ListenStmt: ::libc::c_uint = 729;
pub const T_UnlistenStmt: ::libc::c_uint = 730;
pub const T_TransactionStmt: ::libc::c_uint = 731;
pub const T_ViewStmt: ::libc::c_uint = 732;
pub const T_LoadStmt: ::libc::c_uint = 733;
pub const T_CreateDomainStmt: ::libc::c_uint = 734;
pub const T_CreatedbStmt: ::libc::c_uint = 735;
pub const T_DropdbStmt: ::libc::c_uint = 736;
pub const T_VacuumStmt: ::libc::c_uint = 737;
pub const T_ExplainStmt: ::libc::c_uint = 738;
pub const T_CreateTableAsStmt: ::libc::c_uint = 739;
pub const T_CreateSeqStmt: ::libc::c_uint = 740;
pub const T_AlterSeqStmt: ::libc::c_uint = 741;
pub const T_VariableSetStmt: ::libc::c_uint = 742;
pub const T_VariableShowStmt: ::libc::c_uint = 743;
pub const T_DiscardStmt: ::libc::c_uint = 744;
pub const T_CreateTrigStmt: ::libc::c_uint = 745;
pub const T_CreatePLangStmt: ::libc::c_uint = 746;
pub const T_CreateRoleStmt: ::libc::c_uint = 747;
pub const T_AlterRoleStmt: ::libc::c_uint = 748;
pub const T_DropRoleStmt: ::libc::c_uint = 749;
pub const T_LockStmt: ::libc::c_uint = 750;
pub const T_ConstraintsSetStmt: ::libc::c_uint = 751;
pub const T_ReindexStmt: ::libc::c_uint = 752;
pub const T_CheckPointStmt: ::libc::c_uint = 753;
pub const T_CreateSchemaStmt: ::libc::c_uint = 754;
pub const T_AlterDatabaseStmt: ::libc::c_uint = 755;
pub const T_AlterDatabaseSetStmt: ::libc::c_uint = 756;
pub const T_AlterRoleSetStmt: ::libc::c_uint = 757;
pub const T_CreateConversionStmt: ::libc::c_uint = 758;
pub const T_CreateCastStmt: ::libc::c_uint = 759;
pub const T_CreateOpClassStmt: ::libc::c_uint = 760;
pub const T_CreateOpFamilyStmt: ::libc::c_uint = 761;
pub const T_AlterOpFamilyStmt: ::libc::c_uint = 762;
pub const T_PrepareStmt: ::libc::c_uint = 763;
pub const T_ExecuteStmt: ::libc::c_uint = 764;
pub const T_DeallocateStmt: ::libc::c_uint = 765;
pub const T_DeclareCursorStmt: ::libc::c_uint = 766;
pub const T_CreateTableSpaceStmt: ::libc::c_uint = 767;
pub const T_DropTableSpaceStmt: ::libc::c_uint = 768;
pub const T_AlterObjectSchemaStmt: ::libc::c_uint = 769;
pub const T_AlterOwnerStmt: ::libc::c_uint = 770;
pub const T_DropOwnedStmt: ::libc::c_uint = 771;
pub const T_ReassignOwnedStmt: ::libc::c_uint = 772;
pub const T_CompositeTypeStmt: ::libc::c_uint = 773;
pub const T_CreateEnumStmt: ::libc::c_uint = 774;
pub const T_CreateRangeStmt: ::libc::c_uint = 775;
pub const T_AlterEnumStmt: ::libc::c_uint = 776;
pub const T_AlterTSDictionaryStmt: ::libc::c_uint = 777;
pub const T_AlterTSConfigurationStmt: ::libc::c_uint = 778;
pub const T_CreateFdwStmt: ::libc::c_uint = 779;
pub const T_AlterFdwStmt: ::libc::c_uint = 780;
pub const T_CreateForeignServerStmt: ::libc::c_uint = 781;
pub const T_AlterForeignServerStmt: ::libc::c_uint = 782;
pub const T_CreateUserMappingStmt: ::libc::c_uint = 783;
pub const T_AlterUserMappingStmt: ::libc::c_uint = 784;
pub const T_DropUserMappingStmt: ::libc::c_uint = 785;
pub const T_AlterTableSpaceOptionsStmt: ::libc::c_uint = 786;
pub const T_AlterTableMoveAllStmt: ::libc::c_uint = 787;
pub const T_SecLabelStmt: ::libc::c_uint = 788;
pub const T_CreateForeignTableStmt: ::libc::c_uint = 789;
pub const T_CreateExtensionStmt: ::libc::c_uint = 790;
pub const T_AlterExtensionStmt: ::libc::c_uint = 791;
pub const T_AlterExtensionContentsStmt: ::libc::c_uint = 792;
pub const T_CreateEventTrigStmt: ::libc::c_uint = 793;
pub const T_AlterEventTrigStmt: ::libc::c_uint = 794;
pub const T_RefreshMatViewStmt: ::libc::c_uint = 795;
pub const T_ReplicaIdentityStmt: ::libc::c_uint = 796;
pub const T_AlterSystemStmt: ::libc::c_uint = 797;
pub const T_A_Expr: ::libc::c_uint = 900;
pub const T_ColumnRef: ::libc::c_uint = 901;
pub const T_ParamRef: ::libc::c_uint = 902;
pub const T_A_Const: ::libc::c_uint = 903;
pub const T_FuncCall: ::libc::c_uint = 904;
pub const T_A_Star: ::libc::c_uint = 905;
pub const T_A_Indices: ::libc::c_uint = 906;
pub const T_A_Indirection: ::libc::c_uint = 907;
pub const T_A_ArrayExpr: ::libc::c_uint = 908;
pub const T_ResTarget: ::libc::c_uint = 909;
pub const T_TypeCast: ::libc::c_uint = 910;
pub const T_CollateClause: ::libc::c_uint = 911;
pub const T_SortBy: ::libc::c_uint = 912;
pub const T_WindowDef: ::libc::c_uint = 913;
pub const T_RangeSubselect: ::libc::c_uint = 914;
pub const T_RangeFunction: ::libc::c_uint = 915;
pub const T_TypeName: ::libc::c_uint = 916;
pub const T_ColumnDef: ::libc::c_uint = 917;
pub const T_IndexElem: ::libc::c_uint = 918;
pub const T_Constraint: ::libc::c_uint = 919;
pub const T_DefElem: ::libc::c_uint = 920;
pub const T_RangeTblEntry: ::libc::c_uint = 921;
pub const T_RangeTblFunction: ::libc::c_uint = 922;
pub const T_WithCheckOption: ::libc::c_uint = 923;
pub const T_SortGroupClause: ::libc::c_uint = 924;
pub const T_WindowClause: ::libc::c_uint = 925;
pub const T_PrivGrantee: ::libc::c_uint = 926;
pub const T_FuncWithArgs: ::libc::c_uint = 927;
pub const T_AccessPriv: ::libc::c_uint = 928;
pub const T_CreateOpClassItem: ::libc::c_uint = 929;
pub const T_TableLikeClause: ::libc::c_uint = 930;
pub const T_FunctionParameter: ::libc::c_uint = 931;
pub const T_LockingClause: ::libc::c_uint = 932;
pub const T_RowMarkClause: ::libc::c_uint = 933;
pub const T_XmlSerialize: ::libc::c_uint = 934;
pub const T_WithClause: ::libc::c_uint = 935;
pub const T_CommonTableExpr: ::libc::c_uint = 936;
pub const T_IdentifySystemCmd: ::libc::c_uint = 937;
pub const T_BaseBackupCmd: ::libc::c_uint = 938;
pub const T_CreateReplicationSlotCmd: ::libc::c_uint = 939;
pub const T_DropReplicationSlotCmd: ::libc::c_uint = 940;
pub const T_StartReplicationCmd: ::libc::c_uint = 941;
pub const T_TimeLineHistoryCmd: ::libc::c_uint = 942;
pub const T_TriggerData: ::libc::c_uint = 950;
pub const T_EventTriggerData: ::libc::c_uint = 951;
pub const T_ReturnSetInfo: ::libc::c_uint = 952;
pub const T_WindowObjectData: ::libc::c_uint = 953;
pub const T_TIDBitmap: ::libc::c_uint = 954;
pub const T_InlineCodeBlock: ::libc::c_uint = 955;
pub const T_FdwRoutine: ::libc::c_uint = 956;
pub type NodeTag = Enum_NodeTag;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Node {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_Node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Node = Struct_Node;
pub type Selectivity = ::libc::c_double;
pub type Cost = ::libc::c_double;
pub type Enum_CmdType = ::libc::c_uint;
pub const CMD_UNKNOWN: ::libc::c_uint = 0;
pub const CMD_SELECT: ::libc::c_uint = 1;
pub const CMD_UPDATE: ::libc::c_uint = 2;
pub const CMD_INSERT: ::libc::c_uint = 3;
pub const CMD_DELETE: ::libc::c_uint = 4;
pub const CMD_UTILITY: ::libc::c_uint = 5;
pub const CMD_NOTHING: ::libc::c_uint = 6;
pub type CmdType = Enum_CmdType;
pub type Enum_JoinType = ::libc::c_uint;
pub const JOIN_INNER: ::libc::c_uint = 0;
pub const JOIN_LEFT: ::libc::c_uint = 1;
pub const JOIN_FULL: ::libc::c_uint = 2;
pub const JOIN_RIGHT: ::libc::c_uint = 3;
pub const JOIN_SEMI: ::libc::c_uint = 4;
pub const JOIN_ANTI: ::libc::c_uint = 5;
pub const JOIN_UNIQUE_OUTER: ::libc::c_uint = 6;
pub const JOIN_UNIQUE_INNER: ::libc::c_uint = 7;
pub type JoinType = Enum_JoinType;
pub type ListCell = Struct_ListCell;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_List {
    pub _type: NodeTag,
    pub length: ::libc::c_int,
    pub head: *mut ListCell,
    pub tail: *mut ListCell,
}
impl ::std::clone::Clone for Struct_List {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_List {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type List = Struct_List;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ListCell {
    pub data: Union_Unnamed31,
    pub next: *mut ListCell,
}
impl ::std::clone::Clone for Struct_ListCell {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ListCell {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed31 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed31 {
    pub unsafe fn ptr_value(&mut self) -> *mut *mut ::libc::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn int_value(&mut self) -> *mut ::libc::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn oid_value(&mut self) -> *mut Oid {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed31 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed31 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_attrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_attrDefault {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_attrDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AttrDefault = Struct_attrDefault;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_constrCheck {
    pub ccname: *mut ::libc::c_char,
    pub ccbin: *mut ::libc::c_char,
    pub ccvalid: _bool,
    pub ccnoinherit: _bool,
}
impl ::std::clone::Clone for Struct_constrCheck {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_constrCheck {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConstrCheck = Struct_constrCheck;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: _bool,
}
impl ::std::clone::Clone for Struct_tupleConstr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_tupleConstr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleConstr = Struct_tupleConstr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tupleDesc {
    pub natts: ::libc::c_int,
    pub attrs: *mut Form_pg_attribute,
    pub constr: *mut TupleConstr,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdhasoid: _bool,
    pub tdrefcount: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_tupleDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_tupleDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleDesc = *mut Struct_tupleDesc;
pub type bitmapword = uint32;
pub type signedbitmapword = int32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Bitmapset {
    pub nwords: ::libc::c_int,
    pub words: [bitmapword; 1usize],
}
impl ::std::clone::Clone for Struct_Bitmapset {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Bitmapset {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Bitmapset = Struct_Bitmapset;
pub type Enum_Unnamed32 = ::libc::c_uint;
pub const BMS_EQUAL: ::libc::c_uint = 0;
pub const BMS_SUBSET1: ::libc::c_uint = 1;
pub const BMS_SUBSET2: ::libc::c_uint = 2;
pub const BMS_DIFFERENT: ::libc::c_uint = 3;
pub type BMS_Comparison = Enum_Unnamed32;
pub type Enum_Unnamed33 = ::libc::c_uint;
pub const BMS_EMPTY_SET: ::libc::c_uint = 0;
pub const BMS_SINGLETON: ::libc::c_uint = 1;
pub const BMS_MULTIPLE: ::libc::c_uint = 2;
pub type BMS_Membership = Enum_Unnamed33;
pub type Relation = *mut Struct_RelationData;
pub type RelationPtr = *mut Relation;
pub type Enum_IndexAttrBitmapKind = ::libc::c_uint;
pub const INDEX_ATTR_BITMAP_ALL: ::libc::c_uint = 0;
pub const INDEX_ATTR_BITMAP_KEY: ::libc::c_uint = 1;
pub const INDEX_ATTR_BITMAP_IDENTITY_KEY: ::libc::c_uint = 2;
pub type IndexAttrBitmapKind = Enum_IndexAttrBitmapKind;
pub type HeapTupleHeaderData = Struct_HeapTupleHeaderData;
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
pub type MinimalTupleData = Struct_MinimalTupleData;
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
impl ::std::clone::Clone for Struct_HeapTupleData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTupleData = Struct_HeapTupleData;
pub type HeapTuple = *mut HeapTupleData;
pub type Buffer = ::libc::c_int;
pub enum Struct_BufferAccessStrategyData { }
pub type BufferAccessStrategy = *mut Struct_BufferAccessStrategyData;
pub type Snapshot = *mut Struct_SnapshotData;
pub type SnapshotSatisfiesFunc =
    ::std::option::Option<extern "C" fn(htup: HeapTuple, snapshot: Snapshot,
                                        buffer: Buffer) -> _bool>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SnapshotData {
    pub satisfies: SnapshotSatisfiesFunc,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxcnt: int32,
    pub subxip: *mut TransactionId,
    pub suboverflowed: _bool,
    pub takenDuringRecovery: _bool,
    pub copied: _bool,
    pub curcid: CommandId,
    pub active_count: uint32,
    pub regd_count: uint32,
}
impl ::std::clone::Clone for Struct_SnapshotData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SnapshotData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SnapshotData = Struct_SnapshotData;
pub type Enum_Unnamed34 = ::libc::c_uint;
pub const HeapTupleMayBeUpdated: ::libc::c_uint = 0;
pub const HeapTupleInvisible: ::libc::c_uint = 1;
pub const HeapTupleSelfUpdated: ::libc::c_uint = 2;
pub const HeapTupleUpdated: ::libc::c_uint = 3;
pub const HeapTupleBeingUpdated: ::libc::c_uint = 4;
pub type HTSU_Result = Enum_Unnamed34;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IndexBuildResult {
    pub heap_tuples: ::libc::c_double,
    pub index_tuples: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_IndexBuildResult {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IndexBuildResult {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexBuildResult = Struct_IndexBuildResult;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IndexVacuumInfo {
    pub index: Relation,
    pub analyze_only: _bool,
    pub estimated_count: _bool,
    pub message_level: ::libc::c_int,
    pub num_heap_tuples: ::libc::c_double,
    pub strategy: BufferAccessStrategy,
}
impl ::std::clone::Clone for Struct_IndexVacuumInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IndexVacuumInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexVacuumInfo = Struct_IndexVacuumInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub pages_removed: BlockNumber,
    pub estimated_count: _bool,
    pub num_index_tuples: ::libc::c_double,
    pub tuples_removed: ::libc::c_double,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
impl ::std::clone::Clone for Struct_IndexBulkDeleteResult {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IndexBulkDeleteResult {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexBulkDeleteResult = Struct_IndexBulkDeleteResult;
pub type IndexBulkDeleteCallback =
    ::std::option::Option<extern "C" fn(itemptr: ItemPointer,
                                        state: *mut ::libc::c_void) -> _bool>;
pub enum Struct_IndexScanDescData { }
pub type IndexScanDesc = *mut Struct_IndexScanDescData;
pub enum Struct_SysScanDescData { }
pub type SysScanDesc = *mut Struct_SysScanDescData;
pub type Enum_IndexUniqueCheck = ::libc::c_uint;
pub const UNIQUE_CHECK_NO: ::libc::c_uint = 0;
pub const UNIQUE_CHECK_YES: ::libc::c_uint = 1;
pub const UNIQUE_CHECK_PARTIAL: ::libc::c_uint = 2;
pub const UNIQUE_CHECK_EXISTING: ::libc::c_uint = 3;
pub type IndexUniqueCheck = Enum_IndexUniqueCheck;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_class {
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: _bool,
    pub relisshared: _bool,
    pub relpersistence: ::libc::c_char,
    pub relkind: ::libc::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasoids: _bool,
    pub relhaspkey: _bool,
    pub relhasrules: _bool,
    pub relhastriggers: _bool,
    pub relhassubclass: _bool,
    pub relispopulated: _bool,
    pub relreplident: ::libc::c_char,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
impl ::std::clone::Clone for Struct_FormData_pg_class {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_class {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_class = Struct_FormData_pg_class;
pub type Form_pg_class = *mut FormData_pg_class;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_type {
    pub typname: NameData,
    pub typnamespace: Oid,
    pub typowner: Oid,
    pub typlen: int16,
    pub typbyval: _bool,
    pub typtype: ::libc::c_char,
    pub typcategory: ::libc::c_char,
    pub typispreferred: _bool,
    pub typisdefined: _bool,
    pub typdelim: ::libc::c_char,
    pub typrelid: Oid,
    pub typelem: Oid,
    pub typarray: Oid,
    pub typinput: regproc,
    pub typoutput: regproc,
    pub typreceive: regproc,
    pub typsend: regproc,
    pub typmodin: regproc,
    pub typmodout: regproc,
    pub typanalyze: regproc,
    pub typalign: ::libc::c_char,
    pub typstorage: ::libc::c_char,
    pub typnotnull: _bool,
    pub typbasetype: Oid,
    pub typtypmod: int32,
    pub typndims: int32,
    pub typcollation: Oid,
}
impl ::std::clone::Clone for Struct_FormData_pg_type {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_type {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_type = Struct_FormData_pg_type;
pub type Form_pg_type = *mut FormData_pg_type;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Alias {
    pub _type: NodeTag,
    pub aliasname: *mut ::libc::c_char,
    pub colnames: *mut List,
}
impl ::std::clone::Clone for Struct_Alias {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Alias {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Alias = Struct_Alias;
pub type Enum_InhOption = ::libc::c_uint;
pub const INH_NO: ::libc::c_uint = 0;
pub const INH_YES: ::libc::c_uint = 1;
pub const INH_DEFAULT: ::libc::c_uint = 2;
pub type InhOption = Enum_InhOption;
pub type Enum_OnCommitAction = ::libc::c_uint;
pub const ONCOMMIT_NOOP: ::libc::c_uint = 0;
pub const ONCOMMIT_PRESERVE_ROWS: ::libc::c_uint = 1;
pub const ONCOMMIT_DELETE_ROWS: ::libc::c_uint = 2;
pub const ONCOMMIT_DROP: ::libc::c_uint = 3;
pub type OnCommitAction = Enum_OnCommitAction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeVar {
    pub _type: NodeTag,
    pub catalogname: *mut ::libc::c_char,
    pub schemaname: *mut ::libc::c_char,
    pub relname: *mut ::libc::c_char,
    pub inhOpt: InhOption,
    pub relpersistence: ::libc::c_char,
    pub alias: *mut Alias,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_RangeVar {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeVar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeVar = Struct_RangeVar;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IntoClause {
    pub _type: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::libc::c_char,
    pub viewQuery: *mut Node,
    pub skipData: _bool,
}
impl ::std::clone::Clone for Struct_IntoClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IntoClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IntoClause = Struct_IntoClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Expr {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_Expr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Expr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Expr = Struct_Expr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnoold: Index,
    pub varoattno: AttrNumber,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Var {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Var {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Var = Struct_Var;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::libc::c_int,
    pub constvalue: Datum,
    pub constisnull: _bool,
    pub constbyval: _bool,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Const {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Const {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Const = Struct_Const;
pub type Enum_ParamKind = ::libc::c_uint;
pub const PARAM_EXTERN: ::libc::c_uint = 0;
pub const PARAM_EXEC: ::libc::c_uint = 1;
pub const PARAM_SUBLINK: ::libc::c_uint = 2;
pub type ParamKind = Enum_ParamKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::libc::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Param {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Param {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Param = Struct_Param;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: _bool,
    pub aggvariadic: _bool,
    pub aggkind: ::libc::c_char,
    pub agglevelsup: Index,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Aggref {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Aggref {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Aggref = Struct_Aggref;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub winref: Index,
    pub winstar: _bool,
    pub winagg: _bool,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_WindowFunc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WindowFunc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowFunc = Struct_WindowFunc;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ArrayRef {
    pub xpr: Expr,
    pub refarraytype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
impl ::std::clone::Clone for Struct_ArrayRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ArrayRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayRef = Struct_ArrayRef;
pub type Enum_CoercionContext = ::libc::c_uint;
pub const COERCION_IMPLICIT: ::libc::c_uint = 0;
pub const COERCION_ASSIGNMENT: ::libc::c_uint = 1;
pub const COERCION_EXPLICIT: ::libc::c_uint = 2;
pub type CoercionContext = Enum_CoercionContext;
pub type Enum_CoercionForm = ::libc::c_uint;
pub const COERCE_EXPLICIT_CALL: ::libc::c_uint = 0;
pub const COERCE_EXPLICIT_CAST: ::libc::c_uint = 1;
pub const COERCE_IMPLICIT_CAST: ::libc::c_uint = 2;
pub type CoercionForm = Enum_CoercionForm;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: _bool,
    pub funcvariadic: _bool,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_FuncExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FuncExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncExpr = Struct_FuncExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::libc::c_char,
    pub argnumber: ::libc::c_int,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_NamedArgExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_NamedArgExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NamedArgExpr = Struct_NamedArgExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: _bool,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_OpExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OpExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OpExpr = Struct_OpExpr;
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: _bool,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ScalarArrayOpExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ScalarArrayOpExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ScalarArrayOpExpr = Struct_ScalarArrayOpExpr;
pub type Enum_BoolExprType = ::libc::c_uint;
pub const AND_EXPR: ::libc::c_uint = 0;
pub const OR_EXPR: ::libc::c_uint = 1;
pub const NOT_EXPR: ::libc::c_uint = 2;
pub type BoolExprType = Enum_BoolExprType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_BoolExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BoolExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BoolExpr = Struct_BoolExpr;
pub type Enum_SubLinkType = ::libc::c_uint;
pub const EXISTS_SUBLINK: ::libc::c_uint = 0;
pub const ALL_SUBLINK: ::libc::c_uint = 1;
pub const ANY_SUBLINK: ::libc::c_uint = 2;
pub const ROWCOMPARE_SUBLINK: ::libc::c_uint = 3;
pub const EXPR_SUBLINK: ::libc::c_uint = 4;
pub const ARRAY_SUBLINK: ::libc::c_uint = 5;
pub const CTE_SUBLINK: ::libc::c_uint = 6;
pub type SubLinkType = Enum_SubLinkType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_SubLink {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SubLink {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SubLink = Struct_SubLink;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::libc::c_int,
    pub plan_name: *mut ::libc::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: _bool,
    pub unknownEqFalse: _bool,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
impl ::std::clone::Clone for Struct_SubPlan {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SubPlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SubPlan = Struct_SubPlan;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
impl ::std::clone::Clone for Struct_AlternativeSubPlan {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlternativeSubPlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlternativeSubPlan = Struct_AlternativeSubPlan;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
impl ::std::clone::Clone for Struct_FieldSelect {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FieldSelect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FieldSelect = Struct_FieldSelect;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
impl ::std::clone::Clone for Struct_FieldStore {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FieldStore {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FieldStore = Struct_FieldStore;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_RelabelType {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelabelType {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelabelType = Struct_RelabelType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CoerceViaIO {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CoerceViaIO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceViaIO = Struct_CoerceViaIO;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemfuncid: Oid,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub isExplicit: _bool,
    pub coerceformat: CoercionForm,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ArrayCoerceExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ArrayCoerceExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayCoerceExpr = Struct_ArrayCoerceExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ConvertRowtypeExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ConvertRowtypeExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConvertRowtypeExpr = Struct_ConvertRowtypeExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CollateExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CollateExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CollateExpr = Struct_CollateExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CaseExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CaseExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseExpr = Struct_CaseExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CaseWhen {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CaseWhen {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseWhen = Struct_CaseWhen;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
impl ::std::clone::Clone for Struct_CaseTestExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CaseTestExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseTestExpr = Struct_CaseTestExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: _bool,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ArrayExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ArrayExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayExpr = Struct_ArrayExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_RowExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RowExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowExpr = Struct_RowExpr;
pub type Enum_RowCompareType = ::libc::c_uint;
pub const ROWCOMPARE_LT: ::libc::c_uint = 1;
pub const ROWCOMPARE_LE: ::libc::c_uint = 2;
pub const ROWCOMPARE_EQ: ::libc::c_uint = 3;
pub const ROWCOMPARE_GE: ::libc::c_uint = 4;
pub const ROWCOMPARE_GT: ::libc::c_uint = 5;
pub const ROWCOMPARE_NE: ::libc::c_uint = 6;
pub type RowCompareType = Enum_RowCompareType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
impl ::std::clone::Clone for Struct_RowCompareExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RowCompareExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowCompareExpr = Struct_RowCompareExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CoalesceExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CoalesceExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoalesceExpr = Struct_CoalesceExpr;
pub type Enum_MinMaxOp = ::libc::c_uint;
pub const IS_GREATEST: ::libc::c_uint = 0;
pub const IS_LEAST: ::libc::c_uint = 1;
pub type MinMaxOp = Enum_MinMaxOp;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_MinMaxExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MinMaxExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MinMaxExpr = Struct_MinMaxExpr;
pub type Enum_XmlExprOp = ::libc::c_uint;
pub const IS_XMLCONCAT: ::libc::c_uint = 0;
pub const IS_XMLELEMENT: ::libc::c_uint = 1;
pub const IS_XMLFOREST: ::libc::c_uint = 2;
pub const IS_XMLPARSE: ::libc::c_uint = 3;
pub const IS_XMLPI: ::libc::c_uint = 4;
pub const IS_XMLROOT: ::libc::c_uint = 5;
pub const IS_XMLSERIALIZE: ::libc::c_uint = 6;
pub const IS_DOCUMENT: ::libc::c_uint = 7;
pub type XmlExprOp = Enum_XmlExprOp;
pub type Enum_Unnamed35 = ::libc::c_uint;
pub const XMLOPTION_DOCUMENT: ::libc::c_uint = 0;
pub const XMLOPTION_CONTENT: ::libc::c_uint = 1;
pub type XmlOptionType = Enum_Unnamed35;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::libc::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub _type: Oid,
    pub typmod: int32,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_XmlExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XmlExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XmlExpr = Struct_XmlExpr;
pub type Enum_NullTestType = ::libc::c_uint;
pub const IS_NULL: ::libc::c_uint = 0;
pub const IS_NOT_NULL: ::libc::c_uint = 1;
pub type NullTestType = Enum_NullTestType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: _bool,
}
impl ::std::clone::Clone for Struct_NullTest {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_NullTest {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NullTest = Struct_NullTest;
pub type Enum_BoolTestType = ::libc::c_uint;
pub const IS_TRUE: ::libc::c_uint = 0;
pub const IS_NOT_TRUE: ::libc::c_uint = 1;
pub const IS_FALSE: ::libc::c_uint = 2;
pub const IS_NOT_FALSE: ::libc::c_uint = 3;
pub const IS_UNKNOWN: ::libc::c_uint = 4;
pub const IS_NOT_UNKNOWN: ::libc::c_uint = 5;
pub type BoolTestType = Enum_BoolTestType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
}
impl ::std::clone::Clone for Struct_BooleanTest {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BooleanTest {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BooleanTest = Struct_BooleanTest;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CoerceToDomain {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CoerceToDomain {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceToDomain = Struct_CoerceToDomain;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CoerceToDomainValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CoerceToDomainValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceToDomainValue = Struct_CoerceToDomainValue;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_SetToDefault {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SetToDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SetToDefault = Struct_SetToDefault;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::libc::c_char,
    pub cursor_param: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CurrentOfExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CurrentOfExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CurrentOfExpr = Struct_CurrentOfExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::libc::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: _bool,
}
impl ::std::clone::Clone for Struct_TargetEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TargetEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TargetEntry = Struct_TargetEntry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeTblRef {
    pub _type: NodeTag,
    pub rtindex: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_RangeTblRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeTblRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblRef = Struct_RangeTblRef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_JoinExpr {
    pub _type: NodeTag,
    pub jointype: JoinType,
    pub isNatural: _bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_JoinExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_JoinExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type JoinExpr = Struct_JoinExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FromExpr {
    pub _type: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
impl ::std::clone::Clone for Struct_FromExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FromExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FromExpr = Struct_FromExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Value {
    pub _type: NodeTag,
    pub val: Union_ValUnion,
}
impl ::std::clone::Clone for Struct_Value {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Value {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_ValUnion {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_ValUnion {
    pub unsafe fn ival(&mut self) -> *mut ::libc::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn str(&mut self) -> *mut *mut ::libc::c_char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_ValUnion {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_ValUnion {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Value = Struct_Value;
pub type Enum_QuerySource = ::libc::c_uint;
pub const QSRC_ORIGINAL: ::libc::c_uint = 0;
pub const QSRC_PARSER: ::libc::c_uint = 1;
pub const QSRC_INSTEAD_RULE: ::libc::c_uint = 2;
pub const QSRC_QUAL_INSTEAD_RULE: ::libc::c_uint = 3;
pub const QSRC_NON_INSTEAD_RULE: ::libc::c_uint = 4;
pub type QuerySource = Enum_QuerySource;
pub type Enum_SortByDir = ::libc::c_uint;
pub const SORTBY_DEFAULT: ::libc::c_uint = 0;
pub const SORTBY_ASC: ::libc::c_uint = 1;
pub const SORTBY_DESC: ::libc::c_uint = 2;
pub const SORTBY_USING: ::libc::c_uint = 3;
pub type SortByDir = Enum_SortByDir;
pub type Enum_SortByNulls = ::libc::c_uint;
pub const SORTBY_NULLS_DEFAULT: ::libc::c_uint = 0;
pub const SORTBY_NULLS_FIRST: ::libc::c_uint = 1;
pub const SORTBY_NULLS_LAST: ::libc::c_uint = 2;
pub type SortByNulls = Enum_SortByNulls;
pub type AclMode = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Query {
    pub _type: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint32,
    pub canSetTag: _bool,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::libc::c_int,
    pub hasAggs: _bool,
    pub hasWindowFuncs: _bool,
    pub hasSubLinks: _bool,
    pub hasDistinctOn: _bool,
    pub hasRecursive: _bool,
    pub hasModifyingCTE: _bool,
    pub hasForUpdate: _bool,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub jointree: *mut FromExpr,
    pub targetList: *mut List,
    pub withCheckOptions: *mut List,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
}
impl ::std::clone::Clone for Struct_Query {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Query {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Query = Struct_Query;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TypeName {
    pub _type: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: _bool,
    pub pct_type: _bool,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_TypeName {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TypeName {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TypeName = Struct_TypeName;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ColumnRef {
    pub _type: NodeTag,
    pub fields: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ColumnRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ColumnRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ColumnRef = Struct_ColumnRef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ParamRef {
    pub _type: NodeTag,
    pub number: ::libc::c_int,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ParamRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ParamRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ParamRef = Struct_ParamRef;
pub type Enum_A_Expr_Kind = ::libc::c_uint;
pub const AEXPR_OP: ::libc::c_uint = 0;
pub const AEXPR_AND: ::libc::c_uint = 1;
pub const AEXPR_OR: ::libc::c_uint = 2;
pub const AEXPR_NOT: ::libc::c_uint = 3;
pub const AEXPR_OP_ANY: ::libc::c_uint = 4;
pub const AEXPR_OP_ALL: ::libc::c_uint = 5;
pub const AEXPR_DISTINCT: ::libc::c_uint = 6;
pub const AEXPR_NULLIF: ::libc::c_uint = 7;
pub const AEXPR_OF: ::libc::c_uint = 8;
pub const AEXPR_IN: ::libc::c_uint = 9;
pub type A_Expr_Kind = Enum_A_Expr_Kind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Expr {
    pub _type: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_A_Expr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Expr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Expr = Struct_A_Expr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Const {
    pub _type: NodeTag,
    pub val: Value,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_A_Const {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Const {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Const = Struct_A_Const;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TypeCast {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_TypeCast {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TypeCast {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TypeCast = Struct_TypeCast;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CollateClause {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_CollateClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CollateClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CollateClause = Struct_CollateClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FuncCall {
    pub _type: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub agg_within_group: _bool,
    pub agg_star: _bool,
    pub agg_distinct: _bool,
    pub func_variadic: _bool,
    pub over: *mut Struct_WindowDef,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_FuncCall {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FuncCall {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncCall = Struct_FuncCall;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Star {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_A_Star {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Star {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Star = Struct_A_Star;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Indices {
    pub _type: NodeTag,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
impl ::std::clone::Clone for Struct_A_Indices {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Indices {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Indices = Struct_A_Indices;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Indirection {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
impl ::std::clone::Clone for Struct_A_Indirection {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Indirection {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Indirection = Struct_A_Indirection;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_ArrayExpr {
    pub _type: NodeTag,
    pub elements: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_A_ArrayExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_ArrayExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_ArrayExpr = Struct_A_ArrayExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ResTarget {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ResTarget {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ResTarget {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ResTarget = Struct_ResTarget;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SortBy {
    pub _type: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_SortBy {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SortBy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SortBy = Struct_SortBy;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WindowDef {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
    pub refname: *mut ::libc::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::libc::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_WindowDef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WindowDef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowDef = Struct_WindowDef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeSubselect {
    pub _type: NodeTag,
    pub lateral: _bool,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
impl ::std::clone::Clone for Struct_RangeSubselect {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeSubselect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeSubselect = Struct_RangeSubselect;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeFunction {
    pub _type: NodeTag,
    pub lateral: _bool,
    pub ordinality: _bool,
    pub is_rowsfrom: _bool,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
impl ::std::clone::Clone for Struct_RangeFunction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeFunction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeFunction = Struct_RangeFunction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ColumnDef {
    pub _type: NodeTag,
    pub colname: *mut ::libc::c_char,
    pub typeName: *mut TypeName,
    pub inhcount: ::libc::c_int,
    pub is_local: _bool,
    pub is_not_null: _bool,
    pub is_from_type: _bool,
    pub storage: ::libc::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ColumnDef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ColumnDef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ColumnDef = Struct_ColumnDef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TableLikeClause {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
}
impl ::std::clone::Clone for Struct_TableLikeClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TableLikeClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TableLikeClause = Struct_TableLikeClause;
pub type Enum_TableLikeOption = ::libc::c_uint;
pub const CREATE_TABLE_LIKE_DEFAULTS: ::libc::c_uint = 1;
pub const CREATE_TABLE_LIKE_CONSTRAINTS: ::libc::c_uint = 2;
pub const CREATE_TABLE_LIKE_INDEXES: ::libc::c_uint = 4;
pub const CREATE_TABLE_LIKE_STORAGE: ::libc::c_uint = 8;
pub const CREATE_TABLE_LIKE_COMMENTS: ::libc::c_uint = 16;
pub const CREATE_TABLE_LIKE_ALL: ::libc::c_uint = 2147483647;
pub type TableLikeOption = Enum_TableLikeOption;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IndexElem {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::libc::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
impl ::std::clone::Clone for Struct_IndexElem {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IndexElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexElem = Struct_IndexElem;
pub type Enum_DefElemAction = ::libc::c_uint;
pub const DEFELEM_UNSPEC: ::libc::c_uint = 0;
pub const DEFELEM_SET: ::libc::c_uint = 1;
pub const DEFELEM_ADD: ::libc::c_uint = 2;
pub const DEFELEM_DROP: ::libc::c_uint = 3;
pub type DefElemAction = Enum_DefElemAction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DefElem {
    pub _type: NodeTag,
    pub defnamespace: *mut ::libc::c_char,
    pub defname: *mut ::libc::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
}
impl ::std::clone::Clone for Struct_DefElem {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DefElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DefElem = Struct_DefElem;
pub type Enum_LockClauseStrength = ::libc::c_uint;
pub const LCS_FORKEYSHARE: ::libc::c_uint = 0;
pub const LCS_FORSHARE: ::libc::c_uint = 1;
pub const LCS_FORNOKEYUPDATE: ::libc::c_uint = 2;
pub const LCS_FORUPDATE: ::libc::c_uint = 3;
pub type LockClauseStrength = Enum_LockClauseStrength;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockingClause {
    pub _type: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub noWait: _bool,
}
impl ::std::clone::Clone for Struct_LockingClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockingClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockingClause = Struct_LockingClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XmlSerialize {
    pub _type: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_XmlSerialize {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XmlSerialize {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XmlSerialize = Struct_XmlSerialize;
pub type Enum_RTEKind = ::libc::c_uint;
pub const RTE_RELATION: ::libc::c_uint = 0;
pub const RTE_SUBQUERY: ::libc::c_uint = 1;
pub const RTE_JOIN: ::libc::c_uint = 2;
pub const RTE_FUNCTION: ::libc::c_uint = 3;
pub const RTE_VALUES: ::libc::c_uint = 4;
pub const RTE_CTE: ::libc::c_uint = 5;
pub type RTEKind = Enum_RTEKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeTblEntry {
    pub _type: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::libc::c_char,
    pub subquery: *mut Query,
    pub security_barrier: _bool,
    pub jointype: JoinType,
    pub joinaliasvars: *mut List,
    pub functions: *mut List,
    pub funcordinality: _bool,
    pub values_lists: *mut List,
    pub values_collations: *mut List,
    pub ctename: *mut ::libc::c_char,
    pub ctelevelsup: Index,
    pub self_reference: _bool,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: _bool,
    pub inh: _bool,
    pub inFromCl: _bool,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub modifiedCols: *mut Bitmapset,
    pub securityQuals: *mut List,
}
impl ::std::clone::Clone for Struct_RangeTblEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeTblEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblEntry = Struct_RangeTblEntry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeTblFunction {
    pub _type: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::libc::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
impl ::std::clone::Clone for Struct_RangeTblFunction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeTblFunction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblFunction = Struct_RangeTblFunction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WithCheckOption {
    pub _type: NodeTag,
    pub viewname: *mut ::libc::c_char,
    pub qual: *mut Node,
    pub cascaded: _bool,
}
impl ::std::clone::Clone for Struct_WithCheckOption {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WithCheckOption {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WithCheckOption = Struct_WithCheckOption;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SortGroupClause {
    pub _type: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: _bool,
    pub hashable: _bool,
}
impl ::std::clone::Clone for Struct_SortGroupClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SortGroupClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SortGroupClause = Struct_SortGroupClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WindowClause {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
    pub refname: *mut ::libc::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::libc::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub winref: Index,
    pub copiedOrder: _bool,
}
impl ::std::clone::Clone for Struct_WindowClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WindowClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowClause = Struct_WindowClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RowMarkClause {
    pub _type: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub noWait: _bool,
    pub pushedDown: _bool,
}
impl ::std::clone::Clone for Struct_RowMarkClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RowMarkClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowMarkClause = Struct_RowMarkClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WithClause {
    pub _type: NodeTag,
    pub ctes: *mut List,
    pub recursive: _bool,
    pub location: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_WithClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WithClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WithClause = Struct_WithClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CommonTableExpr {
    pub _type: NodeTag,
    pub ctename: *mut ::libc::c_char,
    pub aliascolnames: *mut List,
    pub ctequery: *mut Node,
    pub location: ::libc::c_int,
    pub cterecursive: _bool,
    pub cterefcount: ::libc::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
impl ::std::clone::Clone for Struct_CommonTableExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CommonTableExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CommonTableExpr = Struct_CommonTableExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_InsertStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::clone::Clone for Struct_InsertStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_InsertStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type InsertStmt = Struct_InsertStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DeleteStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::clone::Clone for Struct_DeleteStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DeleteStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeleteStmt = Struct_DeleteStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_UpdateStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::clone::Clone for Struct_UpdateStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_UpdateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type UpdateStmt = Struct_UpdateStmt;
pub type Enum_SetOperation = ::libc::c_uint;
pub const SETOP_NONE: ::libc::c_uint = 0;
pub const SETOP_UNION: ::libc::c_uint = 1;
pub const SETOP_INTERSECT: ::libc::c_uint = 2;
pub const SETOP_EXCEPT: ::libc::c_uint = 3;
pub type SetOperation = Enum_SetOperation;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SelectStmt {
    pub _type: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: _bool,
    pub larg: *mut Struct_SelectStmt,
    pub rarg: *mut Struct_SelectStmt,
}
impl ::std::clone::Clone for Struct_SelectStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SelectStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SelectStmt = Struct_SelectStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SetOperationStmt {
    pub _type: NodeTag,
    pub op: SetOperation,
    pub all: _bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
impl ::std::clone::Clone for Struct_SetOperationStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SetOperationStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SetOperationStmt = Struct_SetOperationStmt;
pub type Enum_ObjectType = ::libc::c_uint;
pub const OBJECT_AGGREGATE: ::libc::c_uint = 0;
pub const OBJECT_ATTRIBUTE: ::libc::c_uint = 1;
pub const OBJECT_CAST: ::libc::c_uint = 2;
pub const OBJECT_COLUMN: ::libc::c_uint = 3;
pub const OBJECT_CONSTRAINT: ::libc::c_uint = 4;
pub const OBJECT_COLLATION: ::libc::c_uint = 5;
pub const OBJECT_CONVERSION: ::libc::c_uint = 6;
pub const OBJECT_DATABASE: ::libc::c_uint = 7;
pub const OBJECT_DOMAIN: ::libc::c_uint = 8;
pub const OBJECT_EVENT_TRIGGER: ::libc::c_uint = 9;
pub const OBJECT_EXTENSION: ::libc::c_uint = 10;
pub const OBJECT_FDW: ::libc::c_uint = 11;
pub const OBJECT_FOREIGN_SERVER: ::libc::c_uint = 12;
pub const OBJECT_FOREIGN_TABLE: ::libc::c_uint = 13;
pub const OBJECT_FUNCTION: ::libc::c_uint = 14;
pub const OBJECT_INDEX: ::libc::c_uint = 15;
pub const OBJECT_LANGUAGE: ::libc::c_uint = 16;
pub const OBJECT_LARGEOBJECT: ::libc::c_uint = 17;
pub const OBJECT_MATVIEW: ::libc::c_uint = 18;
pub const OBJECT_OPCLASS: ::libc::c_uint = 19;
pub const OBJECT_OPERATOR: ::libc::c_uint = 20;
pub const OBJECT_OPFAMILY: ::libc::c_uint = 21;
pub const OBJECT_ROLE: ::libc::c_uint = 22;
pub const OBJECT_RULE: ::libc::c_uint = 23;
pub const OBJECT_SCHEMA: ::libc::c_uint = 24;
pub const OBJECT_SEQUENCE: ::libc::c_uint = 25;
pub const OBJECT_TABLE: ::libc::c_uint = 26;
pub const OBJECT_TABLESPACE: ::libc::c_uint = 27;
pub const OBJECT_TRIGGER: ::libc::c_uint = 28;
pub const OBJECT_TSCONFIGURATION: ::libc::c_uint = 29;
pub const OBJECT_TSDICTIONARY: ::libc::c_uint = 30;
pub const OBJECT_TSPARSER: ::libc::c_uint = 31;
pub const OBJECT_TSTEMPLATE: ::libc::c_uint = 32;
pub const OBJECT_TYPE: ::libc::c_uint = 33;
pub const OBJECT_VIEW: ::libc::c_uint = 34;
pub type ObjectType = Enum_ObjectType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateSchemaStmt {
    pub _type: NodeTag,
    pub schemaname: *mut ::libc::c_char,
    pub authid: *mut ::libc::c_char,
    pub schemaElts: *mut List,
    pub if_not_exists: _bool,
}
impl ::std::clone::Clone for Struct_CreateSchemaStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateSchemaStmt = Struct_CreateSchemaStmt;
pub type Enum_DropBehavior = ::libc::c_uint;
pub const DROP_RESTRICT: ::libc::c_uint = 0;
pub const DROP_CASCADE: ::libc::c_uint = 1;
pub type DropBehavior = Enum_DropBehavior;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTableStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub relkind: ObjectType,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterTableStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTableStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableStmt = Struct_AlterTableStmt;
pub type Enum_AlterTableType = ::libc::c_uint;
pub const AT_AddColumn: ::libc::c_uint = 0;
pub const AT_AddColumnRecurse: ::libc::c_uint = 1;
pub const AT_AddColumnToView: ::libc::c_uint = 2;
pub const AT_ColumnDefault: ::libc::c_uint = 3;
pub const AT_DropNotNull: ::libc::c_uint = 4;
pub const AT_SetNotNull: ::libc::c_uint = 5;
pub const AT_SetStatistics: ::libc::c_uint = 6;
pub const AT_SetOptions: ::libc::c_uint = 7;
pub const AT_ResetOptions: ::libc::c_uint = 8;
pub const AT_SetStorage: ::libc::c_uint = 9;
pub const AT_DropColumn: ::libc::c_uint = 10;
pub const AT_DropColumnRecurse: ::libc::c_uint = 11;
pub const AT_AddIndex: ::libc::c_uint = 12;
pub const AT_ReAddIndex: ::libc::c_uint = 13;
pub const AT_AddConstraint: ::libc::c_uint = 14;
pub const AT_AddConstraintRecurse: ::libc::c_uint = 15;
pub const AT_ReAddConstraint: ::libc::c_uint = 16;
pub const AT_AlterConstraint: ::libc::c_uint = 17;
pub const AT_ValidateConstraint: ::libc::c_uint = 18;
pub const AT_ValidateConstraintRecurse: ::libc::c_uint = 19;
pub const AT_ProcessedConstraint: ::libc::c_uint = 20;
pub const AT_AddIndexConstraint: ::libc::c_uint = 21;
pub const AT_DropConstraint: ::libc::c_uint = 22;
pub const AT_DropConstraintRecurse: ::libc::c_uint = 23;
pub const AT_AlterColumnType: ::libc::c_uint = 24;
pub const AT_AlterColumnGenericOptions: ::libc::c_uint = 25;
pub const AT_ChangeOwner: ::libc::c_uint = 26;
pub const AT_ClusterOn: ::libc::c_uint = 27;
pub const AT_DropCluster: ::libc::c_uint = 28;
pub const AT_AddOids: ::libc::c_uint = 29;
pub const AT_AddOidsRecurse: ::libc::c_uint = 30;
pub const AT_DropOids: ::libc::c_uint = 31;
pub const AT_SetTableSpace: ::libc::c_uint = 32;
pub const AT_SetRelOptions: ::libc::c_uint = 33;
pub const AT_ResetRelOptions: ::libc::c_uint = 34;
pub const AT_ReplaceRelOptions: ::libc::c_uint = 35;
pub const AT_EnableTrig: ::libc::c_uint = 36;
pub const AT_EnableAlwaysTrig: ::libc::c_uint = 37;
pub const AT_EnableReplicaTrig: ::libc::c_uint = 38;
pub const AT_DisableTrig: ::libc::c_uint = 39;
pub const AT_EnableTrigAll: ::libc::c_uint = 40;
pub const AT_DisableTrigAll: ::libc::c_uint = 41;
pub const AT_EnableTrigUser: ::libc::c_uint = 42;
pub const AT_DisableTrigUser: ::libc::c_uint = 43;
pub const AT_EnableRule: ::libc::c_uint = 44;
pub const AT_EnableAlwaysRule: ::libc::c_uint = 45;
pub const AT_EnableReplicaRule: ::libc::c_uint = 46;
pub const AT_DisableRule: ::libc::c_uint = 47;
pub const AT_AddInherit: ::libc::c_uint = 48;
pub const AT_DropInherit: ::libc::c_uint = 49;
pub const AT_AddOf: ::libc::c_uint = 50;
pub const AT_DropOf: ::libc::c_uint = 51;
pub const AT_ReplicaIdentity: ::libc::c_uint = 52;
pub const AT_GenericOptions: ::libc::c_uint = 53;
pub type AlterTableType = Enum_AlterTableType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicaIdentityStmt {
    pub _type: NodeTag,
    pub identity_type: ::libc::c_char,
    pub name: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_ReplicaIdentityStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicaIdentityStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicaIdentityStmt = Struct_ReplicaIdentityStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTableCmd {
    pub _type: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::libc::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterTableCmd {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTableCmd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableCmd = Struct_AlterTableCmd;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterDomainStmt {
    pub _type: NodeTag,
    pub subtype: ::libc::c_char,
    pub typeName: *mut List,
    pub name: *mut ::libc::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterDomainStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterDomainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDomainStmt = Struct_AlterDomainStmt;
pub type Enum_GrantTargetType = ::libc::c_uint;
pub const ACL_TARGET_OBJECT: ::libc::c_uint = 0;
pub const ACL_TARGET_ALL_IN_SCHEMA: ::libc::c_uint = 1;
pub const ACL_TARGET_DEFAULTS: ::libc::c_uint = 2;
pub type GrantTargetType = Enum_GrantTargetType;
pub type Enum_GrantObjectType = ::libc::c_uint;
pub const ACL_OBJECT_COLUMN: ::libc::c_uint = 0;
pub const ACL_OBJECT_RELATION: ::libc::c_uint = 1;
pub const ACL_OBJECT_SEQUENCE: ::libc::c_uint = 2;
pub const ACL_OBJECT_DATABASE: ::libc::c_uint = 3;
pub const ACL_OBJECT_DOMAIN: ::libc::c_uint = 4;
pub const ACL_OBJECT_FDW: ::libc::c_uint = 5;
pub const ACL_OBJECT_FOREIGN_SERVER: ::libc::c_uint = 6;
pub const ACL_OBJECT_FUNCTION: ::libc::c_uint = 7;
pub const ACL_OBJECT_LANGUAGE: ::libc::c_uint = 8;
pub const ACL_OBJECT_LARGEOBJECT: ::libc::c_uint = 9;
pub const ACL_OBJECT_NAMESPACE: ::libc::c_uint = 10;
pub const ACL_OBJECT_TABLESPACE: ::libc::c_uint = 11;
pub const ACL_OBJECT_TYPE: ::libc::c_uint = 12;
pub type GrantObjectType = Enum_GrantObjectType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_GrantStmt {
    pub _type: NodeTag,
    pub is_grant: _bool,
    pub targtype: GrantTargetType,
    pub objtype: GrantObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: _bool,
    pub behavior: DropBehavior,
}
impl ::std::clone::Clone for Struct_GrantStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_GrantStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GrantStmt = Struct_GrantStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PrivGrantee {
    pub _type: NodeTag,
    pub rolname: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_PrivGrantee {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PrivGrantee {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PrivGrantee = Struct_PrivGrantee;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FuncWithArgs {
    pub _type: NodeTag,
    pub funcname: *mut List,
    pub funcargs: *mut List,
}
impl ::std::clone::Clone for Struct_FuncWithArgs {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FuncWithArgs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncWithArgs = Struct_FuncWithArgs;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AccessPriv {
    pub _type: NodeTag,
    pub priv_name: *mut ::libc::c_char,
    pub cols: *mut List,
}
impl ::std::clone::Clone for Struct_AccessPriv {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AccessPriv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AccessPriv = Struct_AccessPriv;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_GrantRoleStmt {
    pub _type: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: _bool,
    pub admin_opt: _bool,
    pub grantor: *mut ::libc::c_char,
    pub behavior: DropBehavior,
}
impl ::std::clone::Clone for Struct_GrantRoleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_GrantRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GrantRoleStmt = Struct_GrantRoleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterDefaultPrivilegesStmt {
    pub _type: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
impl ::std::clone::Clone for Struct_AlterDefaultPrivilegesStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterDefaultPrivilegesStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDefaultPrivilegesStmt = Struct_AlterDefaultPrivilegesStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CopyStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: _bool,
    pub is_program: _bool,
    pub filename: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CopyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CopyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CopyStmt = Struct_CopyStmt;
pub type Enum_Unnamed36 = ::libc::c_uint;
pub const VAR_SET_VALUE: ::libc::c_uint = 0;
pub const VAR_SET_DEFAULT: ::libc::c_uint = 1;
pub const VAR_SET_CURRENT: ::libc::c_uint = 2;
pub const VAR_SET_MULTI: ::libc::c_uint = 3;
pub const VAR_RESET: ::libc::c_uint = 4;
pub const VAR_RESET_ALL: ::libc::c_uint = 5;
pub type VariableSetKind = Enum_Unnamed36;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VariableSetStmt {
    pub _type: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::libc::c_char,
    pub args: *mut List,
    pub is_local: _bool,
}
impl ::std::clone::Clone for Struct_VariableSetStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VariableSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableSetStmt = Struct_VariableSetStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VariableShowStmt {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_VariableShowStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VariableShowStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableShowStmt = Struct_VariableShowStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::libc::c_char,
    pub if_not_exists: _bool,
}
impl ::std::clone::Clone for Struct_CreateStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateStmt = Struct_CreateStmt;
pub type Enum_ConstrType = ::libc::c_uint;
pub const CONSTR_NULL: ::libc::c_uint = 0;
pub const CONSTR_NOTNULL: ::libc::c_uint = 1;
pub const CONSTR_DEFAULT: ::libc::c_uint = 2;
pub const CONSTR_CHECK: ::libc::c_uint = 3;
pub const CONSTR_PRIMARY: ::libc::c_uint = 4;
pub const CONSTR_UNIQUE: ::libc::c_uint = 5;
pub const CONSTR_EXCLUSION: ::libc::c_uint = 6;
pub const CONSTR_FOREIGN: ::libc::c_uint = 7;
pub const CONSTR_ATTR_DEFERRABLE: ::libc::c_uint = 8;
pub const CONSTR_ATTR_NOT_DEFERRABLE: ::libc::c_uint = 9;
pub const CONSTR_ATTR_DEFERRED: ::libc::c_uint = 10;
pub const CONSTR_ATTR_IMMEDIATE: ::libc::c_uint = 11;
pub type ConstrType = Enum_ConstrType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Constraint {
    pub _type: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::libc::c_char,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub location: ::libc::c_int,
    pub is_no_inherit: _bool,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::libc::c_char,
    pub keys: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::libc::c_char,
    pub indexspace: *mut ::libc::c_char,
    pub access_method: *mut ::libc::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::libc::c_char,
    pub fk_upd_action: ::libc::c_char,
    pub fk_del_action: ::libc::c_char,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub skip_validation: _bool,
    pub initially_valid: _bool,
}
impl ::std::clone::Clone for Struct_Constraint {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Constraint {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Constraint = Struct_Constraint;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateTableSpaceStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::libc::c_char,
    pub owner: *mut ::libc::c_char,
    pub location: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateTableSpaceStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateTableSpaceStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTableSpaceStmt = Struct_CreateTableSpaceStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropTableSpaceStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::libc::c_char,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_DropTableSpaceStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropTableSpaceStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropTableSpaceStmt = Struct_DropTableSpaceStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTableSpaceOptionsStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::libc::c_char,
    pub options: *mut List,
    pub isReset: _bool,
}
impl ::std::clone::Clone for Struct_AlterTableSpaceOptionsStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTableSpaceOptionsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableSpaceOptionsStmt = Struct_AlterTableSpaceOptionsStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTableMoveAllStmt {
    pub _type: NodeTag,
    pub orig_tablespacename: *mut ::libc::c_char,
    pub objtype: ObjectType,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::libc::c_char,
    pub nowait: _bool,
}
impl ::std::clone::Clone for Struct_AlterTableMoveAllStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTableMoveAllStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableMoveAllStmt = Struct_AlterTableMoveAllStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateExtensionStmt {
    pub _type: NodeTag,
    pub extname: *mut ::libc::c_char,
    pub if_not_exists: _bool,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateExtensionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateExtensionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateExtensionStmt = Struct_CreateExtensionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterExtensionStmt {
    pub _type: NodeTag,
    pub extname: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterExtensionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterExtensionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterExtensionStmt = Struct_AlterExtensionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterExtensionContentsStmt {
    pub _type: NodeTag,
    pub extname: *mut ::libc::c_char,
    pub action: ::libc::c_int,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
}
impl ::std::clone::Clone for Struct_AlterExtensionContentsStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterExtensionContentsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterExtensionContentsStmt = Struct_AlterExtensionContentsStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateFdwStmt {
    pub _type: NodeTag,
    pub fdwname: *mut ::libc::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateFdwStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateFdwStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateFdwStmt = Struct_CreateFdwStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterFdwStmt {
    pub _type: NodeTag,
    pub fdwname: *mut ::libc::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterFdwStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterFdwStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterFdwStmt = Struct_AlterFdwStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateForeignServerStmt {
    pub _type: NodeTag,
    pub servername: *mut ::libc::c_char,
    pub servertype: *mut ::libc::c_char,
    pub version: *mut ::libc::c_char,
    pub fdwname: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateForeignServerStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateForeignServerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateForeignServerStmt = Struct_CreateForeignServerStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterForeignServerStmt {
    pub _type: NodeTag,
    pub servername: *mut ::libc::c_char,
    pub version: *mut ::libc::c_char,
    pub options: *mut List,
    pub has_version: _bool,
}
impl ::std::clone::Clone for Struct_AlterForeignServerStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterForeignServerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterForeignServerStmt = Struct_AlterForeignServerStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateForeignTableStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateForeignTableStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateForeignTableStmt = Struct_CreateForeignTableStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateUserMappingStmt {
    pub _type: NodeTag,
    pub username: *mut ::libc::c_char,
    pub servername: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateUserMappingStmt = Struct_CreateUserMappingStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterUserMappingStmt {
    pub _type: NodeTag,
    pub username: *mut ::libc::c_char,
    pub servername: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterUserMappingStmt = Struct_AlterUserMappingStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropUserMappingStmt {
    pub _type: NodeTag,
    pub username: *mut ::libc::c_char,
    pub servername: *mut ::libc::c_char,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_DropUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropUserMappingStmt = Struct_DropUserMappingStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::libc::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: _bool,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub isconstraint: _bool,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub constrrel: *mut RangeVar,
}
impl ::std::clone::Clone for Struct_CreateTrigStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTrigStmt = Struct_CreateTrigStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateEventTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::libc::c_char,
    pub eventname: *mut ::libc::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
impl ::std::clone::Clone for Struct_CreateEventTrigStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateEventTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateEventTrigStmt = Struct_CreateEventTrigStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterEventTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::libc::c_char,
    pub tgenabled: ::libc::c_char,
}
impl ::std::clone::Clone for Struct_AlterEventTrigStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterEventTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterEventTrigStmt = Struct_AlterEventTrigStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreatePLangStmt {
    pub _type: NodeTag,
    pub replace: _bool,
    pub plname: *mut ::libc::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: _bool,
}
impl ::std::clone::Clone for Struct_CreatePLangStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreatePLangStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreatePLangStmt = Struct_CreatePLangStmt;
pub type Enum_RoleStmtType = ::libc::c_uint;
pub const ROLESTMT_ROLE: ::libc::c_uint = 0;
pub const ROLESTMT_USER: ::libc::c_uint = 1;
pub const ROLESTMT_GROUP: ::libc::c_uint = 2;
pub type RoleStmtType = Enum_RoleStmtType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateRoleStmt {
    pub _type: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateRoleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateRoleStmt = Struct_CreateRoleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterRoleStmt {
    pub _type: NodeTag,
    pub role: *mut ::libc::c_char,
    pub options: *mut List,
    pub action: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_AlterRoleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterRoleStmt = Struct_AlterRoleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterRoleSetStmt {
    pub _type: NodeTag,
    pub role: *mut ::libc::c_char,
    pub database: *mut ::libc::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::clone::Clone for Struct_AlterRoleSetStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterRoleSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterRoleSetStmt = Struct_AlterRoleSetStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropRoleStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_DropRoleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropRoleStmt = Struct_DropRoleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateSeqStmt {
    pub _type: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
}
impl ::std::clone::Clone for Struct_CreateSeqStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateSeqStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateSeqStmt = Struct_CreateSeqStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterSeqStmt {
    pub _type: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterSeqStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterSeqStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterSeqStmt = Struct_AlterSeqStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DefineStmt {
    pub _type: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: _bool,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
}
impl ::std::clone::Clone for Struct_DefineStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DefineStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DefineStmt = Struct_DefineStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateDomainStmt {
    pub _type: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
impl ::std::clone::Clone for Struct_CreateDomainStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateDomainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateDomainStmt = Struct_CreateDomainStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateOpClassStmt {
    pub _type: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::libc::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: _bool,
}
impl ::std::clone::Clone for Struct_CreateOpClassStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateOpClassStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpClassStmt = Struct_CreateOpClassStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateOpClassItem {
    pub _type: NodeTag,
    pub itemtype: ::libc::c_int,
    pub name: *mut List,
    pub args: *mut List,
    pub number: ::libc::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
impl ::std::clone::Clone for Struct_CreateOpClassItem {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateOpClassItem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpClassItem = Struct_CreateOpClassItem;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateOpFamilyStmt {
    pub _type: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_CreateOpFamilyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateOpFamilyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpFamilyStmt = Struct_CreateOpFamilyStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterOpFamilyStmt {
    pub _type: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::libc::c_char,
    pub isDrop: _bool,
    pub items: *mut List,
}
impl ::std::clone::Clone for Struct_AlterOpFamilyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterOpFamilyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterOpFamilyStmt = Struct_AlterOpFamilyStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropStmt {
    pub _type: NodeTag,
    pub objects: *mut List,
    pub arguments: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
    pub concurrent: _bool,
}
impl ::std::clone::Clone for Struct_DropStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropStmt = Struct_DropStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TruncateStmt {
    pub _type: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: _bool,
    pub behavior: DropBehavior,
}
impl ::std::clone::Clone for Struct_TruncateStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TruncateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TruncateStmt = Struct_TruncateStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CommentStmt {
    pub _type: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub comment: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_CommentStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CommentStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CommentStmt = Struct_CommentStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SecLabelStmt {
    pub _type: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub provider: *mut ::libc::c_char,
    pub label: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_SecLabelStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SecLabelStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SecLabelStmt = Struct_SecLabelStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DeclareCursorStmt {
    pub _type: NodeTag,
    pub portalname: *mut ::libc::c_char,
    pub options: ::libc::c_int,
    pub query: *mut Node,
}
impl ::std::clone::Clone for Struct_DeclareCursorStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DeclareCursorStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeclareCursorStmt = Struct_DeclareCursorStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ClosePortalStmt {
    pub _type: NodeTag,
    pub portalname: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_ClosePortalStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ClosePortalStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ClosePortalStmt = Struct_ClosePortalStmt;
pub type Enum_FetchDirection = ::libc::c_uint;
pub const FETCH_FORWARD: ::libc::c_uint = 0;
pub const FETCH_BACKWARD: ::libc::c_uint = 1;
pub const FETCH_ABSOLUTE: ::libc::c_uint = 2;
pub const FETCH_RELATIVE: ::libc::c_uint = 3;
pub type FetchDirection = Enum_FetchDirection;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FetchStmt {
    pub _type: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::libc::c_long,
    pub portalname: *mut ::libc::c_char,
    pub ismove: _bool,
}
impl ::std::clone::Clone for Struct_FetchStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FetchStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FetchStmt = Struct_FetchStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IndexStmt {
    pub _type: NodeTag,
    pub idxname: *mut ::libc::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::libc::c_char,
    pub tableSpace: *mut ::libc::c_char,
    pub indexParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::libc::c_char,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub unique: _bool,
    pub primary: _bool,
    pub isconstraint: _bool,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub concurrent: _bool,
}
impl ::std::clone::Clone for Struct_IndexStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IndexStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexStmt = Struct_IndexStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateFunctionStmt {
    pub _type: NodeTag,
    pub replace: _bool,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
    pub withClause: *mut List,
}
impl ::std::clone::Clone for Struct_CreateFunctionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateFunctionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateFunctionStmt = Struct_CreateFunctionStmt;
pub type Enum_FunctionParameterMode = ::libc::c_uint;
pub const FUNC_PARAM_IN: ::libc::c_uint = 105;
pub const FUNC_PARAM_OUT: ::libc::c_uint = 111;
pub const FUNC_PARAM_INOUT: ::libc::c_uint = 98;
pub const FUNC_PARAM_VARIADIC: ::libc::c_uint = 118;
pub const FUNC_PARAM_TABLE: ::libc::c_uint = 116;
pub type FunctionParameterMode = Enum_FunctionParameterMode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FunctionParameter {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
impl ::std::clone::Clone for Struct_FunctionParameter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FunctionParameter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FunctionParameter = Struct_FunctionParameter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterFunctionStmt {
    pub _type: NodeTag,
    pub func: *mut FuncWithArgs,
    pub actions: *mut List,
}
impl ::std::clone::Clone for Struct_AlterFunctionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterFunctionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterFunctionStmt = Struct_AlterFunctionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DoStmt {
    pub _type: NodeTag,
    pub args: *mut List,
}
impl ::std::clone::Clone for Struct_DoStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DoStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DoStmt = Struct_DoStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_InlineCodeBlock {
    pub _type: NodeTag,
    pub source_text: *mut ::libc::c_char,
    pub langOid: Oid,
    pub langIsTrusted: _bool,
}
impl ::std::clone::Clone for Struct_InlineCodeBlock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_InlineCodeBlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type InlineCodeBlock = Struct_InlineCodeBlock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RenameStmt {
    pub _type: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub subname: *mut ::libc::c_char,
    pub newname: *mut ::libc::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_RenameStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RenameStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RenameStmt = Struct_RenameStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterObjectSchemaStmt {
    pub _type: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newschema: *mut ::libc::c_char,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterObjectSchemaStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterObjectSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterObjectSchemaStmt = Struct_AlterObjectSchemaStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterOwnerStmt {
    pub _type: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newowner: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_AlterOwnerStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterOwnerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterOwnerStmt = Struct_AlterOwnerStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RuleStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::libc::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: _bool,
    pub actions: *mut List,
    pub replace: _bool,
}
impl ::std::clone::Clone for Struct_RuleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RuleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RuleStmt = Struct_RuleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_NotifyStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::libc::c_char,
    pub payload: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_NotifyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_NotifyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NotifyStmt = Struct_NotifyStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ListenStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_ListenStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ListenStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ListenStmt = Struct_ListenStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_UnlistenStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_UnlistenStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_UnlistenStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type UnlistenStmt = Struct_UnlistenStmt;
pub type Enum_TransactionStmtKind = ::libc::c_uint;
pub const TRANS_STMT_BEGIN: ::libc::c_uint = 0;
pub const TRANS_STMT_START: ::libc::c_uint = 1;
pub const TRANS_STMT_COMMIT: ::libc::c_uint = 2;
pub const TRANS_STMT_ROLLBACK: ::libc::c_uint = 3;
pub const TRANS_STMT_SAVEPOINT: ::libc::c_uint = 4;
pub const TRANS_STMT_RELEASE: ::libc::c_uint = 5;
pub const TRANS_STMT_ROLLBACK_TO: ::libc::c_uint = 6;
pub const TRANS_STMT_PREPARE: ::libc::c_uint = 7;
pub const TRANS_STMT_COMMIT_PREPARED: ::libc::c_uint = 8;
pub const TRANS_STMT_ROLLBACK_PREPARED: ::libc::c_uint = 9;
pub type TransactionStmtKind = Enum_TransactionStmtKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TransactionStmt {
    pub _type: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub gid: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_TransactionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TransactionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TransactionStmt = Struct_TransactionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CompositeTypeStmt {
    pub _type: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
impl ::std::clone::Clone for Struct_CompositeTypeStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CompositeTypeStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CompositeTypeStmt = Struct_CompositeTypeStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateEnumStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
impl ::std::clone::Clone for Struct_CreateEnumStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateEnumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateEnumStmt = Struct_CreateEnumStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateRangeStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
impl ::std::clone::Clone for Struct_CreateRangeStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateRangeStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateRangeStmt = Struct_CreateRangeStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterEnumStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub newVal: *mut ::libc::c_char,
    pub newValNeighbor: *mut ::libc::c_char,
    pub newValIsAfter: _bool,
    pub skipIfExists: _bool,
}
impl ::std::clone::Clone for Struct_AlterEnumStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterEnumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterEnumStmt = Struct_AlterEnumStmt;
pub type Enum_ViewCheckOption = ::libc::c_uint;
pub const NO_CHECK_OPTION: ::libc::c_uint = 0;
pub const LOCAL_CHECK_OPTION: ::libc::c_uint = 1;
pub const CASCADED_CHECK_OPTION: ::libc::c_uint = 2;
pub type ViewCheckOption = Enum_ViewCheckOption;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ViewStmt {
    pub _type: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: _bool,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption,
}
impl ::std::clone::Clone for Struct_ViewStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ViewStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ViewStmt = Struct_ViewStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LoadStmt {
    pub _type: NodeTag,
    pub filename: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_LoadStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LoadStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LoadStmt = Struct_LoadStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreatedbStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreatedbStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreatedbStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreatedbStmt = Struct_CreatedbStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterDatabaseStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::libc::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterDatabaseStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterDatabaseStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDatabaseStmt = Struct_AlterDatabaseStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterDatabaseSetStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::libc::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::clone::Clone for Struct_AlterDatabaseSetStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterDatabaseSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDatabaseSetStmt = Struct_AlterDatabaseSetStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropdbStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::libc::c_char,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_DropdbStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropdbStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropdbStmt = Struct_DropdbStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterSystemStmt {
    pub _type: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::clone::Clone for Struct_AlterSystemStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterSystemStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterSystemStmt = Struct_AlterSystemStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ClusterStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::libc::c_char,
    pub verbose: _bool,
}
impl ::std::clone::Clone for Struct_ClusterStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ClusterStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ClusterStmt = Struct_ClusterStmt;
pub type Enum_VacuumOption = ::libc::c_uint;
pub const VACOPT_VACUUM: ::libc::c_uint = 1;
pub const VACOPT_ANALYZE: ::libc::c_uint = 2;
pub const VACOPT_VERBOSE: ::libc::c_uint = 4;
pub const VACOPT_FREEZE: ::libc::c_uint = 8;
pub const VACOPT_FULL: ::libc::c_uint = 16;
pub const VACOPT_NOWAIT: ::libc::c_uint = 32;
pub type VacuumOption = Enum_VacuumOption;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VacuumStmt {
    pub _type: NodeTag,
    pub options: ::libc::c_int,
    pub freeze_min_age: ::libc::c_int,
    pub freeze_table_age: ::libc::c_int,
    pub multixact_freeze_min_age: ::libc::c_int,
    pub multixact_freeze_table_age: ::libc::c_int,
    pub relation: *mut RangeVar,
    pub va_cols: *mut List,
}
impl ::std::clone::Clone for Struct_VacuumStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VacuumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VacuumStmt = Struct_VacuumStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ExplainStmt {
    pub _type: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_ExplainStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ExplainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExplainStmt = Struct_ExplainStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateTableAsStmt {
    pub _type: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub relkind: ObjectType,
    pub is_select_into: _bool,
}
impl ::std::clone::Clone for Struct_CreateTableAsStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateTableAsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTableAsStmt = Struct_CreateTableAsStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RefreshMatViewStmt {
    pub _type: NodeTag,
    pub concurrent: _bool,
    pub skipData: _bool,
    pub relation: *mut RangeVar,
}
impl ::std::clone::Clone for Struct_RefreshMatViewStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RefreshMatViewStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RefreshMatViewStmt = Struct_RefreshMatViewStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CheckPointStmt {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_CheckPointStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CheckPointStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheckPointStmt = Struct_CheckPointStmt;
pub type Enum_DiscardMode = ::libc::c_uint;
pub const DISCARD_ALL: ::libc::c_uint = 0;
pub const DISCARD_PLANS: ::libc::c_uint = 1;
pub const DISCARD_SEQUENCES: ::libc::c_uint = 2;
pub const DISCARD_TEMP: ::libc::c_uint = 3;
pub type DiscardMode = Enum_DiscardMode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DiscardStmt {
    pub _type: NodeTag,
    pub target: DiscardMode,
}
impl ::std::clone::Clone for Struct_DiscardStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DiscardStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DiscardStmt = Struct_DiscardStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockStmt {
    pub _type: NodeTag,
    pub relations: *mut List,
    pub mode: ::libc::c_int,
    pub nowait: _bool,
}
impl ::std::clone::Clone for Struct_LockStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockStmt = Struct_LockStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ConstraintsSetStmt {
    pub _type: NodeTag,
    pub constraints: *mut List,
    pub deferred: _bool,
}
impl ::std::clone::Clone for Struct_ConstraintsSetStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ConstraintsSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConstraintsSetStmt = Struct_ConstraintsSetStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReindexStmt {
    pub _type: NodeTag,
    pub kind: ObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::libc::c_char,
    pub do_system: _bool,
    pub do_user: _bool,
}
impl ::std::clone::Clone for Struct_ReindexStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReindexStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReindexStmt = Struct_ReindexStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateConversionStmt {
    pub _type: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::libc::c_char,
    pub to_encoding_name: *mut ::libc::c_char,
    pub func_name: *mut List,
    pub def: _bool,
}
impl ::std::clone::Clone for Struct_CreateConversionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateConversionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateConversionStmt = Struct_CreateConversionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateCastStmt {
    pub _type: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut FuncWithArgs,
    pub context: CoercionContext,
    pub inout: _bool,
}
impl ::std::clone::Clone for Struct_CreateCastStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateCastStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateCastStmt = Struct_CreateCastStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PrepareStmt {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
impl ::std::clone::Clone for Struct_PrepareStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PrepareStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PrepareStmt = Struct_PrepareStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ExecuteStmt {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
    pub params: *mut List,
}
impl ::std::clone::Clone for Struct_ExecuteStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ExecuteStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExecuteStmt = Struct_ExecuteStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DeallocateStmt {
    pub _type: NodeTag,
    pub name: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_DeallocateStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DeallocateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeallocateStmt = Struct_DeallocateStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropOwnedStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
impl ::std::clone::Clone for Struct_DropOwnedStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropOwnedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropOwnedStmt = Struct_DropOwnedStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReassignOwnedStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_ReassignOwnedStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReassignOwnedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReassignOwnedStmt = Struct_ReassignOwnedStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTSDictionaryStmt {
    pub _type: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterTSDictionaryStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTSDictionaryStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTSDictionaryStmt = Struct_AlterTSDictionaryStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTSConfigurationStmt {
    pub _type: NodeTag,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub _override: _bool,
    pub replace: _bool,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterTSConfigurationStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTSConfigurationStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTSConfigurationStmt = Struct_AlterTSConfigurationStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::libc::c_short,
    pub l_whence: ::libc::c_short,
}
impl ::std::clone::Clone for Struct_flock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_flock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_timespec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_flocktimeout {
    pub fl: Struct_flock,
    pub timeout: Struct_timespec,
}
impl ::std::clone::Clone for Struct_flocktimeout {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_flocktimeout {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_radvisory {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_radvisory {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fcodeblobs {
    pub f_cd_hash: *mut ::libc::c_void,
    pub f_hash_size: size_t,
    pub f_cd_buffer: *mut ::libc::c_void,
    pub f_cd_size: size_t,
    pub f_out_size: *mut ::libc::c_uint,
    pub f_arch: ::libc::c_int,
    pub __padding: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_fcodeblobs {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fcodeblobs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fcodeblobs_t = Struct_fcodeblobs;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::libc::c_void,
    pub fs_blob_size: size_t,
}
impl ::std::clone::Clone for Struct_fsignatures {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fsignatures {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fsignatures_t = Struct_fsignatures;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fstore {
    pub fst_flags: ::libc::c_uint,
    pub fst_posmode: ::libc::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
impl ::std::clone::Clone for Struct_fstore {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fstore {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fstore_t = Struct_fstore;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fbootstraptransfer {
    pub fbt_offset: off_t,
    pub fbt_length: size_t,
    pub fbt_buffer: *mut ::libc::c_void,
}
impl ::std::clone::Clone for Struct_fbootstraptransfer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fbootstraptransfer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fbootstraptransfer_t = Struct_fbootstraptransfer;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_log2phys {
    pub l2p_flags: ::libc::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
impl ::std::clone::Clone for Struct_log2phys {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_log2phys {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__filesec { }
pub type filesec_t = *mut Struct__filesec;
pub type Enum_Unnamed37 = ::libc::c_uint;
pub const FILESEC_OWNER: ::libc::c_uint = 1;
pub const FILESEC_GROUP: ::libc::c_uint = 2;
pub const FILESEC_UUID: ::libc::c_uint = 3;
pub const FILESEC_MODE: ::libc::c_uint = 4;
pub const FILESEC_ACL: ::libc::c_uint = 5;
pub const FILESEC_GRPUUID: ::libc::c_uint = 6;
pub const FILESEC_ACL_RAW: ::libc::c_uint = 100;
pub const FILESEC_ACL_ALLOCSIZE: ::libc::c_uint = 101;
pub type filesec_property_t = Enum_Unnamed37;
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VariableCacheData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextXid: TransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub latestCompletedXid: TransactionId,
}
impl ::std::clone::Clone for Struct_VariableCacheData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VariableCacheData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableCacheData = Struct_VariableCacheData;
pub type VariableCache = *mut VariableCacheData;
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed38 {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
impl ::std::clone::Clone for Struct_Unnamed38 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed38 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageXLogRecPtr = Struct_Unnamed38;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: [ItemIdData; 1usize],
}
impl ::std::clone::Clone for Struct_PageHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageHeaderData = Struct_PageHeaderData;
pub type PageHeader = *mut PageHeaderData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: Union_Unnamed39,
}
impl ::std::clone::Clone for Struct_HeapTupleFields {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleFields {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed39 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed39 {
    pub unsafe fn t_cid(&mut self) -> *mut CommandId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn t_xvac(&mut self) -> *mut TransactionId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed39 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed39 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTupleFields = Struct_HeapTupleFields;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
impl ::std::clone::Clone for Struct_DatumTupleFields {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DatumTupleFields {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DatumTupleFields = Struct_DatumTupleFields;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleHeaderData {
    pub t_choice: Union_Unnamed40,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: [bits8; 1usize],
}
impl ::std::clone::Clone for Struct_HeapTupleHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed40 {
    pub _bindgen_data_: [u32; 3usize],
}
impl Union_Unnamed40 {
    pub unsafe fn t_heap(&mut self) -> *mut HeapTupleFields {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn t_datum(&mut self) -> *mut DatumTupleFields {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed40 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed40 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::libc::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: [bits8; 1usize],
}
impl ::std::clone::Clone for Struct_MinimalTupleData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MinimalTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_node = Struct_dlist_node;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_head {
    pub head: dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_head {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_head = Struct_dlist_head;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_iter = Struct_dlist_iter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_mutable_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_mutable_iter = Struct_dlist_mutable_iter;
pub type slist_node = Struct_slist_node;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_node {
    pub next: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_head {
    pub head: slist_node,
}
impl ::std::clone::Clone for Struct_slist_head {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_head = Struct_slist_head;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_iter {
    pub cur: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_iter = Struct_slist_iter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_mutable_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_mutable_iter = Struct_slist_mutable_iter;
pub type Enum_ForkNumber = ::libc::c_int;
pub const InvalidForkNumber: ::libc::c_int = -1;
pub const MAIN_FORKNUM: ::libc::c_int = 0;
pub const FSM_FORKNUM: ::libc::c_int = 1;
pub const VISIBILITYMAP_FORKNUM: ::libc::c_int = 2;
pub const INIT_FORKNUM: ::libc::c_int = 3;
pub type ForkNumber = Enum_ForkNumber;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
impl ::std::clone::Clone for Struct_RelFileNode {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelFileNode {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelFileNode = Struct_RelFileNode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
impl ::std::clone::Clone for Struct_RelFileNodeBackend {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelFileNodeBackend {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelFileNodeBackend = Struct_RelFileNodeBackend;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed41 {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
impl ::std::clone::Clone for Struct_Unnamed41 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed41 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalCatcacheMsg = Struct_Unnamed41;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed42 {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed42 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed42 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalCatalogMsg = Struct_Unnamed42;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed43 {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed43 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed43 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalRelcacheMsg = Struct_Unnamed43;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed44 {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rnode: RelFileNode,
}
impl ::std::clone::Clone for Struct_Unnamed44 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed44 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalSmgrMsg = Struct_Unnamed44;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed45 {
    pub id: int8,
    pub dbId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed45 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed45 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalRelmapMsg = Struct_Unnamed45;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed46 {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed46 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed46 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalSnapshotMsg = Struct_Unnamed46;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed47 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed47 {
    pub unsafe fn id(&mut self) -> *mut int8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cc(&mut self) -> *mut SharedInvalCatcacheMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cat(&mut self) -> *mut SharedInvalCatalogMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn rc(&mut self) -> *mut SharedInvalRelcacheMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sm(&mut self) -> *mut SharedInvalSmgrMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn rm(&mut self) -> *mut SharedInvalRelmapMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sn(&mut self) -> *mut SharedInvalSnapshotMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed47 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed47 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalidationMessage = Union_Unnamed47;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_am {
    pub amname: NameData,
    pub amstrategies: int16,
    pub amsupport: int16,
    pub amcanorder: _bool,
    pub amcanorderbyop: _bool,
    pub amcanbackward: _bool,
    pub amcanunique: _bool,
    pub amcanmulticol: _bool,
    pub amoptionalkey: _bool,
    pub amsearcharray: _bool,
    pub amsearchnulls: _bool,
    pub amstorage: _bool,
    pub amclusterable: _bool,
    pub ampredlocks: _bool,
    pub amkeytype: Oid,
    pub aminsert: regproc,
    pub ambeginscan: regproc,
    pub amgettuple: regproc,
    pub amgetbitmap: regproc,
    pub amrescan: regproc,
    pub amendscan: regproc,
    pub ammarkpos: regproc,
    pub amrestrpos: regproc,
    pub ambuild: regproc,
    pub ambuildempty: regproc,
    pub ambulkdelete: regproc,
    pub amvacuumcleanup: regproc,
    pub amcanreturn: regproc,
    pub amcostestimate: regproc,
    pub amoptions: regproc,
}
impl ::std::clone::Clone for Struct_FormData_pg_am {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_am {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_am = Struct_FormData_pg_am;
pub type Form_pg_am = *mut FormData_pg_am;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indisunique: _bool,
    pub indisprimary: _bool,
    pub indisexclusion: _bool,
    pub indimmediate: _bool,
    pub indisclustered: _bool,
    pub indisvalid: _bool,
    pub indcheckxmin: _bool,
    pub indisready: _bool,
    pub indislive: _bool,
    pub indisreplident: _bool,
    pub indkey: int2vector,
}
impl ::std::clone::Clone for Struct_FormData_pg_index {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_index {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_index = Struct_FormData_pg_index;
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::libc::c_char,
    pub isInstead: _bool,
}
impl ::std::clone::Clone for Struct_RewriteRule {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RewriteRule {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RewriteRule = Struct_RewriteRule;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RuleLock {
    pub numLocks: ::libc::c_int,
    pub rules: *mut *mut RewriteRule,
}
impl ::std::clone::Clone for Struct_RuleLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RuleLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RuleLock = Struct_RuleLock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::libc::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::libc::c_char,
    pub tgisinternal: _bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: _bool,
    pub tginitdeferred: _bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::libc::c_char,
    pub tgqual: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_Trigger {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Trigger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Trigger = Struct_Trigger;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::libc::c_int,
    pub trig_insert_before_row: _bool,
    pub trig_insert_after_row: _bool,
    pub trig_insert_instead_row: _bool,
    pub trig_insert_before_statement: _bool,
    pub trig_insert_after_statement: _bool,
    pub trig_update_before_row: _bool,
    pub trig_update_after_row: _bool,
    pub trig_update_instead_row: _bool,
    pub trig_update_before_statement: _bool,
    pub trig_update_after_statement: _bool,
    pub trig_delete_before_row: _bool,
    pub trig_delete_after_row: _bool,
    pub trig_delete_instead_row: _bool,
    pub trig_delete_before_statement: _bool,
    pub trig_delete_after_statement: _bool,
    pub trig_truncate_before_statement: _bool,
    pub trig_truncate_after_statement: _bool,
}
impl ::std::clone::Clone for Struct_TriggerDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TriggerDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TriggerDesc = Struct_TriggerDesc;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
impl ::std::clone::Clone for Struct_LockRelId {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockRelId {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockRelId = Struct_LockRelId;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockInfoData {
    pub lockRelId: LockRelId,
}
impl ::std::clone::Clone for Struct_LockInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockInfoData = Struct_LockInfoData;
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelationAmInfo {
    pub aminsert: FmgrInfo,
    pub ambeginscan: FmgrInfo,
    pub amgettuple: FmgrInfo,
    pub amgetbitmap: FmgrInfo,
    pub amrescan: FmgrInfo,
    pub amendscan: FmgrInfo,
    pub ammarkpos: FmgrInfo,
    pub amrestrpos: FmgrInfo,
    pub amcanreturn: FmgrInfo,
}
impl ::std::clone::Clone for Struct_RelationAmInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelationAmInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelationAmInfo = Struct_RelationAmInfo;
pub enum Struct_SMgrRelationData { }
pub enum Struct_FdwRoutine { }
pub enum Struct_PgStat_TableStatus { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: *mut Struct_SMgrRelationData,
    pub rd_refcnt: ::libc::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: _bool,
    pub rd_isnailed: _bool,
    pub rd_isvalid: _bool,
    pub rd_indexvalid: ::libc::c_char,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_indexlist: *mut List,
    pub rd_oidindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_indexattr: *mut Bitmapset,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_options: *mut bytea,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut Struct_HeapTupleData,
    pub rd_am: Form_pg_am,
    pub rd_indexcxt: MemoryContext,
    pub rd_aminfo: *mut RelationAmInfo,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_amcache: *mut ::libc::c_void,
    pub rd_indcollation: *mut Oid,
    pub rd_fdwroutine: *mut Struct_FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_info: *mut Struct_PgStat_TableStatus,
}
impl ::std::clone::Clone for Struct_RelationData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelationData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelationData = Struct_RelationData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AutoVacOpts {
    pub enabled: _bool,
    pub vacuum_threshold: ::libc::c_int,
    pub analyze_threshold: ::libc::c_int,
    pub vacuum_cost_delay: ::libc::c_int,
    pub vacuum_cost_limit: ::libc::c_int,
    pub freeze_min_age: ::libc::c_int,
    pub freeze_max_age: ::libc::c_int,
    pub freeze_table_age: ::libc::c_int,
    pub multixact_freeze_min_age: ::libc::c_int,
    pub multixact_freeze_max_age: ::libc::c_int,
    pub multixact_freeze_table_age: ::libc::c_int,
    pub vacuum_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
impl ::std::clone::Clone for Struct_AutoVacOpts {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AutoVacOpts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AutoVacOpts = Struct_AutoVacOpts;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::libc::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: _bool,
}
impl ::std::clone::Clone for Struct_StdRdOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_StdRdOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StdRdOptions = Struct_StdRdOptions;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: _bool,
    pub check_option_offset: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_ViewOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ViewOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ViewOptions = Struct_ViewOptions;
pub type float_t = ::libc::c_float;
pub type double_t = ::libc::c_double;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___float2 {
    pub __sinval: ::libc::c_float,
    pub __cosval: ::libc::c_float,
}
impl ::std::clone::Clone for Struct___float2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___float2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___double2 {
    pub __sinval: ::libc::c_double,
    pub __cosval: ::libc::c_double,
}
impl ::std::clone::Clone for Struct___double2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___double2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_exception {
    pub _type: ::libc::c_int,
    pub name: *mut ::libc::c_char,
    pub arg1: ::libc::c_double,
    pub arg2: ::libc::c_double,
    pub retval: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_exception {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_exception {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed48 {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
impl ::std::clone::Clone for Struct_Unnamed48 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed48 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Interval = Struct_Unnamed48;
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pg_tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
    pub tm_gmtoff: ::libc::c_long,
    pub tm_zone: *const ::libc::c_char,
}
impl ::std::clone::Clone for Struct_pg_tm {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pg_tm {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_pg_tz { }
pub type pg_tz = Struct_pg_tz;
pub enum Struct_pg_tzenum { }
pub type pg_tzenum = Struct_pg_tzenum;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferTupleBuf {
    pub node: slist_node,
    pub tuple: HeapTupleData,
    pub header: HeapTupleHeaderData,
    pub data: [::libc::c_char; 8160usize],
}
impl ::std::clone::Clone for Struct_ReorderBufferTupleBuf {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferTupleBuf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferTupleBuf = Struct_ReorderBufferTupleBuf;
pub type Enum_ReorderBufferChangeType = ::libc::c_uint;
pub const REORDER_BUFFER_CHANGE_INSERT: ::libc::c_uint = 0;
pub const REORDER_BUFFER_CHANGE_UPDATE: ::libc::c_uint = 1;
pub const REORDER_BUFFER_CHANGE_DELETE: ::libc::c_uint = 2;
pub const REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: ::libc::c_uint = 3;
pub const REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID: ::libc::c_uint = 4;
pub const REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID: ::libc::c_uint = 5;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferChange {
    pub lsn: XLogRecPtr,
    pub action: Enum_ReorderBufferChangeType,
    pub data: Union_Unnamed49,
    pub node: dlist_node,
}
impl ::std::clone::Clone for Struct_ReorderBufferChange {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferChange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed49 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed49 {
    pub unsafe fn tp(&mut self) -> *mut Struct_Unnamed50 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn snapshot(&mut self) -> *mut Snapshot {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn command_id(&mut self) -> *mut CommandId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tuplecid(&mut self) -> *mut Struct_Unnamed51 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed49 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed49 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed50 {
    pub relnode: RelFileNode,
    pub clear_toast_afterwards: _bool,
    pub oldtuple: *mut ReorderBufferTupleBuf,
    pub newtuple: *mut ReorderBufferTupleBuf,
}
impl ::std::clone::Clone for Struct_Unnamed50 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed50 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed51 {
    pub node: RelFileNode,
    pub tid: ItemPointerData,
    pub cmin: CommandId,
    pub cmax: CommandId,
    pub combocid: CommandId,
}
impl ::std::clone::Clone for Struct_Unnamed51 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed51 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferChange = Struct_ReorderBufferChange;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferTXN {
    pub xid: TransactionId,
    pub has_catalog_changes: _bool,
    pub is_known_as_subxact: _bool,
    pub first_lsn: XLogRecPtr,
    pub final_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub restart_decoding_lsn: XLogRecPtr,
    pub commit_time: TimestampTz,
    pub base_snapshot: Snapshot,
    pub base_snapshot_lsn: XLogRecPtr,
    pub nentries: uint64,
    pub nentries_mem: uint64,
    pub changes: dlist_head,
    pub tuplecids: dlist_head,
    pub ntuplecids: uint64,
    pub tuplecid_hash: *mut HTAB,
    pub toast_hash: *mut HTAB,
    pub subtxns: dlist_head,
    pub nsubtxns: uint32,
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
    pub node: dlist_node,
}
impl ::std::clone::Clone for Struct_ReorderBufferTXN {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferTXN {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferTXN = Struct_ReorderBufferTXN;
pub type ReorderBuffer = Struct_ReorderBuffer;
pub type ReorderBufferApplyChangeCB =
    ::std::option::Option<extern "C" fn(rb: *mut ReorderBuffer,
                                        txn: *mut ReorderBufferTXN,
                                        relation: Relation,
                                        change: *mut ReorderBufferChange)
                              -> ()>;
pub type ReorderBufferBeginCB =
    ::std::option::Option<extern "C" fn(rb: *mut ReorderBuffer,
                                        txn: *mut ReorderBufferTXN) -> ()>;
pub type ReorderBufferCommitCB =
    ::std::option::Option<extern "C" fn(rb: *mut ReorderBuffer,
                                        txn: *mut ReorderBufferTXN,
                                        commit_lsn: XLogRecPtr) -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBuffer {
    pub by_txn: *mut HTAB,
    pub toplevel_by_lsn: dlist_head,
    pub by_txn_last_xid: TransactionId,
    pub by_txn_last_txn: *mut ReorderBufferTXN,
    pub begin: ReorderBufferBeginCB,
    pub apply_change: ReorderBufferApplyChangeCB,
    pub commit: ReorderBufferCommitCB,
    pub private_data: *mut ::libc::c_void,
    pub context: MemoryContext,
    pub cached_transactions: dlist_head,
    pub nr_cached_transactions: Size,
    pub cached_changes: dlist_head,
    pub nr_cached_changes: Size,
    pub cached_tuplebufs: slist_head,
    pub nr_cached_tuplebufs: Size,
    pub current_restart_decoding_lsn: XLogRecPtr,
    pub outbuf: *mut ::libc::c_char,
    pub outbufsize: Size,
}
impl ::std::clone::Clone for Struct_ReorderBuffer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBuffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_OutputPluginOutputType = ::libc::c_uint;
pub const OUTPUT_PLUGIN_BINARY_OUTPUT: ::libc::c_uint = 0;
pub const OUTPUT_PLUGIN_TEXTUAL_OUTPUT: ::libc::c_uint = 1;
pub type OutputPluginOutputType = Enum_OutputPluginOutputType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OutputPluginOptions {
    pub output_type: OutputPluginOutputType,
}
impl ::std::clone::Clone for Struct_OutputPluginOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OutputPluginOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputPluginOptions = Struct_OutputPluginOptions;
pub type LogicalOutputPluginInit =
    ::std::option::Option<extern "C" fn(cb: *mut Struct_OutputPluginCallbacks)
                              -> ()>;
pub type LogicalDecodeStartupCB =
    ::std::option::Option<extern "C" fn(ctx:
                                            *mut Struct_LogicalDecodingContext,
                                        options: *mut OutputPluginOptions,
                                        is_init: _bool) -> ()>;
pub type LogicalDecodeBeginCB =
    ::std::option::Option<extern "C" fn(arg1:
                                            *mut Struct_LogicalDecodingContext,
                                        txn: *mut ReorderBufferTXN) -> ()>;
pub type LogicalDecodeChangeCB =
    ::std::option::Option<extern "C" fn(arg1:
                                            *mut Struct_LogicalDecodingContext,
                                        txn: *mut ReorderBufferTXN,
                                        relation: Relation,
                                        change: *mut ReorderBufferChange)
                              -> ()>;
pub type LogicalDecodeCommitCB =
    ::std::option::Option<extern "C" fn(arg1:
                                            *mut Struct_LogicalDecodingContext,
                                        txn: *mut ReorderBufferTXN,
                                        commit_lsn: XLogRecPtr) -> ()>;
pub type LogicalDecodeShutdownCB =
    ::std::option::Option<extern "C" fn(arg1:
                                            *mut Struct_LogicalDecodingContext)
                              -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OutputPluginCallbacks {
    pub startup_cb: LogicalDecodeStartupCB,
    pub begin_cb: LogicalDecodeBeginCB,
    pub change_cb: LogicalDecodeChangeCB,
    pub commit_cb: LogicalDecodeCommitCB,
    pub shutdown_cb: LogicalDecodeShutdownCB,
}
impl ::std::clone::Clone for Struct_OutputPluginCallbacks {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OutputPluginCallbacks {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputPluginCallbacks = Struct_OutputPluginCallbacks;
pub type RmgrId = uint8;
pub type Enum_RmgrIds = ::libc::c_uint;
pub const RM_XLOG_ID: ::libc::c_uint = 0;
pub const RM_XACT_ID: ::libc::c_uint = 1;
pub const RM_SMGR_ID: ::libc::c_uint = 2;
pub const RM_CLOG_ID: ::libc::c_uint = 3;
pub const RM_DBASE_ID: ::libc::c_uint = 4;
pub const RM_TBLSPC_ID: ::libc::c_uint = 5;
pub const RM_MULTIXACT_ID: ::libc::c_uint = 6;
pub const RM_RELMAP_ID: ::libc::c_uint = 7;
pub const RM_STANDBY_ID: ::libc::c_uint = 8;
pub const RM_HEAP2_ID: ::libc::c_uint = 9;
pub const RM_HEAP_ID: ::libc::c_uint = 10;
pub const RM_BTREE_ID: ::libc::c_uint = 11;
pub const RM_HASH_ID: ::libc::c_uint = 12;
pub const RM_GIN_ID: ::libc::c_uint = 13;
pub const RM_GIST_ID: ::libc::c_uint = 14;
pub const RM_SEQ_ID: ::libc::c_uint = 15;
pub const RM_SPGIST_ID: ::libc::c_uint = 16;
pub const RM_NEXT_ID: ::libc::c_uint = 17;
pub type RmgrIds = Enum_RmgrIds;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_StringInfoData {
    pub data: *mut ::libc::c_char,
    pub len: ::libc::c_int,
    pub maxlen: ::libc::c_int,
    pub cursor: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_StringInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_StringInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StringInfoData = Struct_StringInfoData;
pub type StringInfo = *mut StringInfoData;
pub type pg_crc32 = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_len: uint32,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_prev: XLogRecPtr,
    pub xl_crc: pg_crc32,
}
impl ::std::clone::Clone for Struct_XLogRecord {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecord {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecord = Struct_XLogRecord;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecData {
    pub data: *mut ::libc::c_char,
    pub len: uint32,
    pub buffer: Buffer,
    pub buffer_std: _bool,
    pub next: *mut Struct_XLogRecData,
}
impl ::std::clone::Clone for Struct_XLogRecData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecData = Struct_XLogRecData;
pub type Enum_Unnamed52 = ::libc::c_uint;
pub const STANDBY_DISABLED: ::libc::c_uint = 0;
pub const STANDBY_INITIALIZED: ::libc::c_uint = 1;
pub const STANDBY_SNAPSHOT_PENDING: ::libc::c_uint = 2;
pub const STANDBY_SNAPSHOT_READY: ::libc::c_uint = 3;
pub type HotStandbyState = Enum_Unnamed52;
pub type Enum_Unnamed53 = ::libc::c_uint;
pub const RECOVERY_TARGET_UNSET: ::libc::c_uint = 0;
pub const RECOVERY_TARGET_XID: ::libc::c_uint = 1;
pub const RECOVERY_TARGET_TIME: ::libc::c_uint = 2;
pub const RECOVERY_TARGET_NAME: ::libc::c_uint = 3;
pub const RECOVERY_TARGET_IMMEDIATE: ::libc::c_uint = 4;
pub type RecoveryTargetType = Enum_Unnamed53;
pub type Enum_WalLevel = ::libc::c_uint;
pub const WAL_LEVEL_MINIMAL: ::libc::c_uint = 0;
pub const WAL_LEVEL_ARCHIVE: ::libc::c_uint = 1;
pub const WAL_LEVEL_HOT_STANDBY: ::libc::c_uint = 2;
pub const WAL_LEVEL_LOGICAL: ::libc::c_uint = 3;
pub type WalLevel = Enum_WalLevel;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::libc::c_int,
    pub ckpt_segs_added: ::libc::c_int,
    pub ckpt_segs_removed: ::libc::c_int,
    pub ckpt_segs_recycled: ::libc::c_int,
    pub ckpt_sync_rels: ::libc::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
impl ::std::clone::Clone for Struct_CheckpointStatsData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CheckpointStatsData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheckpointStatsData = Struct_CheckpointStatsData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BkpBlock {
    pub node: RelFileNode,
    pub fork: ForkNumber,
    pub block: BlockNumber,
    pub hole_offset: uint16,
    pub hole_length: uint16,
}
impl ::std::clone::Clone for Struct_BkpBlock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BkpBlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BkpBlock = Struct_BkpBlock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogPageHeaderData {
    pub xlp_magic: uint16,
    pub xlp_info: uint16,
    pub xlp_tli: TimeLineID,
    pub xlp_pageaddr: XLogRecPtr,
    pub xlp_rem_len: uint32,
}
impl ::std::clone::Clone for Struct_XLogPageHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogPageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogPageHeaderData = Struct_XLogPageHeaderData;
pub type XLogPageHeader = *mut XLogPageHeaderData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogLongPageHeaderData {
    pub std: XLogPageHeaderData,
    pub xlp_sysid: uint64,
    pub xlp_seg_size: uint32,
    pub xlp_xlog_blcksz: uint32,
}
impl ::std::clone::Clone for Struct_XLogLongPageHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogLongPageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogLongPageHeaderData = Struct_XLogLongPageHeaderData;
pub type XLogLongPageHeader = *mut XLogLongPageHeaderData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_xl_parameter_change {
    pub MaxConnections: ::libc::c_int,
    pub max_worker_processes: ::libc::c_int,
    pub max_prepared_xacts: ::libc::c_int,
    pub max_locks_per_xact: ::libc::c_int,
    pub wal_level: ::libc::c_int,
    pub wal_log_hints: _bool,
}
impl ::std::clone::Clone for Struct_xl_parameter_change {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_xl_parameter_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_parameter_change = Struct_xl_parameter_change;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_xl_restore_point {
    pub rp_time: TimestampTz,
    pub rp_name: [::libc::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_xl_restore_point {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_xl_restore_point {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_restore_point = Struct_xl_restore_point;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_xl_end_of_recovery {
    pub end_time: TimestampTz,
    pub ThisTimeLineID: TimeLineID,
    pub PrevTimeLineID: TimeLineID,
}
impl ::std::clone::Clone for Struct_xl_end_of_recovery {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_xl_end_of_recovery {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type xl_end_of_recovery = Struct_xl_end_of_recovery;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RmgrData {
    pub rm_name: *const ::libc::c_char,
    pub rm_redo:
        ::std::option::Option<extern "C" fn(lsn: XLogRecPtr,
                                            rptr: *mut Struct_XLogRecord)
                                             -> ()>,
    pub rm_desc: ::std::option::Option<extern "C" fn(buf: StringInfo,
                                                     xl_info: uint8,
                                                     rec: *mut ::libc::c_char)
                                           -> ()>,
    pub rm_startup: ::std::option::Option<extern "C" fn() -> ()>,
    pub rm_cleanup: ::std::option::Option<extern "C" fn() -> ()>,
}
impl ::std::clone::Clone for Struct_RmgrData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RmgrData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RmgrData = Struct_RmgrData;
pub type XLogReaderState = Struct_XLogReaderState;
pub type XLogPageReadCB =
    ::std::option::Option<extern "C" fn(xlogreader: *mut XLogReaderState,
                                        targetPagePtr: XLogRecPtr,
                                        reqLen: ::libc::c_int,
                                        targetRecPtr: XLogRecPtr,
                                        readBuf: *mut ::libc::c_char,
                                        pageTLI: *mut TimeLineID)
                              -> ::libc::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogReaderState {
    pub read_page: XLogPageReadCB,
    pub system_identifier: uint64,
    pub private_data: *mut ::libc::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub readBuf: *mut ::libc::c_char,
    pub readSegNo: XLogSegNo,
    pub readOff: uint32,
    pub readLen: uint32,
    pub readPageTLI: TimeLineID,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub readRecordBuf: *mut ::libc::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::libc::c_char,
}
impl ::std::clone::Clone for Struct_XLogReaderState {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogReaderState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_ReplicationSlotPersistency = ::libc::c_uint;
pub const RS_PERSISTENT: ::libc::c_uint = 0;
pub const RS_EPHEMERAL: ::libc::c_uint = 1;
pub type ReplicationSlotPersistency = Enum_ReplicationSlotPersistency;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlotPersistentData {
    pub name: NameData,
    pub database: Oid,
    pub persistency: ReplicationSlotPersistency,
    pub xmin: TransactionId,
    pub catalog_xmin: TransactionId,
    pub restart_lsn: XLogRecPtr,
    pub confirmed_flush: XLogRecPtr,
    pub plugin: NameData,
}
impl ::std::clone::Clone for Struct_ReplicationSlotPersistentData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlotPersistentData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlotPersistentData = Struct_ReplicationSlotPersistentData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlot {
    pub mutex: slock_t,
    pub in_use: _bool,
    pub active: _bool,
    pub just_dirtied: _bool,
    pub dirty: _bool,
    pub effective_xmin: TransactionId,
    pub effective_catalog_xmin: TransactionId,
    pub data: ReplicationSlotPersistentData,
    pub io_in_progress_lock: *mut LWLock,
    pub candidate_catalog_xmin: TransactionId,
    pub candidate_xmin_lsn: XLogRecPtr,
    pub candidate_restart_valid: XLogRecPtr,
    pub candidate_restart_lsn: XLogRecPtr,
}
impl ::std::clone::Clone for Struct_ReplicationSlot {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlot {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlot = Struct_ReplicationSlot;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlotCtlData {
    pub replication_slots: [ReplicationSlot; 1usize],
}
impl ::std::clone::Clone for Struct_ReplicationSlotCtlData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlotCtlData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlotCtlData = Struct_ReplicationSlotCtlData;
pub type LogicalOutputPluginWriterWrite =
    ::std::option::Option<extern "C" fn(lr:
                                            *mut Struct_LogicalDecodingContext,
                                        Ptr: XLogRecPtr, xid: TransactionId,
                                        last_write: _bool) -> ()>;
pub type LogicalOutputPluginWriterPrepareWrite =
    LogicalOutputPluginWriterWrite;
pub enum Struct_SnapBuild { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LogicalDecodingContext {
    pub context: MemoryContext,
    pub reader: *mut XLogReaderState,
    pub slot: *mut ReplicationSlot,
    pub reorder: *mut Struct_ReorderBuffer,
    pub snapshot_builder: *mut Struct_SnapBuild,
    pub callbacks: OutputPluginCallbacks,
    pub options: OutputPluginOptions,
    pub output_plugin_options: *mut List,
    pub prepare_write: LogicalOutputPluginWriterPrepareWrite,
    pub write: LogicalOutputPluginWriterWrite,
    pub out: StringInfo,
    pub output_plugin_private: *mut ::libc::c_void,
    pub output_writer_private: *mut ::libc::c_void,
    pub accept_writes: _bool,
    pub prepared_write: _bool,
    pub write_location: XLogRecPtr,
    pub write_xid: TransactionId,
}
impl ::std::clone::Clone for Struct_LogicalDecodingContext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LogicalDecodingContext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LogicalDecodingContext = Struct_LogicalDecodingContext;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::libc::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
impl ::std::clone::Clone for Struct_OpBtreeInterpretation {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OpBtreeInterpretation {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OpBtreeInterpretation = Struct_OpBtreeInterpretation;
pub type Enum_IOFuncSelector = ::libc::c_uint;
pub const IOFunc_input: ::libc::c_uint = 0;
pub const IOFunc_output: ::libc::c_uint = 1;
pub const IOFunc_receive: ::libc::c_uint = 2;
pub const IOFunc_send: ::libc::c_uint = 3;
pub type IOFuncSelector = Enum_IOFuncSelector;
pub type get_attavgwidth_hook_type =
    ::std::option::Option<extern "C" fn(relid: Oid, attnum: AttrNumber)
                              -> int32>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MemoryContextMethods {
    pub alloc: ::std::option::Option<extern "C" fn(context: MemoryContext,
                                                   size: Size)
                                         -> *mut ::libc::c_void>,
    pub free_p: ::std::option::Option<extern "C" fn(context: MemoryContext,
                                                    pointer:
                                                        *mut ::libc::c_void)
                                          -> ()>,
    pub realloc: ::std::option::Option<extern "C" fn(context: MemoryContext,
                                                     pointer:
                                                         *mut ::libc::c_void,
                                                     size: Size)
                                           -> *mut ::libc::c_void>,
    pub init: ::std::option::Option<extern "C" fn(context: MemoryContext)
                                        -> ()>,
    pub reset: ::std::option::Option<extern "C" fn(context: MemoryContext)
                                         -> ()>,
    pub delete_context: ::std::option::Option<extern "C" fn(context:
                                                                MemoryContext)
                                                  -> ()>,
    pub get_chunk_space:
        ::std::option::Option<extern "C" fn(context: MemoryContext,
                                            pointer: *mut ::libc::c_void)
                                             -> Size>,
    pub is_empty: ::std::option::Option<extern "C" fn(context: MemoryContext)
                                            -> _bool>,
    pub stats: ::std::option::Option<extern "C" fn(context: MemoryContext,
                                                   level: ::libc::c_int)
                                         -> ()>,
}
impl ::std::clone::Clone for Struct_MemoryContextMethods {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MemoryContextMethods {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MemoryContextMethods = Struct_MemoryContextMethods;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MemoryContextData {
    pub _type: NodeTag,
    pub methods: *mut MemoryContextMethods,
    pub parent: MemoryContext,
    pub firstchild: MemoryContext,
    pub nextchild: MemoryContext,
    pub name: *mut ::libc::c_char,
    pub isReset: _bool,
}
impl ::std::clone::Clone for Struct_MemoryContextData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MemoryContextData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MemoryContextData = Struct_MemoryContextData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_StandardChunkHeader {
    pub context: MemoryContext,
    pub size: Size,
}
impl ::std::clone::Clone for Struct_StandardChunkHeader {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_StandardChunkHeader {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StandardChunkHeader = Struct_StandardChunkHeader;
pub type Enum_SysCacheIdentifier = ::libc::c_uint;
pub const AGGFNOID: ::libc::c_uint = 0;
pub const AMNAME: ::libc::c_uint = 1;
pub const AMOID: ::libc::c_uint = 2;
pub const AMOPOPID: ::libc::c_uint = 3;
pub const AMOPSTRATEGY: ::libc::c_uint = 4;
pub const AMPROCNUM: ::libc::c_uint = 5;
pub const ATTNAME: ::libc::c_uint = 6;
pub const ATTNUM: ::libc::c_uint = 7;
pub const AUTHMEMMEMROLE: ::libc::c_uint = 8;
pub const AUTHMEMROLEMEM: ::libc::c_uint = 9;
pub const AUTHNAME: ::libc::c_uint = 10;
pub const AUTHOID: ::libc::c_uint = 11;
pub const CASTSOURCETARGET: ::libc::c_uint = 12;
pub const CLAAMNAMENSP: ::libc::c_uint = 13;
pub const CLAOID: ::libc::c_uint = 14;
pub const COLLNAMEENCNSP: ::libc::c_uint = 15;
pub const COLLOID: ::libc::c_uint = 16;
pub const CONDEFAULT: ::libc::c_uint = 17;
pub const CONNAMENSP: ::libc::c_uint = 18;
pub const CONSTROID: ::libc::c_uint = 19;
pub const CONVOID: ::libc::c_uint = 20;
pub const DATABASEOID: ::libc::c_uint = 21;
pub const DEFACLROLENSPOBJ: ::libc::c_uint = 22;
pub const ENUMOID: ::libc::c_uint = 23;
pub const ENUMTYPOIDNAME: ::libc::c_uint = 24;
pub const EVENTTRIGGERNAME: ::libc::c_uint = 25;
pub const EVENTTRIGGEROID: ::libc::c_uint = 26;
pub const FOREIGNDATAWRAPPERNAME: ::libc::c_uint = 27;
pub const FOREIGNDATAWRAPPEROID: ::libc::c_uint = 28;
pub const FOREIGNSERVERNAME: ::libc::c_uint = 29;
pub const FOREIGNSERVEROID: ::libc::c_uint = 30;
pub const FOREIGNTABLEREL: ::libc::c_uint = 31;
pub const INDEXRELID: ::libc::c_uint = 32;
pub const LANGNAME: ::libc::c_uint = 33;
pub const LANGOID: ::libc::c_uint = 34;
pub const NAMESPACENAME: ::libc::c_uint = 35;
pub const NAMESPACEOID: ::libc::c_uint = 36;
pub const OPERNAMENSP: ::libc::c_uint = 37;
pub const OPEROID: ::libc::c_uint = 38;
pub const OPFAMILYAMNAMENSP: ::libc::c_uint = 39;
pub const OPFAMILYOID: ::libc::c_uint = 40;
pub const PROCNAMEARGSNSP: ::libc::c_uint = 41;
pub const PROCOID: ::libc::c_uint = 42;
pub const RANGETYPE: ::libc::c_uint = 43;
pub const RELNAMENSP: ::libc::c_uint = 44;
pub const RELOID: ::libc::c_uint = 45;
pub const RULERELNAME: ::libc::c_uint = 46;
pub const STATRELATTINH: ::libc::c_uint = 47;
pub const TABLESPACEOID: ::libc::c_uint = 48;
pub const TSCONFIGMAP: ::libc::c_uint = 49;
pub const TSCONFIGNAMENSP: ::libc::c_uint = 50;
pub const TSCONFIGOID: ::libc::c_uint = 51;
pub const TSDICTNAMENSP: ::libc::c_uint = 52;
pub const TSDICTOID: ::libc::c_uint = 53;
pub const TSPARSERNAMENSP: ::libc::c_uint = 54;
pub const TSPARSEROID: ::libc::c_uint = 55;
pub const TSTEMPLATENAMENSP: ::libc::c_uint = 56;
pub const TSTEMPLATEOID: ::libc::c_uint = 57;
pub const TYPENAMENSP: ::libc::c_uint = 58;
pub const TYPEOID: ::libc::c_uint = 59;
pub const USERMAPPINGOID: ::libc::c_uint = 60;
pub const USERMAPPINGUSERSERVER: ::libc::c_uint = 61;
pub enum Struct_catclist { }
pub enum Struct_TypeCacheEnumData { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TypeCacheEntry {
    pub type_id: Oid,
    pub typlen: int16,
    pub typbyval: _bool,
    pub typalign: ::libc::c_char,
    pub typstorage: ::libc::c_char,
    pub typtype: ::libc::c_char,
    pub typrelid: Oid,
    pub btree_opf: Oid,
    pub btree_opintype: Oid,
    pub hash_opf: Oid,
    pub hash_opintype: Oid,
    pub eq_opr: Oid,
    pub lt_opr: Oid,
    pub gt_opr: Oid,
    pub cmp_proc: Oid,
    pub hash_proc: Oid,
    pub eq_opr_finfo: FmgrInfo,
    pub cmp_proc_finfo: FmgrInfo,
    pub hash_proc_finfo: FmgrInfo,
    pub tupDesc: TupleDesc,
    pub rngelemtype: *mut Struct_TypeCacheEntry,
    pub rng_collation: Oid,
    pub rng_cmp_proc_finfo: FmgrInfo,
    pub rng_canonical_finfo: FmgrInfo,
    pub rng_subdiff_finfo: FmgrInfo,
    pub flags: ::libc::c_int,
    pub enumData: *mut Struct_TypeCacheEnumData,
}
impl ::std::clone::Clone for Struct_TypeCacheEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TypeCacheEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TypeCacheEntry = Struct_TypeCacheEntry;
pub type DecodingJsonData = Struct__DecodingJsonData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__DecodingJsonData {
    pub context: MemoryContext,
    pub xact_wrote_changes: _bool,
}
impl ::std::clone::Clone for Struct__DecodingJsonData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__DecodingJsonData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub static mut __stdinp: *mut FILE;
    pub static mut __stdoutp: *mut FILE;
    pub static mut __stderrp: *mut FILE;
    pub static sys_nerr: ::libc::c_int;
    pub static mut sys_errlist: *const *const ::libc::c_char;
    pub static mut __mb_cur_max: ::libc::c_int;
    pub static mut suboptarg: *mut ::libc::c_char;
    pub static mut _DefaultRuneLocale: _RuneLocale;
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
    pub static in6addr_any: Struct_in6_addr;
    pub static in6addr_loopback: Struct_in6_addr;
    pub static in6addr_nodelocal_allnodes: Struct_in6_addr;
    pub static in6addr_linklocal_allnodes: Struct_in6_addr;
    pub static in6addr_linklocal_allrouters: Struct_in6_addr;
    pub static in6addr_linklocal_allv2routers: Struct_in6_addr;
    pub static mut h_errno: ::libc::c_int;
    pub static mut error_context_stack: *mut ErrorContextCallback;
    pub static mut PG_exception_stack: *mut sigjmp_buf;
    pub static mut emit_log_hook: emit_log_hook_type;
    pub static mut Log_error_verbosity: ::libc::c_int;
    pub static mut Log_line_prefix: *mut ::libc::c_char;
    pub static mut Log_destination: ::libc::c_int;
    pub static mut Log_destination_string: *mut ::libc::c_char;
    pub static mut CurrentMemoryContext: MemoryContext;
    pub static mut assert_enabled: _bool;
    pub static mut Dynamic_library_path: *mut ::libc::c_char;
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
    pub static mut fmgr_hook: fmgr_hook_type;
    pub static mut MyBackendId: BackendId;
    pub static mut MainLWLockArray: *mut LWLockPadded;
    pub static mut max_locks_per_xact: ::libc::c_int;
    pub static mut criticalRelcachesBuilt: _bool;
    pub static mut criticalSharedRelcachesBuilt: _bool;
    pub static mut no_such_variable: ::libc::c_int;
    pub static mut ShmemVariableCache: VariableCache;
    pub static mut forkNames: *const *const ::libc::c_char;
    pub static mut SharedInvalidMessageCounter: uint64;
    pub static mut signgam: ::libc::c_int;
    pub static mut session_timezone: *mut pg_tz;
    pub static mut log_timezone: *mut pg_tz;
    pub static mut PgStartTime: TimestampTz;
    pub static mut PgReloadTime: TimestampTz;
    pub static mut pg_crc32_table: *const uint32;
    pub static mut sync_method: ::libc::c_int;
    pub static mut ThisTimeLineID: TimeLineID;
    pub static mut InRecovery: _bool;
    pub static mut standbyState: HotStandbyState;
    pub static mut XactLastRecEnd: XLogRecPtr;
    pub static mut reachedConsistency: _bool;
    pub static mut CheckPointSegments: ::libc::c_int;
    pub static mut wal_keep_segments: ::libc::c_int;
    pub static mut XLOGbuffers: ::libc::c_int;
    pub static mut XLogArchiveTimeout: ::libc::c_int;
    pub static mut XLogArchiveMode: _bool;
    pub static mut XLogArchiveCommand: *mut ::libc::c_char;
    pub static mut EnableHotStandby: _bool;
    pub static mut fullPageWrites: _bool;
    pub static mut wal_log_hints: _bool;
    pub static mut log_checkpoints: _bool;
    pub static mut wal_level: ::libc::c_int;
    pub static mut CheckpointStats: CheckpointStatsData;
    pub static mut RmgrTable: *const RmgrData;
    pub static mut ArchiveRecoveryRequested: _bool;
    pub static mut InArchiveRecovery: _bool;
    pub static mut StandbyMode: _bool;
    pub static mut recoveryRestoreCommand: *mut ::libc::c_char;
    pub static mut ReplicationSlotCtl: *mut ReplicationSlotCtlData;
    pub static mut MyReplicationSlot: *mut ReplicationSlot;
    pub static mut max_replication_slots: ::libc::c_int;
    pub static mut extra_float_digits: ::libc::c_int;
    pub static mut quote_all_identifiers: _bool;
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
    pub static mut TopMemoryContext: MemoryContext;
    pub static mut ErrorContext: MemoryContext;
    pub static mut PostmasterContext: MemoryContext;
    pub static mut CacheMemoryContext: MemoryContext;
    pub static mut MessageContext: MemoryContext;
    pub static mut TopTransactionContext: MemoryContext;
    pub static mut CurTransactionContext: MemoryContext;
    pub static mut PortalContext: MemoryContext;
}
extern "C" {
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ffsl(arg1: ::libc::c_long) -> ::libc::c_int;
    pub fn ffsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
    pub fn fls(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn flsl(arg1: ::libc::c_long) -> ::libc::c_int;
    pub fn flsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
    pub fn __error() -> *mut ::libc::c_int;
    pub fn localeconv() -> *mut Struct_lconv;
    pub fn setlocale(arg1: ::libc::c_int, arg2: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn fdatasync(fildes: ::libc::c_int) -> ::libc::c_int;
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::libc::c_ulong;
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn isascii(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn __maskrune(arg1: __darwin_ct_rune_t, arg2: ::libc::c_ulong)
     -> ::libc::c_int;
    pub fn __istype(_c: __darwin_ct_rune_t, _f: ::libc::c_ulong)
     -> ::libc::c_int;
    pub fn __isctype(_c: __darwin_ct_rune_t, _f: ::libc::c_ulong)
     -> __darwin_ct_rune_t;
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn __wcwidth(_c: __darwin_ct_rune_t) -> ::libc::c_int;
    pub fn isalnum(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isalpha(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isblank(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn iscntrl(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isdigit(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isgraph(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn islower(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isprint(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn ispunct(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isspace(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isupper(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isxdigit(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn toascii(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn tolower(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn toupper(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn digittoint(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn ishexnumber(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isideogram(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isnumber(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isphonogram(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isrune(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn isspecial(_c: ::libc::c_int) -> ::libc::c_int;
    pub fn accept(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                  arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn bind(arg1: ::libc::c_int, arg2: *const Struct_sockaddr,
                arg3: socklen_t) -> ::libc::c_int;
    pub fn connect(arg1: ::libc::c_int, arg2: *const Struct_sockaddr,
                   arg3: socklen_t) -> ::libc::c_int;
    pub fn getpeername(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                       arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn getsockname(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr,
                       arg3: *mut socklen_t) -> ::libc::c_int;
    pub fn getsockopt(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *mut ::libc::c_void,
                      arg5: *mut socklen_t) -> ::libc::c_int;
    pub fn listen(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn recv(arg1: ::libc::c_int, arg2: *mut ::libc::c_void, arg3: size_t,
                arg4: ::libc::c_int) -> ssize_t;
    pub fn recvfrom(arg1: ::libc::c_int, arg2: *mut ::libc::c_void,
                    arg3: size_t, arg4: ::libc::c_int,
                    arg5: *mut Struct_sockaddr, arg6: *mut socklen_t)
     -> ssize_t;
    pub fn recvmsg(arg1: ::libc::c_int, arg2: *mut Struct_msghdr,
                   arg3: ::libc::c_int) -> ssize_t;
    pub fn send(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                arg3: size_t, arg4: ::libc::c_int) -> ssize_t;
    pub fn sendmsg(arg1: ::libc::c_int, arg2: *const Struct_msghdr,
                   arg3: ::libc::c_int) -> ssize_t;
    pub fn sendto(arg1: ::libc::c_int, arg2: *const ::libc::c_void,
                  arg3: size_t, arg4: ::libc::c_int,
                  arg5: *const Struct_sockaddr, arg6: socklen_t) -> ssize_t;
    pub fn setsockopt(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *const ::libc::c_void,
                      arg5: socklen_t) -> ::libc::c_int;
    pub fn shutdown(arg1: ::libc::c_int, arg2: ::libc::c_int)
     -> ::libc::c_int;
    pub fn sockatmark(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn socket(arg1: ::libc::c_int, arg2: ::libc::c_int,
                  arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn socketpair(arg1: ::libc::c_int, arg2: ::libc::c_int,
                      arg3: ::libc::c_int, arg4: *mut ::libc::c_int)
     -> ::libc::c_int;
    pub fn sendfile(arg1: ::libc::c_int, arg2: ::libc::c_int, arg3: off_t,
                    arg4: *mut off_t, arg5: *mut Struct_sf_hdtr,
                    arg6: ::libc::c_int) -> ::libc::c_int;
    pub fn pfctlinput(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr) -> ();
    pub fn connectx(arg1: ::libc::c_int, arg2: *const sa_endpoints_t,
                    arg3: sae_associd_t, arg4: ::libc::c_uint,
                    arg5: *const Struct_iovec, arg6: ::libc::c_uint,
                    arg7: *mut size_t, arg8: *mut sae_connid_t)
     -> ::libc::c_int;
    pub fn disconnectx(arg1: ::libc::c_int, arg2: sae_associd_t,
                       arg3: sae_connid_t) -> ::libc::c_int;
    pub fn setipv4sourcefilter(arg1: ::libc::c_int, arg2: Struct_in_addr,
                               arg3: Struct_in_addr, arg4: uint32_t,
                               arg5: uint32_t, arg6: *mut Struct_in_addr)
     -> ::libc::c_int;
    pub fn getipv4sourcefilter(arg1: ::libc::c_int, arg2: Struct_in_addr,
                               arg3: Struct_in_addr, arg4: *mut uint32_t,
                               arg5: *mut uint32_t, arg6: *mut Struct_in_addr)
     -> ::libc::c_int;
    pub fn setsourcefilter(arg1: ::libc::c_int, arg2: uint32_t,
                           arg3: *mut Struct_sockaddr, arg4: socklen_t,
                           arg5: uint32_t, arg6: uint32_t,
                           arg7: *mut Struct_sockaddr_storage)
     -> ::libc::c_int;
    pub fn getsourcefilter(arg1: ::libc::c_int, arg2: uint32_t,
                           arg3: *mut Struct_sockaddr, arg4: socklen_t,
                           arg5: *mut uint32_t, arg6: *mut uint32_t,
                           arg7: *mut Struct_sockaddr_storage)
     -> ::libc::c_int;
    pub fn inet6_option_space(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_init(arg1: *mut ::libc::c_void,
                             arg2: *mut *mut Struct_cmsghdr,
                             arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_append(arg1: *mut Struct_cmsghdr,
                               arg2: *const __uint8_t, arg3: ::libc::c_int,
                               arg4: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_option_alloc(arg1: *mut Struct_cmsghdr, arg2: ::libc::c_int,
                              arg3: ::libc::c_int, arg4: ::libc::c_int)
     -> *mut __uint8_t;
    pub fn inet6_option_next(arg1: *const Struct_cmsghdr,
                             arg2: *mut *mut __uint8_t) -> ::libc::c_int;
    pub fn inet6_option_find(arg1: *const Struct_cmsghdr,
                             arg2: *mut *mut __uint8_t, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn inet6_rthdr_space(arg1: ::libc::c_int, arg2: ::libc::c_int)
     -> size_t;
    pub fn inet6_rthdr_init(arg1: *mut ::libc::c_void, arg2: ::libc::c_int)
     -> *mut Struct_cmsghdr;
    pub fn inet6_rthdr_add(arg1: *mut Struct_cmsghdr,
                           arg2: *const Struct_in6_addr, arg3: ::libc::c_uint)
     -> ::libc::c_int;
    pub fn inet6_rthdr_lasthop(arg1: *mut Struct_cmsghdr,
                               arg2: ::libc::c_uint) -> ::libc::c_int;
    pub fn inet6_rthdr_segments(arg1: *const Struct_cmsghdr) -> ::libc::c_int;
    pub fn inet6_rthdr_getaddr(arg1: *mut Struct_cmsghdr, arg2: ::libc::c_int)
     -> *mut Struct_in6_addr;
    pub fn inet6_rthdr_getflags(arg1: *const Struct_cmsghdr,
                                arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_opt_init(arg1: *mut ::libc::c_void, arg2: socklen_t)
     -> ::libc::c_int;
    pub fn inet6_opt_append(arg1: *mut ::libc::c_void, arg2: socklen_t,
                            arg3: ::libc::c_int, arg4: __uint8_t,
                            arg5: socklen_t, arg6: __uint8_t,
                            arg7: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_finish(arg1: *mut ::libc::c_void, arg2: socklen_t,
                            arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn inet6_opt_set_val(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                             arg3: *mut ::libc::c_void, arg4: socklen_t)
     -> ::libc::c_int;
    pub fn inet6_opt_next(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: *mut __uint8_t,
                          arg5: *mut socklen_t,
                          arg6: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_find(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: __uint8_t,
                          arg5: *mut socklen_t,
                          arg6: *mut *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_opt_get_val(arg1: *mut ::libc::c_void, arg2: ::libc::c_int,
                             arg3: *mut ::libc::c_void, arg4: socklen_t)
     -> ::libc::c_int;
    pub fn inet6_rth_space(arg1: ::libc::c_int, arg2: ::libc::c_int)
     -> socklen_t;
    pub fn inet6_rth_init(arg1: *mut ::libc::c_void, arg2: socklen_t,
                          arg3: ::libc::c_int, arg4: ::libc::c_int)
     -> *mut ::libc::c_void;
    pub fn inet6_rth_add(arg1: *mut ::libc::c_void,
                         arg2: *const Struct_in6_addr) -> ::libc::c_int;
    pub fn inet6_rth_reverse(arg1: *const ::libc::c_void,
                             arg2: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_rth_segments(arg1: *const ::libc::c_void) -> ::libc::c_int;
    pub fn inet6_rth_getaddr(arg1: *const ::libc::c_void, arg2: ::libc::c_int)
     -> *mut Struct_in6_addr;
    pub fn addrsel_policy_init() -> ();
    pub fn bindresvport(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr_in)
     -> ::libc::c_int;
    pub fn bindresvport_sa(arg1: ::libc::c_int, arg2: *mut Struct_sockaddr)
     -> ::libc::c_int;
    pub fn endhostent() -> ();
    pub fn endnetent() -> ();
    pub fn endprotoent() -> ();
    pub fn endservent() -> ();
    pub fn freeaddrinfo(arg1: *mut Struct_addrinfo) -> ();
    pub fn gai_strerror(arg1: ::libc::c_int) -> *const ::libc::c_char;
    pub fn getaddrinfo(arg1: *const ::libc::c_char,
                       arg2: *const ::libc::c_char,
                       arg3: *const Struct_addrinfo,
                       arg4: *mut *mut Struct_addrinfo) -> ::libc::c_int;
    pub fn gethostbyaddr(arg1: *const ::libc::c_void, arg2: socklen_t,
                         arg3: ::libc::c_int) -> *mut Struct_hostent;
    pub fn gethostbyname(arg1: *const ::libc::c_char) -> *mut Struct_hostent;
    pub fn gethostent() -> *mut Struct_hostent;
    pub fn getnameinfo(arg1: *const Struct_sockaddr, arg2: socklen_t,
                       arg3: *mut ::libc::c_char, arg4: socklen_t,
                       arg5: *mut ::libc::c_char, arg6: socklen_t,
                       arg7: ::libc::c_int) -> ::libc::c_int;
    pub fn getnetbyaddr(arg1: uint32_t, arg2: ::libc::c_int)
     -> *mut Struct_netent;
    pub fn getnetbyname(arg1: *const ::libc::c_char) -> *mut Struct_netent;
    pub fn getnetent() -> *mut Struct_netent;
    pub fn getprotobyname(arg1: *const ::libc::c_char)
     -> *mut Struct_protoent;
    pub fn getprotobynumber(arg1: ::libc::c_int) -> *mut Struct_protoent;
    pub fn getprotoent() -> *mut Struct_protoent;
    pub fn getservbyname(arg1: *const ::libc::c_char,
                         arg2: *const ::libc::c_char) -> *mut Struct_servent;
    pub fn getservbyport(arg1: ::libc::c_int, arg2: *const ::libc::c_char)
     -> *mut Struct_servent;
    pub fn getservent() -> *mut Struct_servent;
    pub fn sethostent(arg1: ::libc::c_int) -> ();
    pub fn setnetent(arg1: ::libc::c_int) -> ();
    pub fn setprotoent(arg1: ::libc::c_int) -> ();
    pub fn setservent(arg1: ::libc::c_int) -> ();
    pub fn freehostent(arg1: *mut Struct_hostent) -> ();
    pub fn gethostbyname2(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> *mut Struct_hostent;
    pub fn getipnodebyaddr(arg1: *const ::libc::c_void, arg2: size_t,
                           arg3: ::libc::c_int, arg4: *mut ::libc::c_int)
     -> *mut Struct_hostent;
    pub fn getipnodebyname(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                           arg3: ::libc::c_int, arg4: *mut ::libc::c_int)
     -> *mut Struct_hostent;
    pub fn getrpcbyname(name: *const ::libc::c_char) -> *mut Struct_rpcent;
    pub fn getrpcbynumber(number: ::libc::c_int) -> *mut Struct_rpcent;
    pub fn getrpcent() -> *mut Struct_rpcent;
    pub fn setrpcent(stayopen: ::libc::c_int) -> ();
    pub fn endrpcent() -> ();
    pub fn herror(arg1: *const ::libc::c_char) -> ();
    pub fn hstrerror(arg1: ::libc::c_int) -> *const ::libc::c_char;
    pub fn innetgr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char,
                   arg3: *const ::libc::c_char, arg4: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn getnetgrent(arg1: *mut *mut ::libc::c_char,
                       arg2: *mut *mut ::libc::c_char,
                       arg3: *mut *mut ::libc::c_char) -> ::libc::c_int;
    pub fn endnetgrent() -> ();
    pub fn setnetgrent(arg1: *const ::libc::c_char) -> ();
    pub fn getpwuid(arg1: uid_t) -> *mut Struct_passwd;
    pub fn getpwnam(arg1: *const ::libc::c_char) -> *mut Struct_passwd;
    pub fn getpwuid_r(arg1: uid_t, arg2: *mut Struct_passwd,
                      arg3: *mut ::libc::c_char, arg4: size_t,
                      arg5: *mut *mut Struct_passwd) -> ::libc::c_int;
    pub fn getpwnam_r(arg1: *const ::libc::c_char, arg2: *mut Struct_passwd,
                      arg3: *mut ::libc::c_char, arg4: size_t,
                      arg5: *mut *mut Struct_passwd) -> ::libc::c_int;
    pub fn getpwent() -> *mut Struct_passwd;
    pub fn setpwent() -> ();
    pub fn endpwent() -> ();
    pub fn uuid_clear(uu: uuid_t) -> ();
    pub fn uuid_compare(uu1: uuid_t, uu2: uuid_t) -> ::libc::c_int;
    pub fn uuid_copy(dst: uuid_t, src: uuid_t) -> ();
    pub fn uuid_generate(out: uuid_t) -> ();
    pub fn uuid_generate_random(out: uuid_t) -> ();
    pub fn uuid_generate_time(out: uuid_t) -> ();
    pub fn uuid_is_null(uu: uuid_t) -> ::libc::c_int;
    pub fn uuid_parse(_in: uuid_string_t, uu: uuid_t) -> ::libc::c_int;
    pub fn uuid_unparse(uu: uuid_t, out: uuid_string_t) -> ();
    pub fn uuid_unparse_lower(uu: uuid_t, out: uuid_string_t) -> ();
    pub fn uuid_unparse_upper(uu: uuid_t, out: uuid_string_t) -> ();
    pub fn setpassent(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn user_from_uid(arg1: uid_t, arg2: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn getpwuuid(arg1: uuid_t) -> *mut Struct_passwd;
    pub fn getpwuuid_r(arg1: uuid_t, arg2: *mut Struct_passwd,
                       arg3: *mut ::libc::c_char, arg4: size_t,
                       arg5: *mut *mut Struct_passwd) -> ::libc::c_int;
    pub fn pg_set_noblock(sock: pgsocket) -> _bool;
    pub fn pg_set_block(sock: pgsocket) -> _bool;
    pub fn has_drive_prefix(filename: *const ::libc::c_char) -> _bool;
    pub fn first_dir_separator(filename: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn last_dir_separator(filename: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn first_path_var_separator(pathlist: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn join_path_components(ret_path: *mut ::libc::c_char,
                                head: *const ::libc::c_char,
                                tail: *const ::libc::c_char) -> ();
    pub fn canonicalize_path(path: *mut ::libc::c_char) -> ();
    pub fn make_native_path(path: *mut ::libc::c_char) -> ();
    pub fn path_contains_parent_reference(path: *const ::libc::c_char)
     -> _bool;
    pub fn path_is_relative_and_below_cwd(path: *const ::libc::c_char)
     -> _bool;
    pub fn path_is_prefix_of_path(path1: *const ::libc::c_char,
                                  path2: *const ::libc::c_char) -> _bool;
    pub fn make_absolute_path(path: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn get_progname(argv0: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn get_share_path(my_exec_path: *const ::libc::c_char,
                          ret_path: *mut ::libc::c_char) -> ();
    pub fn get_etc_path(my_exec_path: *const ::libc::c_char,
                        ret_path: *mut ::libc::c_char) -> ();
    pub fn get_include_path(my_exec_path: *const ::libc::c_char,
                            ret_path: *mut ::libc::c_char) -> ();
    pub fn get_pkginclude_path(my_exec_path: *const ::libc::c_char,
                               ret_path: *mut ::libc::c_char) -> ();
    pub fn get_includeserver_path(my_exec_path: *const ::libc::c_char,
                                  ret_path: *mut ::libc::c_char) -> ();
    pub fn get_lib_path(my_exec_path: *const ::libc::c_char,
                        ret_path: *mut ::libc::c_char) -> ();
    pub fn get_pkglib_path(my_exec_path: *const ::libc::c_char,
                           ret_path: *mut ::libc::c_char) -> ();
    pub fn get_locale_path(my_exec_path: *const ::libc::c_char,
                           ret_path: *mut ::libc::c_char) -> ();
    pub fn get_doc_path(my_exec_path: *const ::libc::c_char,
                        ret_path: *mut ::libc::c_char) -> ();
    pub fn get_html_path(my_exec_path: *const ::libc::c_char,
                         ret_path: *mut ::libc::c_char) -> ();
    pub fn get_man_path(my_exec_path: *const ::libc::c_char,
                        ret_path: *mut ::libc::c_char) -> ();
    pub fn get_home_path(ret_path: *mut ::libc::c_char) -> _bool;
    pub fn get_parent_directory(path: *mut ::libc::c_char) -> ();
    pub fn pgfnames(path: *const ::libc::c_char) -> *mut *mut ::libc::c_char;
    pub fn pgfnames_cleanup(filenames: *mut *mut ::libc::c_char) -> ();
    pub fn set_pglocale_pgservice(argv0: *const ::libc::c_char,
                                  app: *const ::libc::c_char) -> ();
    pub fn find_my_exec(argv0: *const ::libc::c_char,
                        retpath: *mut ::libc::c_char) -> ::libc::c_int;
    pub fn find_other_exec(argv0: *const ::libc::c_char,
                           target: *const ::libc::c_char,
                           versionstr: *const ::libc::c_char,
                           retpath: *mut ::libc::c_char) -> ::libc::c_int;
    pub fn pg_usleep(microsec: ::libc::c_long) -> ();
    pub fn pg_strcasecmp(s1: *const ::libc::c_char, s2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn pg_strncasecmp(s1: *const ::libc::c_char,
                          s2: *const ::libc::c_char, n: size_t)
     -> ::libc::c_int;
    pub fn pg_toupper(ch: ::libc::c_uchar) -> ::libc::c_uchar;
    pub fn pg_tolower(ch: ::libc::c_uchar) -> ::libc::c_uchar;
    pub fn pg_ascii_toupper(ch: ::libc::c_uchar) -> ::libc::c_uchar;
    pub fn pg_ascii_tolower(ch: ::libc::c_uchar) -> ::libc::c_uchar;
    pub fn simple_prompt(prompt: *const ::libc::c_char, maxlen: ::libc::c_int,
                         echo: _bool) -> *mut ::libc::c_char;
    pub fn pclose_check(stream: *mut FILE) -> ::libc::c_int;
    pub fn rmtree(path: *const ::libc::c_char, rmtopdir: _bool) -> _bool;
    pub fn pg_erand48(xseed: *mut ::libc::c_ushort) -> ::libc::c_double;
    pub fn pg_lrand48() -> ::libc::c_long;
    pub fn pg_srand48(seed: ::libc::c_long) -> ();
    pub fn pqStrerror(errnum: ::libc::c_int, strerrbuf: *mut ::libc::c_char,
                      buflen: size_t) -> *mut ::libc::c_char;
    pub fn pqGetpwuid(uid: uid_t, resultbuf: *mut Struct_passwd,
                      buffer: *mut ::libc::c_char, buflen: size_t,
                      result: *mut *mut Struct_passwd) -> ::libc::c_int;
    pub fn pqGethostbyname(name: *const ::libc::c_char,
                           resultbuf: *mut Struct_hostent,
                           buffer: *mut ::libc::c_char, buflen: size_t,
                           result: *mut *mut Struct_hostent,
                           herrno: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn pg_qsort(
        base: *mut ::libc::c_void, nel: size_t, elsize: size_t,
        cmp: ::std::option::Option<extern "C" fn(arg1: *const ::libc::c_void,
                                                 arg2: *const ::libc::c_void)
                                                  -> ::libc::c_int>
    ) -> ();
    pub fn pg_qsort_strcmp(a: *const ::libc::c_void, b: *const ::libc::c_void)
     -> ::libc::c_int;
    pub fn qsort_arg(base: *mut ::libc::c_void, nel: size_t, elsize: size_t,
                     cmp: qsort_arg_comparator, arg: *mut ::libc::c_void)
     -> ();
    pub fn pg_get_encoding_from_locale(ctype: *const ::libc::c_char,
                                       write_message: _bool) -> ::libc::c_int;
    pub fn inet_net_ntop(af: ::libc::c_int, src: *const ::libc::c_void,
                         bits: ::libc::c_int, dst: *mut ::libc::c_char,
                         size: size_t) -> *mut ::libc::c_char;
    pub fn pg_check_dir(dir: *const ::libc::c_char) -> ::libc::c_int;
    pub fn pg_mkdir_p(path: *mut ::libc::c_char, omode: ::libc::c_int)
     -> ::libc::c_int;
    pub fn pqsignal(signo: ::libc::c_int, func: pqsigfunc) -> pqsigfunc;
    pub fn escape_single_quotes_ascii(src: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn wait_result_to_str(exit_status: ::libc::c_int)
     -> *mut ::libc::c_char;
    pub fn setjmp(arg1: jmp_buf) -> ::libc::c_int;
    pub fn longjmp(arg1: jmp_buf, arg2: ::libc::c_int) -> ();
    pub fn _setjmp(arg1: jmp_buf) -> ::libc::c_int;
    pub fn _longjmp(arg1: jmp_buf, arg2: ::libc::c_int) -> ();
    pub fn sigsetjmp(arg1: sigjmp_buf, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn siglongjmp(arg1: sigjmp_buf, arg2: ::libc::c_int) -> ();
    pub fn longjmperror() -> ();
    pub fn errstart(elevel: ::libc::c_int, filename: *const ::libc::c_char,
                    lineno: ::libc::c_int, funcname: *const ::libc::c_char,
                    domain: *const ::libc::c_char) -> _bool;
    pub fn errfinish(dummy: ::libc::c_int, ...) -> ();
    pub fn errcode(sqlerrcode: ::libc::c_int) -> ::libc::c_int;
    pub fn errcode_for_file_access() -> ::libc::c_int;
    pub fn errcode_for_socket_access() -> ::libc::c_int;
    pub fn errmsg(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errmsg_internal(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errmsg_plural(fmt_singular: *const ::libc::c_char,
                         fmt_plural: *const ::libc::c_char,
                         n: ::libc::c_ulong, ...) -> ::libc::c_int;
    pub fn errdetail(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errdetail_internal(fmt: *const ::libc::c_char, ...)
     -> ::libc::c_int;
    pub fn errdetail_log(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errdetail_log_plural(fmt_singular: *const ::libc::c_char,
                                fmt_plural: *const ::libc::c_char,
                                n: ::libc::c_ulong, ...) -> ::libc::c_int;
    pub fn errdetail_plural(fmt_singular: *const ::libc::c_char,
                            fmt_plural: *const ::libc::c_char,
                            n: ::libc::c_ulong, ...) -> ::libc::c_int;
    pub fn errhint(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn set_errcontext_domain(domain: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn errcontext_msg(fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn errhidestmt(hide_stmt: _bool) -> ::libc::c_int;
    pub fn errfunction(funcname: *const ::libc::c_char) -> ::libc::c_int;
    pub fn errposition(cursorpos: ::libc::c_int) -> ::libc::c_int;
    pub fn internalerrposition(cursorpos: ::libc::c_int) -> ::libc::c_int;
    pub fn internalerrquery(query: *const ::libc::c_char) -> ::libc::c_int;
    pub fn err_generic_string(field: ::libc::c_int,
                              str: *const ::libc::c_char) -> ::libc::c_int;
    pub fn geterrcode() -> ::libc::c_int;
    pub fn geterrposition() -> ::libc::c_int;
    pub fn getinternalerrposition() -> ::libc::c_int;
    pub fn elog_start(filename: *const ::libc::c_char, lineno: ::libc::c_int,
                      funcname: *const ::libc::c_char) -> ();
    pub fn elog_finish(elevel: ::libc::c_int, fmt: *const ::libc::c_char, ...)
     -> ();
    pub fn pre_format_elog_string(errnumber: ::libc::c_int,
                                  domain: *const ::libc::c_char) -> ();
    pub fn format_elog_string(fmt: *const ::libc::c_char, ...)
     -> *mut ::libc::c_char;
    pub fn EmitErrorReport() -> ();
    pub fn CopyErrorData() -> *mut ErrorData;
    pub fn FreeErrorData(edata: *mut ErrorData) -> ();
    pub fn FlushErrorState() -> ();
    pub fn ReThrowError(edata: *mut ErrorData) -> ();
    pub fn pg_re_throw() -> ();
    pub fn GetErrorContextStack() -> *mut ::libc::c_char;
    pub fn DebugFileOpen() -> ();
    pub fn unpack_sql_state(sql_state: ::libc::c_int) -> *mut ::libc::c_char;
    pub fn in_error_recursion_trouble() -> _bool;
    pub fn set_syslog_parameters(ident: *const ::libc::c_char,
                                 facility: ::libc::c_int) -> ();
    pub fn write_stderr(fmt: *const ::libc::c_char, ...) -> ();
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size)
     -> *mut ::libc::c_void;
    pub fn MemoryContextAllocZero(context: MemoryContext, size: Size)
     -> *mut ::libc::c_void;
    pub fn MemoryContextAllocZeroAligned(context: MemoryContext, size: Size)
     -> *mut ::libc::c_void;
    pub fn palloc(size: Size) -> *mut ::libc::c_void;
    pub fn palloc0(size: Size) -> *mut ::libc::c_void;
    pub fn repalloc(pointer: *mut ::libc::c_void, size: Size)
     -> *mut ::libc::c_void;
    pub fn pfree(pointer: *mut ::libc::c_void) -> ();
    pub fn MemoryContextAllocHuge(context: MemoryContext, size: Size)
     -> *mut ::libc::c_void;
    pub fn repalloc_huge(pointer: *mut ::libc::c_void, size: Size)
     -> *mut ::libc::c_void;
    pub fn MemoryContextStrdup(context: MemoryContext,
                               string: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn pstrdup(_in: *const ::libc::c_char) -> *mut ::libc::c_char;
    pub fn pnstrdup(_in: *const ::libc::c_char, len: Size)
     -> *mut ::libc::c_char;
    pub fn psprintf(fmt: *const ::libc::c_char, ...) -> *mut ::libc::c_char;
    pub fn DatumGetFloat4(X: Datum) -> float4;
    pub fn Float4GetDatum(X: float4) -> Datum;
    pub fn DatumGetFloat8(X: Datum) -> float8;
    pub fn Float8GetDatum(X: float8) -> Datum;
    pub fn ExceptionalCondition(conditionName: *const ::libc::c_char,
                                errorType: *const ::libc::c_char,
                                fileName: *const ::libc::c_char,
                                lineNumber: ::libc::c_int) -> ();
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo) -> ();
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo,
                         mcxt: MemoryContext) -> ();
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo,
                          destcxt: MemoryContext) -> ();
    pub fn pg_detoast_datum(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn pg_detoast_datum_copy(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn pg_detoast_datum_slice(datum: *mut Struct_varlena, first: int32,
                                  count: int32) -> *mut Struct_varlena;
    pub fn pg_detoast_datum_packed(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum) -> Datum;
    pub fn DirectFunctionCall2Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum) -> Datum;
    pub fn DirectFunctionCall3Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum)
     -> Datum;
    pub fn DirectFunctionCall4Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum) -> Datum;
    pub fn DirectFunctionCall5Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum) -> Datum;
    pub fn DirectFunctionCall6Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum)
     -> Datum;
    pub fn DirectFunctionCall7Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum) -> Datum;
    pub fn DirectFunctionCall8Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum) -> Datum;
    pub fn DirectFunctionCall9Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum, arg9: Datum)
     -> Datum;
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum) -> Datum;
    pub fn FunctionCall2Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum) -> Datum;
    pub fn FunctionCall3Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum) -> Datum;
    pub fn FunctionCall4Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum) -> Datum;
    pub fn FunctionCall5Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum) -> Datum;
    pub fn FunctionCall6Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum) -> Datum;
    pub fn FunctionCall7Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum) -> Datum;
    pub fn FunctionCall8Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum) -> Datum;
    pub fn FunctionCall9Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum, arg9: Datum) -> Datum;
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum)
     -> Datum;
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum) -> Datum;
    pub fn OidFunctionCall3Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum) -> Datum;
    pub fn OidFunctionCall4Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum)
     -> Datum;
    pub fn OidFunctionCall5Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum) -> Datum;
    pub fn OidFunctionCall6Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum) -> Datum;
    pub fn OidFunctionCall7Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum)
     -> Datum;
    pub fn OidFunctionCall8Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum) -> Datum;
    pub fn OidFunctionCall9Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum, arg9: Datum) -> Datum;
    pub fn InputFunctionCall(flinfo: *mut FmgrInfo, str: *mut ::libc::c_char,
                             typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidInputFunctionCall(functionId: Oid, str: *mut ::libc::c_char,
                                typioparam: Oid, typmod: int32) -> Datum;
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum)
     -> *mut ::libc::c_char;
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum)
     -> *mut ::libc::c_char;
    pub fn ReceiveFunctionCall(flinfo: *mut FmgrInfo, buf: fmStringInfo,
                               typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidReceiveFunctionCall(functionId: Oid, buf: fmStringInfo,
                                  typioparam: Oid, typmod: int32) -> Datum;
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
    pub fn fetch_finfo_record(filehandle: *mut ::libc::c_void,
                              funcname: *mut ::libc::c_char)
     -> *const Pg_finfo_record;
    pub fn clear_external_function_hash(filehandle: *mut ::libc::c_void)
     -> ();
    pub fn fmgr_internal_function(proname: *const ::libc::c_char) -> Oid;
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo, argnum: ::libc::c_int)
     -> Oid;
    pub fn get_call_expr_argtype(expr: fmNodePtr, argnum: ::libc::c_int)
     -> Oid;
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo,
                                  argnum: ::libc::c_int) -> _bool;
    pub fn get_call_expr_arg_stable(expr: fmNodePtr, argnum: ::libc::c_int)
     -> _bool;
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> _bool;
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid)
     -> _bool;
    pub fn load_external_function(filename: *mut ::libc::c_char,
                                  funcname: *mut ::libc::c_char,
                                  signalNotFound: _bool,
                                  filehandle: *mut *mut ::libc::c_void)
     -> PGFunction;
    pub fn lookup_external_function(filehandle: *mut ::libc::c_void,
                                    funcname: *mut ::libc::c_char)
     -> PGFunction;
    pub fn load_file(filename: *const ::libc::c_char, restricted: _bool)
     -> ();
    pub fn find_rendezvous_variable(varName: *const ::libc::c_char)
     -> *mut *mut ::libc::c_void;
    pub fn AggCheckCallContext(fcinfo: FunctionCallInfo,
                               aggcontext: *mut MemoryContext)
     -> ::libc::c_int;
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
    pub fn AggRegisterCallback(fcinfo: FunctionCallInfo,
                               func: fmExprContextCallbackFunction,
                               arg: Datum) -> ();
    pub fn fmgr(procedureId: Oid, ...) -> *mut ::libc::c_char;
    pub fn ScanKeyInit(entry: ScanKey, attributeNumber: AttrNumber,
                       strategy: StrategyNumber, procedure: RegProcedure,
                       argument: Datum) -> ();
    pub fn ScanKeyEntryInitialize(entry: ScanKey, flags: ::libc::c_int,
                                  attributeNumber: AttrNumber,
                                  strategy: StrategyNumber, subtype: Oid,
                                  collation: Oid, procedure: RegProcedure,
                                  argument: Datum) -> ();
    pub fn ScanKeyEntryInitializeWithInfo(entry: ScanKey,
                                          flags: ::libc::c_int,
                                          attributeNumber: AttrNumber,
                                          strategy: StrategyNumber,
                                          subtype: Oid, collation: Oid,
                                          finfo: *mut FmgrInfo,
                                          argument: Datum) -> ();
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer)
     -> _bool;
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
    pub fn tbm_create(maxbytes: ::libc::c_long) -> *mut TIDBitmap;
    pub fn tbm_free(tbm: *mut TIDBitmap) -> ();
    pub fn tbm_add_tuples(tbm: *mut TIDBitmap, tids: ItemPointer,
                          ntids: ::libc::c_int, recheck: _bool) -> ();
    pub fn tbm_add_page(tbm: *mut TIDBitmap, pageno: BlockNumber) -> ();
    pub fn tbm_union(a: *mut TIDBitmap, b: *const TIDBitmap) -> ();
    pub fn tbm_intersect(a: *mut TIDBitmap, b: *const TIDBitmap) -> ();
    pub fn tbm_is_empty(tbm: *const TIDBitmap) -> _bool;
    pub fn tbm_begin_iterate(tbm: *mut TIDBitmap) -> *mut TBMIterator;
    pub fn tbm_iterate(iterator: *mut TBMIterator) -> *mut TBMIterateResult;
    pub fn tbm_end_iterate(iterator: *mut TBMIterator) -> ();
    pub fn s_lock(lock: *mut slock_t, file: *const ::libc::c_char,
                  line: ::libc::c_int) -> ::libc::c_int;
    pub fn set_spins_per_delay(shared_spins_per_delay: ::libc::c_int) -> ();
    pub fn update_spins_per_delay(shared_spins_per_delay: ::libc::c_int)
     -> ::libc::c_int;
    pub fn LWLockAcquire(lock: *mut LWLock, mode: LWLockMode) -> _bool;
    pub fn LWLockConditionalAcquire(lock: *mut LWLock, mode: LWLockMode)
     -> _bool;
    pub fn LWLockAcquireOrWait(lock: *mut LWLock, mode: LWLockMode) -> _bool;
    pub fn LWLockRelease(lock: *mut LWLock) -> ();
    pub fn LWLockReleaseAll() -> ();
    pub fn LWLockHeldByMe(lock: *mut LWLock) -> _bool;
    pub fn LWLockAcquireWithVar(lock: *mut LWLock, valptr: *mut uint64,
                                val: uint64) -> _bool;
    pub fn LWLockWaitForVar(lock: *mut LWLock, valptr: *mut uint64,
                            oldval: uint64, newval: *mut uint64) -> _bool;
    pub fn LWLockUpdateVar(lock: *mut LWLock, valptr: *mut uint64,
                           value: uint64) -> ();
    pub fn LWLockShmemSize() -> Size;
    pub fn CreateLWLocks() -> ();
    pub fn RequestAddinLWLocks(n: ::libc::c_int) -> ();
    pub fn LWLockAssign() -> *mut LWLock;
    pub fn LWLockNewTrancheId() -> ::libc::c_int;
    pub fn LWLockRegisterTranche(arg1: ::libc::c_int,
                                 arg2: *mut LWLockTranche) -> ();
    pub fn LWLockInitialize(arg1: *mut LWLock, tranche_id: ::libc::c_int)
     -> ();
    pub fn hash_create(tabname: *const ::libc::c_char, nelem: ::libc::c_long,
                       info: *mut HASHCTL, flags: ::libc::c_int) -> *mut HTAB;
    pub fn hash_destroy(hashp: *mut HTAB) -> ();
    pub fn hash_stats(_where: *const ::libc::c_char, hashp: *mut HTAB) -> ();
    pub fn hash_search(hashp: *mut HTAB, keyPtr: *const ::libc::c_void,
                       action: HASHACTION, foundPtr: *mut _bool)
     -> *mut ::libc::c_void;
    pub fn get_hash_value(hashp: *mut HTAB, keyPtr: *const ::libc::c_void)
     -> uint32;
    pub fn hash_search_with_hash_value(hashp: *mut HTAB,
                                       keyPtr: *const ::libc::c_void,
                                       hashvalue: uint32, action: HASHACTION,
                                       foundPtr: *mut _bool)
     -> *mut ::libc::c_void;
    pub fn hash_update_hash_key(hashp: *mut HTAB,
                                existingEntry: *mut ::libc::c_void,
                                newKeyPtr: *const ::libc::c_void) -> _bool;
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::libc::c_long;
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB)
     -> ();
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS)
     -> *mut ::libc::c_void;
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS) -> ();
    pub fn hash_freeze(hashp: *mut HTAB) -> ();
    pub fn hash_estimate_size(num_entries: ::libc::c_long, entrysize: Size)
     -> Size;
    pub fn hash_select_dirsize(num_entries: ::libc::c_long) -> ::libc::c_long;
    pub fn hash_get_shared_size(info: *mut HASHCTL, flags: ::libc::c_int)
     -> Size;
    pub fn AtEOXact_HashTables(isCommit: _bool) -> ();
    pub fn AtEOSubXact_HashTables(isCommit: _bool, nestDepth: ::libc::c_int)
     -> ();
    pub fn string_hash(key: *const ::libc::c_void, keysize: Size) -> uint32;
    pub fn tag_hash(key: *const ::libc::c_void, keysize: Size) -> uint32;
    pub fn oid_hash(key: *const ::libc::c_void, keysize: Size) -> uint32;
    pub fn bitmap_hash(key: *const ::libc::c_void, keysize: Size) -> uint32;
    pub fn bitmap_match(key1: *const ::libc::c_void,
                        key2: *const ::libc::c_void, keysize: Size)
     -> ::libc::c_int;
    pub fn InitShmemAccess(seghdr: *mut ::libc::c_void) -> ();
    pub fn InitShmemAllocation() -> ();
    pub fn ShmemAlloc(size: Size) -> *mut ::libc::c_void;
    pub fn ShmemAddrIsValid(addr: *const ::libc::c_void) -> _bool;
    pub fn InitShmemIndex() -> ();
    pub fn ShmemInitHash(name: *const ::libc::c_char,
                         init_size: ::libc::c_long, max_size: ::libc::c_long,
                         infoP: *mut HASHCTL, hash_flags: ::libc::c_int)
     -> *mut HTAB;
    pub fn ShmemInitStruct(name: *const ::libc::c_char, size: Size,
                           foundPtr: *mut _bool) -> *mut ::libc::c_void;
    pub fn add_size(s1: Size, s2: Size) -> Size;
    pub fn mul_size(s1: Size, s2: Size) -> Size;
    pub fn RequestAddinShmemSpace(size: Size) -> ();
    pub fn SHMQueueInit(queue: *mut SHM_QUEUE) -> ();
    pub fn SHMQueueElemInit(queue: *mut SHM_QUEUE) -> ();
    pub fn SHMQueueDelete(queue: *mut SHM_QUEUE) -> ();
    pub fn SHMQueueInsertBefore(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE)
     -> ();
    pub fn SHMQueueInsertAfter(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE)
     -> ();
    pub fn SHMQueueNext(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueuePrev(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueueEmpty(queue: *const SHM_QUEUE) -> _bool;
    pub fn SHMQueueIsDetached(queue: *const SHM_QUEUE) -> _bool;
    pub fn InitLocks() -> ();
    pub fn GetLocksMethodTable(lock: *const LOCK) -> LockMethod;
    pub fn LockTagHashCode(locktag: *const LOCKTAG) -> uint32;
    pub fn DoLockModesConflict(mode1: LOCKMODE, mode2: LOCKMODE) -> _bool;
    pub fn LockAcquire(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                       sessionLock: _bool, dontWait: _bool)
     -> LockAcquireResult;
    pub fn LockAcquireExtended(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                               sessionLock: _bool, dontWait: _bool,
                               report_memory_error: _bool)
     -> LockAcquireResult;
    pub fn AbortStrongLockAcquire() -> ();
    pub fn LockRelease(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                       sessionLock: _bool) -> _bool;
    pub fn LockReleaseAll(lockmethodid: LOCKMETHODID, allLocks: _bool) -> ();
    pub fn LockReleaseSession(lockmethodid: LOCKMETHODID) -> ();
    pub fn LockReleaseCurrentOwner(locallocks: *mut *mut LOCALLOCK,
                                   nlocks: ::libc::c_int) -> ();
    pub fn LockReassignCurrentOwner(locallocks: *mut *mut LOCALLOCK,
                                    nlocks: ::libc::c_int) -> ();
    pub fn LockHasWaiters(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                          sessionLock: _bool) -> _bool;
    pub fn GetLockConflicts(locktag: *const LOCKTAG, lockmode: LOCKMODE)
     -> *mut VirtualTransactionId;
    pub fn AtPrepare_Locks() -> ();
    pub fn PostPrepare_Locks(xid: TransactionId) -> ();
    pub fn LockCheckConflicts(lockMethodTable: LockMethod, lockmode: LOCKMODE,
                              lock: *mut LOCK, proclock: *mut PROCLOCK)
     -> ::libc::c_int;
    pub fn GrantLock(lock: *mut LOCK, proclock: *mut PROCLOCK,
                     lockmode: LOCKMODE) -> ();
    pub fn GrantAwaitedLock() -> ();
    pub fn RemoveFromWaitQueue(_proc: *mut PGPROC, hashcode: uint32) -> ();
    pub fn LockShmemSize() -> Size;
    pub fn GetLockStatusData() -> *mut LockData;
    pub fn ReportLockTableError(report: _bool) -> ();
    pub fn GetRunningTransactionLocks(nlocks: *mut ::libc::c_int)
     -> *mut xl_standby_lock;
    pub fn GetLockmodeName(lockmethodid: LOCKMETHODID, mode: LOCKMODE)
     -> *const ::libc::c_char;
    pub fn lock_twophase_recover(xid: TransactionId, info: uint16,
                                 recdata: *mut ::libc::c_void, len: uint32)
     -> ();
    pub fn lock_twophase_postcommit(xid: TransactionId, info: uint16,
                                    recdata: *mut ::libc::c_void, len: uint32)
     -> ();
    pub fn lock_twophase_postabort(xid: TransactionId, info: uint16,
                                   recdata: *mut ::libc::c_void, len: uint32)
     -> ();
    pub fn lock_twophase_standby_recover(xid: TransactionId, info: uint16,
                                         recdata: *mut ::libc::c_void,
                                         len: uint32) -> ();
    pub fn DeadLockCheck(_proc: *mut PGPROC) -> DeadLockState;
    pub fn GetBlockingAutoVacuumPgproc() -> *mut PGPROC;
    pub fn DeadLockReport() -> ();
    pub fn RememberSimpleDeadLock(proc1: *mut PGPROC, lockmode: LOCKMODE,
                                  lock: *mut LOCK, proc2: *mut PGPROC) -> ();
    pub fn InitDeadLockChecking() -> ();
    pub fn VirtualXactLockTableInsert(vxid: VirtualTransactionId) -> ();
    pub fn VirtualXactLockTableCleanup() -> ();
    pub fn VirtualXactLock(vxid: VirtualTransactionId, wait: _bool) -> _bool;
    pub fn nodeToString(obj: *const ::libc::c_void) -> *mut ::libc::c_char;
    pub fn stringToNode(str: *mut ::libc::c_char) -> *mut ::libc::c_void;
    pub fn copyObject(obj: *const ::libc::c_void) -> *mut ::libc::c_void;
    pub fn equal(a: *const ::libc::c_void, b: *const ::libc::c_void) -> _bool;
    pub fn lappend(list: *mut List, datum: *mut ::libc::c_void) -> *mut List;
    pub fn lappend_int(list: *mut List, datum: ::libc::c_int) -> *mut List;
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn lappend_cell(list: *mut List, prev: *mut ListCell,
                        datum: *mut ::libc::c_void) -> *mut ListCell;
    pub fn lappend_cell_int(list: *mut List, prev: *mut ListCell,
                            datum: ::libc::c_int) -> *mut ListCell;
    pub fn lappend_cell_oid(list: *mut List, prev: *mut ListCell, datum: Oid)
     -> *mut ListCell;
    pub fn lcons(datum: *mut ::libc::c_void, list: *mut List) -> *mut List;
    pub fn lcons_int(datum: ::libc::c_int, list: *mut List) -> *mut List;
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
    pub fn list_concat(list1: *mut List, list2: *mut List) -> *mut List;
    pub fn list_truncate(list: *mut List, new_size: ::libc::c_int)
     -> *mut List;
    pub fn list_nth(list: *const List, n: ::libc::c_int)
     -> *mut ::libc::c_void;
    pub fn list_nth_int(list: *const List, n: ::libc::c_int) -> ::libc::c_int;
    pub fn list_nth_oid(list: *const List, n: ::libc::c_int) -> Oid;
    pub fn list_member(list: *const List, datum: *const ::libc::c_void)
     -> _bool;
    pub fn list_member_ptr(list: *const List, datum: *const ::libc::c_void)
     -> _bool;
    pub fn list_member_int(list: *const List, datum: ::libc::c_int) -> _bool;
    pub fn list_member_oid(list: *const List, datum: Oid) -> _bool;
    pub fn list_delete(list: *mut List, datum: *mut ::libc::c_void)
     -> *mut List;
    pub fn list_delete_ptr(list: *mut List, datum: *mut ::libc::c_void)
     -> *mut List;
    pub fn list_delete_int(list: *mut List, datum: ::libc::c_int)
     -> *mut List;
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_delete_first(list: *mut List) -> *mut List;
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell,
                            prev: *mut ListCell) -> *mut List;
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_intersection(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_append_unique(list: *mut List, datum: *mut ::libc::c_void)
     -> *mut List;
    pub fn list_append_unique_ptr(list: *mut List, datum: *mut ::libc::c_void)
     -> *mut List;
    pub fn list_append_unique_int(list: *mut List, datum: ::libc::c_int)
     -> *mut List;
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_concat_unique(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_int(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_oid(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_free(list: *mut List) -> ();
    pub fn list_free_deep(list: *mut List) -> ();
    pub fn list_copy(list: *const List) -> *mut List;
    pub fn list_copy_tail(list: *const List, nskip: ::libc::c_int)
     -> *mut List;
    pub fn CreateTemplateTupleDesc(natts: ::libc::c_int, hasoid: _bool)
     -> TupleDesc;
    pub fn CreateTupleDesc(natts: ::libc::c_int, hasoid: _bool,
                           attrs: *mut Form_pg_attribute) -> TupleDesc;
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
    pub fn TupleDescCopyEntry(dst: TupleDesc, dstAttno: AttrNumber,
                              src: TupleDesc, srcAttno: AttrNumber) -> ();
    pub fn FreeTupleDesc(tupdesc: TupleDesc) -> ();
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc) -> ();
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc) -> ();
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> _bool;
    pub fn TupleDescInitEntry(desc: TupleDesc, attributeNumber: AttrNumber,
                              attributeName: *const ::libc::c_char,
                              oidtypeid: Oid, typmod: int32,
                              attdim: ::libc::c_int) -> ();
    pub fn TupleDescInitEntryCollation(desc: TupleDesc,
                                       attributeNumber: AttrNumber,
                                       collationid: Oid) -> ();
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
    pub fn BuildDescFromLists(names: *mut List, types: *mut List,
                              typmods: *mut List, collations: *mut List)
     -> TupleDesc;
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_make_singleton(x: ::libc::c_int) -> *mut Bitmapset;
    pub fn bms_free(a: *mut Bitmapset) -> ();
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset)
     -> BMS_Comparison;
    pub fn bms_is_member(x: ::libc::c_int, a: *const Bitmapset) -> _bool;
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> _bool;
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::libc::c_int;
    pub fn bms_num_members(a: *const Bitmapset) -> ::libc::c_int;
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
    pub fn bms_is_empty(a: *const Bitmapset) -> _bool;
    pub fn bms_add_member(a: *mut Bitmapset, x: ::libc::c_int)
     -> *mut Bitmapset;
    pub fn bms_del_member(a: *mut Bitmapset, x: ::libc::c_int)
     -> *mut Bitmapset;
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
    pub fn bms_first_member(a: *mut Bitmapset) -> ::libc::c_int;
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
    pub fn RelationClose(relation: Relation) -> ();
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
    pub fn RelationGetOidIndex(relation: Relation) -> Oid;
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
    pub fn RelationGetIndexAttrBitmap(relation: Relation,
                                      keyAttrs: IndexAttrBitmapKind)
     -> *mut Bitmapset;
    pub fn RelationGetExclusionInfo(indexRelation: Relation,
                                    operators: *mut *mut Oid,
                                    procs: *mut *mut Oid,
                                    strategies: *mut *mut uint16) -> ();
    pub fn RelationSetIndexList(relation: Relation, indexIds: *mut List,
                                oidIndex: Oid) -> ();
    pub fn RelationInitIndexAccessInfo(relation: Relation) -> ();
    pub fn errtable(rel: Relation) -> ::libc::c_int;
    pub fn errtablecol(rel: Relation, attnum: ::libc::c_int) -> ::libc::c_int;
    pub fn errtablecolname(rel: Relation, colname: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn errtableconstraint(rel: Relation, conname: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn RelationCacheInitialize() -> ();
    pub fn RelationCacheInitializePhase2() -> ();
    pub fn RelationCacheInitializePhase3() -> ();
    pub fn RelationBuildLocalRelation(relname: *const ::libc::c_char,
                                      relnamespace: Oid, tupDesc: TupleDesc,
                                      relid: Oid, relfilenode: Oid,
                                      reltablespace: Oid,
                                      shared_relation: _bool,
                                      mapped_relation: _bool,
                                      relpersistence: ::libc::c_char,
                                      relkind: ::libc::c_char) -> Relation;
    pub fn RelationSetNewRelfilenode(relation: Relation,
                                     freezeXid: TransactionId,
                                     minmulti: MultiXactId) -> ();
    pub fn RelationForgetRelation(rid: Oid) -> ();
    pub fn RelationCacheInvalidateEntry(relationId: Oid) -> ();
    pub fn RelationCacheInvalidate() -> ();
    pub fn RelationCloseSmgrByOid(relationId: Oid) -> ();
    pub fn AtEOXact_RelationCache(isCommit: _bool) -> ();
    pub fn AtEOSubXact_RelationCache(isCommit: _bool,
                                     mySubid: SubTransactionId,
                                     parentSubid: SubTransactionId) -> ();
    pub fn RelationIdIsInInitFile(relationId: Oid) -> _bool;
    pub fn RelationCacheInitFilePreInvalidate() -> ();
    pub fn RelationCacheInitFilePostInvalidate() -> ();
    pub fn RelationCacheInitFileRemove() -> ();
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderAdjustCmax(tup: HeapTupleHeader,
                                     cmax: *mut CommandId,
                                     iscombo: *mut _bool) -> ();
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
    pub fn index_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn index_close(relation: Relation, lockmode: LOCKMODE) -> ();
    pub fn index_insert(indexRelation: Relation, values: *mut Datum,
                        isnull: *mut _bool, heap_t_ctid: ItemPointer,
                        heapRelation: Relation, checkUnique: IndexUniqueCheck)
     -> _bool;
    pub fn index_beginscan(heapRelation: Relation, indexRelation: Relation,
                           snapshot: Snapshot, nkeys: ::libc::c_int,
                           norderbys: ::libc::c_int) -> IndexScanDesc;
    pub fn index_beginscan_bitmap(indexRelation: Relation, snapshot: Snapshot,
                                  nkeys: ::libc::c_int) -> IndexScanDesc;
    pub fn index_rescan(scan: IndexScanDesc, keys: ScanKey,
                        nkeys: ::libc::c_int, orderbys: ScanKey,
                        norderbys: ::libc::c_int) -> ();
    pub fn index_endscan(scan: IndexScanDesc) -> ();
    pub fn index_markpos(scan: IndexScanDesc) -> ();
    pub fn index_restrpos(scan: IndexScanDesc) -> ();
    pub fn index_getnext_tid(scan: IndexScanDesc, direction: ScanDirection)
     -> ItemPointer;
    pub fn index_fetch_heap(scan: IndexScanDesc) -> HeapTuple;
    pub fn index_getnext(scan: IndexScanDesc, direction: ScanDirection)
     -> HeapTuple;
    pub fn index_getbitmap(scan: IndexScanDesc, bitmap: *mut TIDBitmap)
     -> int64;
    pub fn index_bulk_delete(info: *mut IndexVacuumInfo,
                             stats: *mut IndexBulkDeleteResult,
                             callback: IndexBulkDeleteCallback,
                             callback_state: *mut ::libc::c_void)
     -> *mut IndexBulkDeleteResult;
    pub fn index_vacuum_cleanup(info: *mut IndexVacuumInfo,
                                stats: *mut IndexBulkDeleteResult)
     -> *mut IndexBulkDeleteResult;
    pub fn index_can_return(indexRelation: Relation) -> _bool;
    pub fn index_getprocid(irel: Relation, attnum: AttrNumber,
                           procnum: uint16) -> RegProcedure;
    pub fn index_getprocinfo(irel: Relation, attnum: AttrNumber,
                             procnum: uint16) -> *mut FmgrInfo;
    pub fn RelationGetIndexScan(indexRelation: Relation, nkeys: ::libc::c_int,
                                norderbys: ::libc::c_int) -> IndexScanDesc;
    pub fn IndexScanEnd(scan: IndexScanDesc) -> ();
    pub fn BuildIndexValueDescription(indexRelation: Relation,
                                      values: *mut Datum, isnull: *mut _bool)
     -> *mut ::libc::c_char;
    pub fn systable_beginscan(heapRelation: Relation, indexId: Oid,
                              indexOK: _bool, snapshot: Snapshot,
                              nkeys: ::libc::c_int, key: ScanKey)
     -> SysScanDesc;
    pub fn systable_getnext(sysscan: SysScanDesc) -> HeapTuple;
    pub fn systable_recheck_tuple(sysscan: SysScanDesc, tup: HeapTuple)
     -> _bool;
    pub fn systable_endscan(sysscan: SysScanDesc) -> ();
    pub fn systable_beginscan_ordered(heapRelation: Relation,
                                      indexRelation: Relation,
                                      snapshot: Snapshot,
                                      nkeys: ::libc::c_int, key: ScanKey)
     -> SysScanDesc;
    pub fn systable_getnext_ordered(sysscan: SysScanDesc,
                                    direction: ScanDirection) -> HeapTuple;
    pub fn systable_endscan_ordered(sysscan: SysScanDesc) -> ();
    pub fn makeInteger(i: ::libc::c_long) -> *mut Value;
    pub fn makeFloat(numericStr: *mut ::libc::c_char) -> *mut Value;
    pub fn makeString(str: *mut ::libc::c_char) -> *mut Value;
    pub fn makeBitString(str: *mut ::libc::c_char) -> *mut Value;
    pub fn open(arg1: *const ::libc::c_char, arg2: ::libc::c_int, ...)
     -> ::libc::c_int;
    pub fn openat(arg1: ::libc::c_int, arg2: *const ::libc::c_char,
                  arg3: ::libc::c_int, ...) -> ::libc::c_int;
    pub fn creat(arg1: *const ::libc::c_char, arg2: mode_t) -> ::libc::c_int;
    pub fn fcntl(arg1: ::libc::c_int, arg2: ::libc::c_int, ...)
     -> ::libc::c_int;
    pub fn openx_np(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                    arg3: filesec_t) -> ::libc::c_int;
    pub fn open_dprotected_np(arg1: *const ::libc::c_char,
                              arg2: ::libc::c_int, arg3: ::libc::c_int,
                              arg4: ::libc::c_int, ...) -> ::libc::c_int;
    pub fn flock(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
    pub fn filesec_init() -> filesec_t;
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
    pub fn filesec_free(arg1: filesec_t) -> ();
    pub fn filesec_get_property(arg1: filesec_t, arg2: filesec_property_t,
                                arg3: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn filesec_query_property(arg1: filesec_t, arg2: filesec_property_t,
                                  arg3: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn filesec_set_property(arg1: filesec_t, arg2: filesec_property_t,
                                arg3: *const ::libc::c_void) -> ::libc::c_int;
    pub fn filesec_unset_property(arg1: filesec_t, arg2: filesec_property_t)
     -> ::libc::c_int;
    pub fn TransactionStartedDuringRecovery() -> _bool;
    pub fn TransactionIdDidCommit(transactionId: TransactionId) -> _bool;
    pub fn TransactionIdDidAbort(transactionId: TransactionId) -> _bool;
    pub fn TransactionIdIsKnownCompleted(transactionId: TransactionId)
     -> _bool;
    pub fn TransactionIdAbort(transactionId: TransactionId) -> ();
    pub fn TransactionIdCommitTree(xid: TransactionId, nxids: ::libc::c_int,
                                   xids: *mut TransactionId) -> ();
    pub fn TransactionIdAsyncCommitTree(xid: TransactionId,
                                        nxids: ::libc::c_int,
                                        xids: *mut TransactionId,
                                        lsn: XLogRecPtr) -> ();
    pub fn TransactionIdAbortTree(xid: TransactionId, nxids: ::libc::c_int,
                                  xids: *mut TransactionId) -> ();
    pub fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId)
     -> _bool;
    pub fn TransactionIdPrecedesOrEquals(id1: TransactionId,
                                         id2: TransactionId) -> _bool;
    pub fn TransactionIdFollows(id1: TransactionId, id2: TransactionId)
     -> _bool;
    pub fn TransactionIdFollowsOrEquals(id1: TransactionId,
                                        id2: TransactionId) -> _bool;
    pub fn TransactionIdLatest(mainxid: TransactionId, nxids: ::libc::c_int,
                               xids: *const TransactionId) -> TransactionId;
    pub fn TransactionIdGetCommitLSN(xid: TransactionId) -> XLogRecPtr;
    pub fn GetNewTransactionId(isSubXact: _bool) -> TransactionId;
    pub fn ReadNewTransactionId() -> TransactionId;
    pub fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId,
                                 oldest_datoid: Oid) -> ();
    pub fn ForceTransactionIdLimitUpdate() -> _bool;
    pub fn GetNewObjectId() -> Oid;
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size) -> ();
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> _bool;
    pub fn PageAddItem(page: Page, item: Item, size: Size,
                       offsetNumber: OffsetNumber, overwrite: _bool,
                       is_heap: _bool) -> OffsetNumber;
    pub fn PageGetTempPage(page: Page) -> Page;
    pub fn PageGetTempPageCopy(page: Page) -> Page;
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page) -> ();
    pub fn PageRepairFragmentation(page: Page) -> ();
    pub fn PageGetFreeSpace(page: Page) -> Size;
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber) -> ();
    pub fn PageIndexMultiDelete(page: Page, itemnos: *mut OffsetNumber,
                                nitems: ::libc::c_int) -> ();
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber)
     -> *mut ::libc::c_char;
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber) -> ();
    pub fn heap_compute_data_size(tupleDesc: TupleDesc, values: *mut Datum,
                                  isnull: *mut _bool) -> Size;
    pub fn heap_fill_tuple(tupleDesc: TupleDesc, values: *mut Datum,
                           isnull: *mut _bool, data: *mut ::libc::c_char,
                           data_size: Size, infomask: *mut uint16,
                           bit: *mut bits8) -> ();
    pub fn heap_attisnull(tup: HeapTuple, attnum: ::libc::c_int) -> _bool;
    pub fn nocachegetattr(tup: HeapTuple, attnum: ::libc::c_int,
                          att: TupleDesc) -> Datum;
    pub fn heap_getsysattr(tup: HeapTuple, attnum: ::libc::c_int,
                           tupleDesc: TupleDesc, isnull: *mut _bool) -> Datum;
    pub fn heap_copytuple(tuple: HeapTuple) -> HeapTuple;
    pub fn heap_copytuple_with_tuple(src: HeapTuple, dest: HeapTuple) -> ();
    pub fn heap_copy_tuple_as_datum(tuple: HeapTuple, tupleDesc: TupleDesc)
     -> Datum;
    pub fn heap_form_tuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                           isnull: *mut _bool) -> HeapTuple;
    pub fn heap_modify_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             replValues: *mut Datum, replIsnull: *mut _bool,
                             doReplace: *mut _bool) -> HeapTuple;
    pub fn heap_deform_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             values: *mut Datum, isnull: *mut _bool) -> ();
    pub fn heap_formtuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                          nulls: *mut ::libc::c_char) -> HeapTuple;
    pub fn heap_modifytuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                            replValues: *mut Datum,
                            replNulls: *mut ::libc::c_char,
                            replActions: *mut ::libc::c_char) -> HeapTuple;
    pub fn heap_deformtuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                            values: *mut Datum, nulls: *mut ::libc::c_char)
     -> ();
    pub fn heap_freetuple(htup: HeapTuple) -> ();
    pub fn heap_form_minimal_tuple(tupleDescriptor: TupleDesc,
                                   values: *mut Datum, isnull: *mut _bool)
     -> MinimalTuple;
    pub fn heap_free_minimal_tuple(mtup: MinimalTuple) -> ();
    pub fn heap_copy_minimal_tuple(mtup: MinimalTuple) -> MinimalTuple;
    pub fn heap_tuple_from_minimal_tuple(mtup: MinimalTuple) -> HeapTuple;
    pub fn minimal_tuple_from_heap_tuple(htup: HeapTuple) -> MinimalTuple;
    pub fn slist_delete(head: *mut slist_head, node: *mut slist_node) -> ();
    pub fn forkname_to_number(forkName: *const ::libc::c_char) -> ForkNumber;
    pub fn forkname_chars(str: *const ::libc::c_char, fork: *mut ForkNumber)
     -> ::libc::c_int;
    pub fn GetDatabasePath(dbNode: Oid, spcNode: Oid) -> *mut ::libc::c_char;
    pub fn GetRelationPath(dbNode: Oid, spcNode: Oid, relNode: Oid,
                           backendId: ::libc::c_int, forkNumber: ForkNumber)
     -> *mut ::libc::c_char;
    pub fn SendSharedInvalidMessages(msgs: *const SharedInvalidationMessage,
                                     n: ::libc::c_int) -> ();
    pub fn ReceiveSharedInvalidMessages(
        invalFunction: ::std::option::Option<extern "C"
                           fn(msg: *mut SharedInvalidationMessage) -> ()>,
        resetFunction: ::std::option::Option<extern "C" fn() -> ()>
    ) -> ();
    pub fn HandleCatchupInterrupt() -> ();
    pub fn EnableCatchupInterrupt() -> ();
    pub fn DisableCatchupInterrupt() -> _bool;
    pub fn xactGetCommittedInvalidationMessages(
        msgs: *mut *mut SharedInvalidationMessage,
        RelcacheInitFileInval: *mut _bool
    ) -> ::libc::c_int;
    pub fn ProcessCommittedInvalidationMessages(
        msgs: *mut SharedInvalidationMessage,
        nmsgs: ::libc::c_int,
        RelcacheInitFileInval: _bool,
        dbid: Oid, tsid: Oid
    ) -> ();
    pub fn LocalExecuteInvalidationMessage(msg: *mut SharedInvalidationMessage)
     -> ();
    pub fn RelationIncrementReferenceCount(rel: Relation) -> ();
    pub fn RelationDecrementReferenceCount(rel: Relation) -> ();
    pub fn __math_errhandling() -> ::libc::c_int;
    pub fn __fpclassifyf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn __fpclassifyd(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __fpclassifyl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isfinitef(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isfinited(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isfinitel(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isinff(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isinfd(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isinfl(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnanf(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isnand(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnanl(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnormalf(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_isnormald(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_isnormall(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_signbitf(__x: ::libc::c_float) -> ::libc::c_int;
    pub fn __inline_signbitd(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn __inline_signbitl(__x: ::libc::c_double) -> ::libc::c_int;
    pub fn acosf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn acos(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acosl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn asin(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn atan(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atan2f(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn atan2(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn atan2l(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn cosf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cos(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cosl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sin(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tan(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acoshf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn acosh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn acoshl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn asinh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn asinhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn atanh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn atanhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn coshf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cosh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn coshl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sinh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sinhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanhf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tanh(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tanhl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn exp(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn exp2f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn exp2(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn exp2l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expm1f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn expm1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn expm1l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log10f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log10(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log10l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log2f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log2(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log2l(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log1pf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn log1p(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn log1pl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logbf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn logb(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn logbl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn modff(arg1: ::libc::c_float, arg2: *mut ::libc::c_float)
     -> ::libc::c_float;
    pub fn modf(arg1: ::libc::c_double, arg2: *mut ::libc::c_double)
     -> ::libc::c_double;
    pub fn modfl(arg1: ::libc::c_double, arg2: *mut ::libc::c_double)
     -> ::libc::c_double;
    pub fn ldexpf(arg1: ::libc::c_float, arg2: ::libc::c_int)
     -> ::libc::c_float;
    pub fn ldexp(arg1: ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn ldexpl(arg1: ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn frexpf(arg1: ::libc::c_float, arg2: *mut ::libc::c_int)
     -> ::libc::c_float;
    pub fn frexp(arg1: ::libc::c_double, arg2: *mut ::libc::c_int)
     -> ::libc::c_double;
    pub fn frexpl(arg1: ::libc::c_double, arg2: *mut ::libc::c_int)
     -> ::libc::c_double;
    pub fn ilogbf(arg1: ::libc::c_float) -> ::libc::c_int;
    pub fn ilogb(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn ilogbl(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn scalbnf(arg1: ::libc::c_float, arg2: ::libc::c_int)
     -> ::libc::c_float;
    pub fn scalbn(arg1: ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn scalbnl(arg1: ::libc::c_double, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn scalblnf(arg1: ::libc::c_float, arg2: ::libc::c_long)
     -> ::libc::c_float;
    pub fn scalbln(arg1: ::libc::c_double, arg2: ::libc::c_long)
     -> ::libc::c_double;
    pub fn scalblnl(arg1: ::libc::c_double, arg2: ::libc::c_long)
     -> ::libc::c_double;
    pub fn fabsf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn fabs(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn fabsl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cbrtf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn cbrt(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn cbrtl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn hypotf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn hypot(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn hypotl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn powf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn pow(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn powl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn sqrtf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn sqrt(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn sqrtl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erff(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn erf(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfcf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn erfc(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn erfcl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn lgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tgammaf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn tgamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn tgammal(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn ceilf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn ceil(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn ceill(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn floorf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn floor(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn floorl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn nearbyintf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn nearbyint(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn nearbyintl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn rintf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn rint(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn rintl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lrintf(arg1: ::libc::c_float) -> ::libc::c_long;
    pub fn lrint(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn lrintl(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn roundf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn round(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn roundl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn lroundf(arg1: ::libc::c_float) -> ::libc::c_long;
    pub fn lround(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn lroundl(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn llrintf(arg1: ::libc::c_float) -> ::libc::c_longlong;
    pub fn llrint(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llrintl(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llroundf(arg1: ::libc::c_float) -> ::libc::c_longlong;
    pub fn llround(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn llroundl(arg1: ::libc::c_double) -> ::libc::c_longlong;
    pub fn truncf(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn trunc(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn truncl(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn fmodf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn fmod(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fmodl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn remainderf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn remainder(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn remainderl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn remquof(arg1: ::libc::c_float, arg2: ::libc::c_float,
                   arg3: *mut ::libc::c_int) -> ::libc::c_float;
    pub fn remquo(arg1: ::libc::c_double, arg2: ::libc::c_double,
                  arg3: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn remquol(arg1: ::libc::c_double, arg2: ::libc::c_double,
                   arg3: *mut ::libc::c_int) -> ::libc::c_double;
    pub fn copysignf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn copysign(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn copysignl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn nanf(arg1: *const ::libc::c_char) -> ::libc::c_float;
    pub fn nan(arg1: *const ::libc::c_char) -> ::libc::c_double;
    pub fn nanl(arg1: *const ::libc::c_char) -> ::libc::c_double;
    pub fn nextafterf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn nextafter(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn nextafterl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn nexttoward(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn nexttowardf(arg1: ::libc::c_float, arg2: ::libc::c_double)
     -> ::libc::c_float;
    pub fn nexttowardl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fdimf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn fdim(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fdiml(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fmaxf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn fmax(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fmaxl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fminf(arg1: ::libc::c_float, arg2: ::libc::c_float)
     -> ::libc::c_float;
    pub fn fmin(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fminl(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn fmaf(arg1: ::libc::c_float, arg2: ::libc::c_float,
                arg3: ::libc::c_float) -> ::libc::c_float;
    pub fn fma(arg1: ::libc::c_double, arg2: ::libc::c_double,
               arg3: ::libc::c_double) -> ::libc::c_double;
    pub fn fmal(arg1: ::libc::c_double, arg2: ::libc::c_double,
                arg3: ::libc::c_double) -> ::libc::c_double;
    pub fn __inff() -> ::libc::c_float;
    pub fn __inf() -> ::libc::c_double;
    pub fn __infl() -> ::libc::c_double;
    pub fn __nan() -> ::libc::c_float;
    pub fn __exp10f(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __exp10(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sincosf(__x: ::libc::c_float, __sinp: *mut ::libc::c_float,
                     __cosp: *mut ::libc::c_float) -> ();
    pub fn __sincos(__x: ::libc::c_double, __sinp: *mut ::libc::c_double,
                    __cosp: *mut ::libc::c_double) -> ();
    pub fn __cospif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __cospi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sinpif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __sinpi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __tanpif(arg1: ::libc::c_float) -> ::libc::c_float;
    pub fn __tanpi(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn __sincospif(__x: ::libc::c_float, __sinp: *mut ::libc::c_float,
                       __cosp: *mut ::libc::c_float) -> ();
    pub fn __sincospi(__x: ::libc::c_double, __sinp: *mut ::libc::c_double,
                      __cosp: *mut ::libc::c_double) -> ();
    pub fn __sincosf_stret(arg1: ::libc::c_float) -> Struct___float2;
    pub fn __sincos_stret(arg1: ::libc::c_double) -> Struct___double2;
    pub fn __sincospif_stret(arg1: ::libc::c_float) -> Struct___float2;
    pub fn __sincospi_stret(arg1: ::libc::c_double) -> Struct___double2;
    pub fn j0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn j1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn jn(arg1: ::libc::c_int, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn y0(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn y1(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn yn(arg1: ::libc::c_int, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn scalb(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn rinttol(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn roundtol(arg1: ::libc::c_double) -> ::libc::c_long;
    pub fn drem(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> ::libc::c_double;
    pub fn finite(arg1: ::libc::c_double) -> ::libc::c_int;
    pub fn gamma(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn significand(arg1: ::libc::c_double) -> ::libc::c_double;
    pub fn matherr(arg1: *mut Struct_exception) -> ::libc::c_int;
    pub fn pg_localtime(timep: *const pg_time_t, tz: *const pg_tz)
     -> *mut Struct_pg_tm;
    pub fn pg_gmtime(timep: *const pg_time_t) -> *mut Struct_pg_tm;
    pub fn pg_next_dst_boundary(timep: *const pg_time_t,
                                before_gmtoff: *mut ::libc::c_long,
                                before_isdst: *mut ::libc::c_int,
                                boundary: *mut pg_time_t,
                                after_gmtoff: *mut ::libc::c_long,
                                after_isdst: *mut ::libc::c_int,
                                tz: *const pg_tz) -> ::libc::c_int;
    pub fn pg_interpret_timezone_abbrev(abbrev: *const ::libc::c_char,
                                        timep: *const pg_time_t,
                                        gmtoff: *mut ::libc::c_long,
                                        isdst: *mut ::libc::c_int,
                                        tz: *const pg_tz) -> _bool;
    pub fn pg_get_timezone_offset(tz: *const pg_tz,
                                  gmtoff: *mut ::libc::c_long) -> _bool;
    pub fn pg_get_timezone_name(tz: *mut pg_tz) -> *const ::libc::c_char;
    pub fn pg_tz_acceptable(tz: *mut pg_tz) -> _bool;
    pub fn pg_strftime(s: *mut ::libc::c_char, max: size_t,
                       format: *const ::libc::c_char, tm: *const Struct_pg_tm)
     -> size_t;
    pub fn pg_timezone_initialize() -> ();
    pub fn pg_tzset(tzname: *const ::libc::c_char) -> *mut pg_tz;
    pub fn pg_tzset_offset(gmtoffset: ::libc::c_long) -> *mut pg_tz;
    pub fn pg_tzenumerate_start() -> *mut pg_tzenum;
    pub fn pg_tzenumerate_next(dir: *mut pg_tzenum) -> *mut pg_tz;
    pub fn pg_tzenumerate_end(dir: *mut pg_tzenum) -> ();
    pub fn timestamp_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_hours(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_days(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mul_d_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn now(fcinfo: FunctionCallInfo) -> Datum;
    pub fn statement_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clock_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_conf_load_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn GetCurrentTimestamp() -> TimestampTz;
    pub fn TimestampDifference(start_time: TimestampTz,
                               stop_time: TimestampTz,
                               secs: *mut ::libc::c_long,
                               microsecs: *mut ::libc::c_int) -> ();
    pub fn TimestampDifferenceExceeds(start_time: TimestampTz,
                                      stop_time: TimestampTz,
                                      msec: ::libc::c_int) -> _bool;
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
    pub fn timestamptz_to_str(t: TimestampTz) -> *const ::libc::c_char;
    pub fn tm2timestamp(tm: *mut Struct_pg_tm, fsec: fsec_t,
                        tzp: *mut ::libc::c_int, dt: *mut Timestamp)
     -> ::libc::c_int;
    pub fn timestamp2tm(dt: Timestamp, tzp: *mut ::libc::c_int,
                        tm: *mut Struct_pg_tm, fsec: *mut fsec_t,
                        tzn: *mut *const ::libc::c_char,
                        attimezone: *mut pg_tz) -> ::libc::c_int;
    pub fn dt2time(dt: Timestamp, hour: *mut ::libc::c_int,
                   min: *mut ::libc::c_int, sec: *mut ::libc::c_int,
                   fsec: *mut fsec_t) -> ();
    pub fn interval2tm(span: Interval, tm: *mut Struct_pg_tm,
                       fsec: *mut fsec_t) -> ::libc::c_int;
    pub fn tm2interval(tm: *mut Struct_pg_tm, fsec: fsec_t,
                       span: *mut Interval) -> ::libc::c_int;
    pub fn SetEpochTimestamp() -> Timestamp;
    pub fn GetEpochTime(tm: *mut Struct_pg_tm) -> ();
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp)
     -> ::libc::c_int;
    pub fn isoweek2j(year: ::libc::c_int, week: ::libc::c_int)
     -> ::libc::c_int;
    pub fn isoweek2date(woy: ::libc::c_int, year: *mut ::libc::c_int,
                        mon: *mut ::libc::c_int, mday: *mut ::libc::c_int)
     -> ();
    pub fn isoweekdate2date(isoweek: ::libc::c_int, wday: ::libc::c_int,
                            year: *mut ::libc::c_int, mon: *mut ::libc::c_int,
                            mday: *mut ::libc::c_int) -> ();
    pub fn date2isoweek(year: ::libc::c_int, mon: ::libc::c_int,
                        mday: ::libc::c_int) -> ::libc::c_int;
    pub fn date2isoyear(year: ::libc::c_int, mon: ::libc::c_int,
                        mday: ::libc::c_int) -> ::libc::c_int;
    pub fn date2isoyearday(year: ::libc::c_int, mon: ::libc::c_int,
                           mday: ::libc::c_int) -> ::libc::c_int;
    pub fn ReorderBufferAllocate() -> *mut ReorderBuffer;
    pub fn ReorderBufferFree(arg1: *mut ReorderBuffer) -> ();
    pub fn ReorderBufferGetTupleBuf(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferTupleBuf;
    pub fn ReorderBufferReturnTupleBuf(arg1: *mut ReorderBuffer,
                                       tuple: *mut ReorderBufferTupleBuf)
     -> ();
    pub fn ReorderBufferGetChange(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferChange;
    pub fn ReorderBufferReturnChange(arg1: *mut ReorderBuffer,
                                     arg2: *mut ReorderBufferChange) -> ();
    pub fn ReorderBufferQueueChange(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    arg3: *mut ReorderBufferChange) -> ();
    pub fn ReorderBufferCommit(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               commit_lsn: XLogRecPtr, end_lsn: XLogRecPtr,
                               commit_time: TimestampTz) -> ();
    pub fn ReorderBufferAssignChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferCommitChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr,
                                    end_lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferAbort(arg1: *mut ReorderBuffer, arg2: TransactionId,
                              lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferAbortOld(arg1: *mut ReorderBuffer, xid: TransactionId)
     -> ();
    pub fn ReorderBufferForget(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferSetBaseSnapshot(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        snap: *mut Struct_SnapshotData) -> ();
    pub fn ReorderBufferAddSnapshot(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    snap: *mut Struct_SnapshotData) -> ();
    pub fn ReorderBufferAddNewCommandId(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        cid: CommandId) -> ();
    pub fn ReorderBufferAddNewTupleCids(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        node: RelFileNode,
                                        pt: ItemPointerData, cmin: CommandId,
                                        cmax: CommandId, combocid: CommandId)
     -> ();
    pub fn ReorderBufferAddInvalidations(arg1: *mut ReorderBuffer,
                                         arg2: TransactionId, lsn: XLogRecPtr,
                                         nmsgs: Size,
                                         msgs: *mut SharedInvalidationMessage)
     -> ();
    pub fn ReorderBufferIsXidKnown(arg1: *mut ReorderBuffer,
                                   xid: TransactionId) -> _bool;
    pub fn ReorderBufferXidSetCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId,
                                             lsn: XLogRecPtr) -> ();
    pub fn ReorderBufferXidHasCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId) -> _bool;
    pub fn ReorderBufferXidHasBaseSnapshot(arg1: *mut ReorderBuffer,
                                           xid: TransactionId) -> _bool;
    pub fn ReorderBufferGetOldestTXN(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferTXN;
    pub fn ReorderBufferSetRestartPoint(arg1: *mut ReorderBuffer,
                                        ptr: XLogRecPtr) -> ();
    pub fn StartupReorderBuffer() -> ();
    pub fn OutputPluginPrepareWrite(ctx: *mut Struct_LogicalDecodingContext,
                                    last_write: _bool) -> ();
    pub fn OutputPluginWrite(ctx: *mut Struct_LogicalDecodingContext,
                             last_write: _bool) -> ();
    pub fn makeStringInfo() -> StringInfo;
    pub fn initStringInfo(str: StringInfo) -> ();
    pub fn resetStringInfo(str: StringInfo) -> ();
    pub fn appendStringInfo(str: StringInfo, fmt: *const ::libc::c_char, ...)
     -> ();
    pub fn appendStringInfoString(str: StringInfo, s: *const ::libc::c_char)
     -> ();
    pub fn appendStringInfoChar(str: StringInfo, ch: ::libc::c_char) -> ();
    pub fn appendStringInfoSpaces(str: StringInfo, count: ::libc::c_int)
     -> ();
    pub fn appendBinaryStringInfo(str: StringInfo,
                                  data: *const ::libc::c_char,
                                  datalen: ::libc::c_int) -> ();
    pub fn enlargeStringInfo(str: StringInfo, needed: ::libc::c_int) -> ();
    pub fn XLogInsert(rmid: RmgrId, info: uint8, rdata: *mut XLogRecData)
     -> XLogRecPtr;
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> _bool;
    pub fn XLogFlush(RecPtr: XLogRecPtr) -> ();
    pub fn XLogBackgroundFlush() -> _bool;
    pub fn XLogNeedsFlush(RecPtr: XLogRecPtr) -> _bool;
    pub fn XLogFileInit(segno: XLogSegNo, use_existent: *mut _bool,
                        use_lock: _bool) -> ::libc::c_int;
    pub fn XLogFileOpen(segno: XLogSegNo) -> ::libc::c_int;
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: _bool)
     -> XLogRecPtr;
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID) -> ();
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
    pub fn XLogSetAsyncXactLSN(record: XLogRecPtr) -> ();
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr) -> ();
    pub fn RestoreBackupBlock(lsn: XLogRecPtr, record: *mut XLogRecord,
                              block_index: ::libc::c_int,
                              get_cleanup_lock: _bool, keep_buffer: _bool)
     -> Buffer;
    pub fn xlog_redo(lsn: XLogRecPtr, record: *mut XLogRecord) -> ();
    pub fn xlog_desc(buf: StringInfo, xl_info: uint8,
                     rec: *mut ::libc::c_char) -> ();
    pub fn issue_xlog_fsync(fd: ::libc::c_int, segno: XLogSegNo) -> ();
    pub fn RecoveryInProgress() -> _bool;
    pub fn HotStandbyActive() -> _bool;
    pub fn HotStandbyActiveInReplay() -> _bool;
    pub fn XLogInsertAllowed() -> _bool;
    pub fn GetXLogReceiptTime(rtime: *mut TimestampTz, fromStream: *mut _bool)
     -> ();
    pub fn GetXLogReplayRecPtr(replayTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
    pub fn RecoveryIsPaused() -> _bool;
    pub fn SetRecoveryPause(recoveryPause: _bool) -> ();
    pub fn GetLatestXTime() -> TimestampTz;
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
    pub fn XLogFileNameP(tli: TimeLineID, segno: XLogSegNo)
     -> *mut ::libc::c_char;
    pub fn UpdateControlFile() -> ();
    pub fn GetSystemIdentifier() -> uint64;
    pub fn DataChecksumsEnabled() -> _bool;
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
    pub fn XLOGShmemSize() -> Size;
    pub fn XLOGShmemInit() -> ();
    pub fn BootStrapXLOG() -> ();
    pub fn StartupXLOG() -> ();
    pub fn ShutdownXLOG(code: ::libc::c_int, arg: Datum) -> ();
    pub fn InitXLOGAccess() -> ();
    pub fn CreateCheckPoint(flags: ::libc::c_int) -> ();
    pub fn CreateRestartPoint(flags: ::libc::c_int) -> _bool;
    pub fn XLogPutNextOid(nextOid: Oid) -> ();
    pub fn XLogRestorePoint(rpName: *const ::libc::c_char) -> XLogRecPtr;
    pub fn UpdateFullPageWrites() -> ();
    pub fn GetRedoRecPtr() -> XLogRecPtr;
    pub fn GetInsertRecPtr() -> XLogRecPtr;
    pub fn GetFlushRecPtr() -> XLogRecPtr;
    pub fn GetNextXidAndEpoch(xid: *mut TransactionId, epoch: *mut uint32)
     -> ();
    pub fn RemovePromoteSignalFiles() -> ();
    pub fn CheckPromoteSignal() -> _bool;
    pub fn WakeupRecovery() -> ();
    pub fn SetWalWriterSleeping(sleeping: _bool) -> ();
    pub fn do_pg_start_backup(backupidstr: *const ::libc::c_char, fast: _bool,
                              starttli_p: *mut TimeLineID,
                              labelfile: *mut *mut ::libc::c_char)
     -> XLogRecPtr;
    pub fn do_pg_stop_backup(labelfile: *mut ::libc::c_char,
                             waitforarchive: _bool,
                             stoptli_p: *mut TimeLineID) -> XLogRecPtr;
    pub fn do_pg_abort_backup() -> ();
    pub fn GetLastSegSwitchTime() -> pg_time_t;
    pub fn RequestXLogSwitch() -> XLogRecPtr;
    pub fn GetOldestRestartPoint(oldrecptr: *mut XLogRecPtr,
                                 oldtli: *mut TimeLineID) -> ();
    pub fn RestoreArchivedFile(path: *mut ::libc::c_char,
                               xlogfname: *const ::libc::c_char,
                               recovername: *const ::libc::c_char,
                               expectedSize: off_t, cleanupEnabled: _bool)
     -> _bool;
    pub fn ExecuteRecoveryCommand(command: *mut ::libc::c_char,
                                  commandName: *mut ::libc::c_char,
                                  failOnerror: _bool) -> ();
    pub fn KeepFileRestoredFromArchive(path: *mut ::libc::c_char,
                                       xlogfname: *mut ::libc::c_char) -> ();
    pub fn XLogArchiveNotify(xlog: *const ::libc::c_char) -> ();
    pub fn XLogArchiveNotifySeg(segno: XLogSegNo) -> ();
    pub fn XLogArchiveForceDone(xlog: *const ::libc::c_char) -> ();
    pub fn XLogArchiveCheckDone(xlog: *const ::libc::c_char) -> _bool;
    pub fn XLogArchiveIsBusy(xlog: *const ::libc::c_char) -> _bool;
    pub fn XLogArchiveIsReady(xlog: *const ::libc::c_char) -> _bool;
    pub fn XLogArchiveCleanup(xlog: *const ::libc::c_char) -> ();
    pub fn XLogReaderAllocate(pagereadfunc: XLogPageReadCB,
                              private_data: *mut ::libc::c_void)
     -> *mut XLogReaderState;
    pub fn XLogReaderFree(state: *mut XLogReaderState) -> ();
    pub fn XLogReadRecord(state: *mut XLogReaderState, recptr: XLogRecPtr,
                          errormsg: *mut *mut ::libc::c_char)
     -> *mut Struct_XLogRecord;
    pub fn SpinlockSemas() -> ::libc::c_int;
    pub fn SpinlockSemaSize() -> Size;
    pub fn ReplicationSlotsShmemSize() -> Size;
    pub fn ReplicationSlotsShmemInit() -> ();
    pub fn ReplicationSlotCreate(name: *const ::libc::c_char,
                                 db_specific: _bool,
                                 p: ReplicationSlotPersistency) -> ();
    pub fn ReplicationSlotPersist() -> ();
    pub fn ReplicationSlotDrop(name: *const ::libc::c_char) -> ();
    pub fn ReplicationSlotAcquire(name: *const ::libc::c_char) -> ();
    pub fn ReplicationSlotRelease() -> ();
    pub fn ReplicationSlotSave() -> ();
    pub fn ReplicationSlotMarkDirty() -> ();
    pub fn ReplicationSlotValidateName(name: *const ::libc::c_char,
                                       elevel: ::libc::c_int) -> _bool;
    pub fn ReplicationSlotsComputeRequiredXmin(already_locked: _bool) -> ();
    pub fn ReplicationSlotsComputeRequiredLSN() -> ();
    pub fn ReplicationSlotsComputeLogicalRestartLSN() -> XLogRecPtr;
    pub fn ReplicationSlotsCountDBSlots(dboid: Oid,
                                        nslots: *mut ::libc::c_int,
                                        nactive: *mut ::libc::c_int) -> _bool;
    pub fn StartupReplicationSlots() -> ();
    pub fn CheckPointReplicationSlots() -> ();
    pub fn CheckSlotRequirements() -> ();
    pub fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
    pub fn CheckLogicalDecodingRequirements() -> ();
    pub fn CreateInitDecodingContext(plugin: *mut ::libc::c_char,
                                     output_plugin_options: *mut List,
                                     read_page: XLogPageReadCB,
                                     prepare_write:
                                         LogicalOutputPluginWriterPrepareWrite,
                                     do_write: LogicalOutputPluginWriterWrite)
     -> *mut LogicalDecodingContext;
    pub fn CreateDecodingContext(start_lsn: XLogRecPtr,
                                 output_plugin_options: *mut List,
                                 read_page: XLogPageReadCB,
                                 prepare_write:
                                     LogicalOutputPluginWriterPrepareWrite,
                                 do_write: LogicalOutputPluginWriterWrite)
     -> *mut LogicalDecodingContext;
    pub fn DecodingContextFindStartpoint(ctx: *mut LogicalDecodingContext)
     -> ();
    pub fn DecodingContextReady(ctx: *mut LogicalDecodingContext) -> _bool;
    pub fn FreeDecodingContext(ctx: *mut LogicalDecodingContext) -> ();
    pub fn LogicalIncreaseXminForSlot(lsn: XLogRecPtr, xmin: TransactionId)
     -> ();
    pub fn LogicalIncreaseRestartDecodingForSlot(current_lsn: XLogRecPtr,
                                                 restart_lsn: XLogRecPtr)
     -> ();
    pub fn LogicalConfirmReceivedLocation(lsn: XLogRecPtr) -> ();
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo:
                                                            FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_alltrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_anytrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn parse_bool(value: *const ::libc::c_char, result: *mut _bool)
     -> _bool;
    pub fn parse_bool_with_len(value: *const ::libc::c_char, len: size_t,
                               result: *mut _bool) -> _bool;
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_check(value: Datum, isnull: _bool, domainType: Oid,
                        extra: *mut *mut ::libc::c_void, mcxt: MemoryContext)
     -> ();
    pub fn errdatatype(datatypeOid: Oid) -> ::libc::c_int;
    pub fn errdomainconstraint(datatypeOid: Oid,
                               conname: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hex_encode(src: *const ::libc::c_char, len: ::libc::c_uint,
                      dst: *mut ::libc::c_char) -> ::libc::c_uint;
    pub fn hex_decode(src: *const ::libc::c_char, len: ::libc::c_uint,
                      dst: *mut ::libc::c_char) -> ::libc::c_uint;
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn buildint2vector(int2s: *const int16, n: ::libc::c_int)
     -> *mut int2vector;
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namecpy(n1: Name, n2: Name) -> ::libc::c_int;
    pub fn namestrcpy(name: Name, str: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn namestrcmp(name: Name, str: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_atoi(s: *mut ::libc::c_char, size: ::libc::c_int,
                   c: ::libc::c_int) -> int32;
    pub fn pg_itoa(i: int16, a: *mut ::libc::c_char) -> ();
    pub fn pg_ltoa(l: int32, a: *mut ::libc::c_char) -> ();
    pub fn pg_lltoa(ll: int64, a: *mut ::libc::c_char) -> ();
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btabstimecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btreltimecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttintervalcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn get_float8_infinity() -> ::libc::c_double;
    pub fn get_float4_infinity() -> ::libc::c_float;
    pub fn get_float8_nan() -> ::libc::c_double;
    pub fn get_float4_nan() -> ::libc::c_float;
    pub fn is_infinite(val: ::libc::c_double) -> ::libc::c_int;
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_filenode_relation(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn read_binary_file(filename: *const ::libc::c_char,
                            seek_offset: int64, bytes_to_read: int64)
     -> *mut bytea;
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn buildoidvector(oids: *const Oid, n: ::libc::c_int)
     -> *mut oidvector;
    pub fn oidparse(node: *mut Node) -> Oid;
    pub fn ordered_set_transition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn mode_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn opaque_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn opaque_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_fixed_prefix(text_re: *mut text, case_insensitive: _bool,
                               collation: Oid, exact: *mut _bool)
     -> *mut ::libc::c_char;
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regproc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regprocedure(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoperator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regtype(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn stringToQualifiedNameList(string: *const ::libc::c_char)
     -> *mut List;
    pub fn format_procedure(procedure_oid: Oid) -> *mut ::libc::c_char;
    pub fn format_procedure_qualified(procedure_oid: Oid)
     -> *mut ::libc::c_char;
    pub fn format_operator(operator_oid: Oid) -> *mut ::libc::c_char;
    pub fn format_operator_qualified(operator_oid: Oid)
     -> *mut ::libc::c_char;
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordimagecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_string(indexrelid: Oid) -> *mut ::libc::c_char;
    pub fn pg_get_indexdef_columns(indexrelid: Oid, pretty: _bool)
     -> *mut ::libc::c_char;
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_string(constraintId: Oid)
     -> *mut ::libc::c_char;
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn deparse_expression(expr: *mut Node, dpcontext: *mut List,
                              forceprefix: _bool, showimplicit: _bool)
     -> *mut ::libc::c_char;
    pub fn deparse_context_for(aliasname: *const ::libc::c_char, relid: Oid)
     -> *mut List;
    pub fn deparse_context_for_plan_rtable(rtable: *mut List,
                                           rtable_names: *mut List)
     -> *mut List;
    pub fn set_deparse_context_planstate(dpcontext: *mut List,
                                         planstate: *mut Node,
                                         ancestors: *mut List) -> *mut List;
    pub fn select_rtable_names_for_explain(rtable: *mut List,
                                           rels_used: *mut Bitmapset)
     -> *mut List;
    pub fn quote_identifier(ident: *const ::libc::c_char)
     -> *const ::libc::c_char;
    pub fn quote_qualified_identifier(qualifier: *const ::libc::c_char,
                                      ident: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn generate_collation_name(collid: Oid) -> *mut ::libc::c_char;
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byreloid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_to_text(s: *const ::libc::c_char) -> *mut text;
    pub fn cstring_to_text_with_len(s: *const ::libc::c_char,
                                    len: ::libc::c_int) -> *mut text;
    pub fn text_to_cstring(t: *const text) -> *mut ::libc::c_char;
    pub fn text_to_cstring_buffer(src: *const text, dst: *mut ::libc::c_char,
                                  dst_len: size_t) -> ();
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varstr_cmp(arg1: *mut ::libc::c_char, len1: ::libc::c_int,
                      arg2: *mut ::libc::c_char, len2: ::libc::c_int,
                      collid: Oid) -> ::libc::c_int;
    pub fn textToQualifiedNameList(textval: *mut text) -> *mut List;
    pub fn SplitIdentifierString(rawstring: *mut ::libc::c_char,
                                 separator: ::libc::c_char,
                                 namelist: *mut *mut List) -> _bool;
    pub fn SplitDirectoriesString(rawstring: *mut ::libc::c_char,
                                  separator: ::libc::c_char,
                                  namelist: *mut *mut List) -> _bool;
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn replace_text_regexp(src_text: *mut text,
                               regexp: *mut ::libc::c_void,
                               replace_text: *mut text, glob: _bool)
     -> *mut text;
    pub fn split_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidComparator(arg1: *const ::libc::c_void,
                         arg2: *const ::libc::c_void) -> ::libc::c_int;
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_cidr_ntop(af: ::libc::c_int, src: *const ::libc::c_void,
                          bits: ::libc::c_int, dst: *mut ::libc::c_char,
                          size: size_t) -> *mut ::libc::c_char;
    pub fn inet_net_pton(af: ::libc::c_int, src: *const ::libc::c_char,
                         dst: *mut ::libc::c_void, size: size_t)
     -> ::libc::c_int;
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn convert_network_to_scalar(value: Datum, typid: Oid)
     -> ::libc::c_double;
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_scan_first(_in: Datum) -> Datum;
    pub fn network_scan_last(_in: Datum) -> Datum;
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clean_ipv6_addr(addr_family: ::libc::c_int,
                           addr: *mut ::libc::c_char) -> ();
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_character_set(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_character_set_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_character_set_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type_be(type_oid: Oid) -> *mut ::libc::c_char;
    pub fn format_type_be_qualified(type_oid: Oid) -> *mut ::libc::c_char;
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32)
     -> *mut ::libc::c_char;
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal_cstr(rawstr: *const ::libc::c_char)
     -> *mut ::libc::c_char;
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_current(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarraytriconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> _bool;
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid)
     -> ::libc::c_int;
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
    pub fn get_op_opfamily_properties(opno: Oid, opfamily: Oid,
                                      ordering_op: _bool,
                                      strategy: *mut ::libc::c_int,
                                      lefttype: *mut Oid, righttype: *mut Oid)
     -> ();
    pub fn get_opfamily_member(opfamily: Oid, lefttype: Oid, righttype: Oid,
                               strategy: int16) -> Oid;
    pub fn get_ordering_op_properties(opno: Oid, opfamily: *mut Oid,
                                      opcintype: *mut Oid,
                                      strategy: *mut int16) -> _bool;
    pub fn get_sort_function_for_ordering_op(opno: Oid, sortfunc: *mut Oid,
                                             issupport: *mut _bool,
                                             reverse: *mut _bool) -> _bool;
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: *mut _bool)
     -> Oid;
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: _bool)
     -> Oid;
    pub fn get_mergejoin_opfamilies(opno: Oid) -> *mut List;
    pub fn get_compatible_hash_operators(opno: Oid, lhs_opno: *mut Oid,
                                         rhs_opno: *mut Oid) -> _bool;
    pub fn get_op_hash_functions(opno: Oid, lhs_procno: *mut RegProcedure,
                                 rhs_procno: *mut RegProcedure) -> _bool;
    pub fn get_op_btree_interpretation(opno: Oid) -> *mut List;
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> _bool;
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid,
                             procnum: int16) -> Oid;
    pub fn get_attname(relid: Oid, attnum: AttrNumber) -> *mut ::libc::c_char;
    pub fn get_relid_attribute_name(relid: Oid, attnum: AttrNumber)
     -> *mut ::libc::c_char;
    pub fn get_attnum(relid: Oid, attname: *const ::libc::c_char)
     -> AttrNumber;
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
    pub fn get_atttypmod(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_atttypetypmodcoll(relid: Oid, attnum: AttrNumber,
                                 typid: *mut Oid, typmod: *mut int32,
                                 collid: *mut Oid) -> ();
    pub fn get_collation_name(colloid: Oid) -> *mut ::libc::c_char;
    pub fn get_constraint_name(conoid: Oid) -> *mut ::libc::c_char;
    pub fn get_opclass_family(opclass: Oid) -> Oid;
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
    pub fn get_opcode(opno: Oid) -> RegProcedure;
    pub fn get_opname(opno: Oid) -> *mut ::libc::c_char;
    pub fn op_input_types(opno: Oid, lefttype: *mut Oid, righttype: *mut Oid)
     -> ();
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> _bool;
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> _bool;
    pub fn op_strict(opno: Oid) -> _bool;
    pub fn op_volatile(opno: Oid) -> ::libc::c_char;
    pub fn get_commutator(opno: Oid) -> Oid;
    pub fn get_negator(opno: Oid) -> Oid;
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
    pub fn get_func_name(funcid: Oid) -> *mut ::libc::c_char;
    pub fn get_func_namespace(funcid: Oid) -> Oid;
    pub fn get_func_rettype(funcid: Oid) -> Oid;
    pub fn get_func_nargs(funcid: Oid) -> ::libc::c_int;
    pub fn get_func_signature(funcid: Oid, argtypes: *mut *mut Oid,
                              nargs: *mut ::libc::c_int) -> Oid;
    pub fn get_func_variadictype(funcid: Oid) -> Oid;
    pub fn get_func_retset(funcid: Oid) -> _bool;
    pub fn func_strict(funcid: Oid) -> _bool;
    pub fn func_volatile(funcid: Oid) -> ::libc::c_char;
    pub fn get_func_leakproof(funcid: Oid) -> _bool;
    pub fn get_func_cost(funcid: Oid) -> float4;
    pub fn get_func_rows(funcid: Oid) -> float4;
    pub fn get_relname_relid(relname: *const ::libc::c_char,
                             relnamespace: Oid) -> Oid;
    pub fn get_rel_name(relid: Oid) -> *mut ::libc::c_char;
    pub fn get_rel_namespace(relid: Oid) -> Oid;
    pub fn get_rel_type_id(relid: Oid) -> Oid;
    pub fn get_rel_relkind(relid: Oid) -> ::libc::c_char;
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
    pub fn get_typisdefined(typid: Oid) -> _bool;
    pub fn get_typlen(typid: Oid) -> int16;
    pub fn get_typbyval(typid: Oid) -> _bool;
    pub fn get_typlenbyval(typid: Oid, typlen: *mut int16,
                           typbyval: *mut _bool) -> ();
    pub fn get_typlenbyvalalign(typid: Oid, typlen: *mut int16,
                                typbyval: *mut _bool,
                                typalign: *mut ::libc::c_char) -> ();
    pub fn getTypeIOParam(typeTuple: HeapTuple) -> Oid;
    pub fn get_type_io_data(typid: Oid, which_func: IOFuncSelector,
                            typlen: *mut int16, typbyval: *mut _bool,
                            typalign: *mut ::libc::c_char,
                            typdelim: *mut ::libc::c_char,
                            typioparam: *mut Oid, func: *mut Oid) -> ();
    pub fn get_typstorage(typid: Oid) -> ::libc::c_char;
    pub fn get_typdefault(typid: Oid) -> *mut Node;
    pub fn get_typtype(typid: Oid) -> ::libc::c_char;
    pub fn type_is_rowtype(typid: Oid) -> _bool;
    pub fn type_is_enum(typid: Oid) -> _bool;
    pub fn type_is_range(typid: Oid) -> _bool;
    pub fn get_type_category_preferred(typid: Oid,
                                       typcategory: *mut ::libc::c_char,
                                       typispreferred: *mut _bool) -> ();
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
    pub fn get_element_type(typid: Oid) -> Oid;
    pub fn get_array_type(typid: Oid) -> Oid;
    pub fn get_base_element_type(typid: Oid) -> Oid;
    pub fn getTypeInputInfo(_type: Oid, typInput: *mut Oid,
                            typIOParam: *mut Oid) -> ();
    pub fn getTypeOutputInfo(_type: Oid, typOutput: *mut Oid,
                             typIsVarlena: *mut _bool) -> ();
    pub fn getTypeBinaryInputInfo(_type: Oid, typReceive: *mut Oid,
                                  typIOParam: *mut Oid) -> ();
    pub fn getTypeBinaryOutputInfo(_type: Oid, typSend: *mut Oid,
                                   typIsVarlena: *mut _bool) -> ();
    pub fn get_typmodin(typid: Oid) -> Oid;
    pub fn get_typcollation(typid: Oid) -> Oid;
    pub fn type_is_collatable(typid: Oid) -> _bool;
    pub fn getBaseType(typid: Oid) -> Oid;
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: *mut int32) -> Oid;
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_attstatsslot(statstuple: HeapTuple, atttype: Oid,
                            atttypmod: int32, reqkind: ::libc::c_int,
                            reqop: Oid, actualop: *mut Oid,
                            values: *mut *mut Datum,
                            nvalues: *mut ::libc::c_int,
                            numbers: *mut *mut float4,
                            nnumbers: *mut ::libc::c_int) -> _bool;
    pub fn free_attstatsslot(atttype: Oid, values: *mut Datum,
                             nvalues: ::libc::c_int, numbers: *mut float4,
                             nnumbers: ::libc::c_int) -> ();
    pub fn get_namespace_name(nspid: Oid) -> *mut ::libc::c_char;
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
    pub fn MemoryContextInit() -> ();
    pub fn MemoryContextReset(context: MemoryContext) -> ();
    pub fn MemoryContextDelete(context: MemoryContext) -> ();
    pub fn MemoryContextResetChildren(context: MemoryContext) -> ();
    pub fn MemoryContextDeleteChildren(context: MemoryContext) -> ();
    pub fn MemoryContextResetAndDeleteChildren(context: MemoryContext) -> ();
    pub fn MemoryContextSetParent(context: MemoryContext,
                                  new_parent: MemoryContext) -> ();
    pub fn GetMemoryChunkSpace(pointer: *mut ::libc::c_void) -> Size;
    pub fn GetMemoryChunkContext(pointer: *mut ::libc::c_void)
     -> MemoryContext;
    pub fn MemoryContextGetParent(context: MemoryContext) -> MemoryContext;
    pub fn MemoryContextIsEmpty(context: MemoryContext) -> _bool;
    pub fn MemoryContextStats(context: MemoryContext) -> ();
    pub fn MemoryContextContains(context: MemoryContext,
                                 pointer: *mut ::libc::c_void) -> _bool;
    pub fn MemoryContextCreate(tag: NodeTag, size: Size,
                               methods: *mut MemoryContextMethods,
                               parent: MemoryContext,
                               name: *const ::libc::c_char) -> MemoryContext;
    pub fn AllocSetContextCreate(parent: MemoryContext,
                                 name: *const ::libc::c_char,
                                 minContextSize: Size, initBlockSize: Size,
                                 maxBlockSize: Size) -> MemoryContext;
    pub fn InitCatalogCache() -> ();
    pub fn InitCatalogCachePhase2() -> ();
    pub fn SearchSysCache(cacheId: ::libc::c_int, key1: Datum, key2: Datum,
                          key3: Datum, key4: Datum) -> HeapTuple;
    pub fn ReleaseSysCache(tuple: HeapTuple) -> ();
    pub fn SearchSysCacheCopy(cacheId: ::libc::c_int, key1: Datum,
                              key2: Datum, key3: Datum, key4: Datum)
     -> HeapTuple;
    pub fn SearchSysCacheExists(cacheId: ::libc::c_int, key1: Datum,
                                key2: Datum, key3: Datum, key4: Datum)
     -> _bool;
    pub fn GetSysCacheOid(cacheId: ::libc::c_int, key1: Datum, key2: Datum,
                          key3: Datum, key4: Datum) -> Oid;
    pub fn SearchSysCacheAttName(relid: Oid, attname: *const ::libc::c_char)
     -> HeapTuple;
    pub fn SearchSysCacheCopyAttName(relid: Oid,
                                     attname: *const ::libc::c_char)
     -> HeapTuple;
    pub fn SearchSysCacheExistsAttName(relid: Oid,
                                       attname: *const ::libc::c_char)
     -> _bool;
    pub fn SysCacheGetAttr(cacheId: ::libc::c_int, tup: HeapTuple,
                           attributeNumber: AttrNumber, isNull: *mut _bool)
     -> Datum;
    pub fn GetSysCacheHashValue(cacheId: ::libc::c_int, key1: Datum,
                                key2: Datum, key3: Datum, key4: Datum)
     -> uint32;
    pub fn SearchSysCacheList(cacheId: ::libc::c_int, nkeys: ::libc::c_int,
                              key1: Datum, key2: Datum, key3: Datum,
                              key4: Datum) -> *mut Struct_catclist;
    pub fn RelationInvalidatesSnapshotsOnly(relid: Oid) -> _bool;
    pub fn RelationHasSysCache(relid: Oid) -> _bool;
    pub fn RelationSupportsSysCache(relid: Oid) -> _bool;
    pub fn lookup_type_cache(type_id: Oid, flags: ::libc::c_int)
     -> *mut TypeCacheEntry;
    pub fn lookup_rowtype_tupdesc(type_id: Oid, typmod: int32) -> TupleDesc;
    pub fn lookup_rowtype_tupdesc_noerror(type_id: Oid, typmod: int32,
                                          noError: _bool) -> TupleDesc;
    pub fn lookup_rowtype_tupdesc_copy(type_id: Oid, typmod: int32)
     -> TupleDesc;
    pub fn assign_record_type_typmod(tupDesc: TupleDesc) -> ();
    pub fn compare_values_of_enum(tcache: *mut TypeCacheEntry, arg1: Oid,
                                  arg2: Oid) -> ::libc::c_int;
    pub fn Pg_magic_func() -> *const Pg_magic_struct;
    pub fn _PG_init() -> ();
    pub fn _PG_output_plugin_init(cb: *mut OutputPluginCallbacks) -> ();
}
