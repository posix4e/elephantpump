/* automatically generated by rust-bindgen */

pub type va_list = __darwin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed1 {
    pub _bindgen_data_: [u64; 16usize],
}
impl Union_Unnamed1 {
    pub unsafe fn __mbstate8(&mut self)
     -> *mut [::std::os::raw::c_char; 128usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _mbstateL(&mut self) -> *mut ::std::os::raw::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __mbstate_t = Union_Unnamed1;
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut Struct___darwin_pthread_handler_rec,
}
impl ::std::clone::Clone for Struct___darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_pthread_handler_rec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_cond_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_condattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_mutex_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_mutexattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_once_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_rwlock_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_rwlockattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct__opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut Struct___darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
impl ::std::clone::Clone for Struct__opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__opaque_pthread_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_pthread_attr_t = Struct__opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = Struct__opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = Struct__opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = Struct__opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = Struct__opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = Struct__opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = Struct__opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = Struct__opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut Struct__opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type size_t = __darwin_size_t;
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___sbuf {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sbuf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct___sFILEX { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: Struct___sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: Struct___sbuf,
    pub _extra: *mut Struct___sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: Struct___sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
impl ::std::clone::Clone for Struct___sFILE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sFILE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FILE = Struct___sFILE;
pub type off_t = __darwin_off_t;
pub type ssize_t = __darwin_ssize_t;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed2 { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub type idtype_t = Enum_Unnamed2;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct___darwin_i386_thread_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_thread_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_fp_control {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_ushort,
}
impl ::std::clone::Clone for Struct___darwin_fp_control {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_fp_control {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_fp_control_t = Struct___darwin_fp_control;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_fp_status {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_ushort,
}
impl ::std::clone::Clone for Struct___darwin_fp_status {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_fp_status {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_fp_status_t = Struct___darwin_fp_status;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
impl ::std::clone::Clone for Struct___darwin_mmst_reg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mmst_reg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
impl ::std::clone::Clone for Struct___darwin_xmm_reg {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_xmm_reg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___darwin_i386_float_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_float_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: Struct___darwin_xmm_reg,
    pub __fpu_ymmh1: Struct___darwin_xmm_reg,
    pub __fpu_ymmh2: Struct___darwin_xmm_reg,
    pub __fpu_ymmh3: Struct___darwin_xmm_reg,
    pub __fpu_ymmh4: Struct___darwin_xmm_reg,
    pub __fpu_ymmh5: Struct___darwin_xmm_reg,
    pub __fpu_ymmh6: Struct___darwin_xmm_reg,
    pub __fpu_ymmh7: Struct___darwin_xmm_reg,
}
impl ::std::clone::Clone for Struct___darwin_i386_avx_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_avx_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
impl ::std::clone::Clone for Struct___darwin_i386_exception_state {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_i386_exception_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct___darwin_x86_debug_state32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_debug_state32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_thread_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_thread_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_xmm8: Struct___darwin_xmm_reg,
    pub __fpu_xmm9: Struct___darwin_xmm_reg,
    pub __fpu_xmm10: Struct___darwin_xmm_reg,
    pub __fpu_xmm11: Struct___darwin_xmm_reg,
    pub __fpu_xmm12: Struct___darwin_xmm_reg,
    pub __fpu_xmm13: Struct___darwin_xmm_reg,
    pub __fpu_xmm14: Struct___darwin_xmm_reg,
    pub __fpu_xmm15: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___darwin_x86_float_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_float_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: Struct___darwin_fp_control,
    pub __fpu_fsw: Struct___darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: Struct___darwin_mmst_reg,
    pub __fpu_stmm1: Struct___darwin_mmst_reg,
    pub __fpu_stmm2: Struct___darwin_mmst_reg,
    pub __fpu_stmm3: Struct___darwin_mmst_reg,
    pub __fpu_stmm4: Struct___darwin_mmst_reg,
    pub __fpu_stmm5: Struct___darwin_mmst_reg,
    pub __fpu_stmm6: Struct___darwin_mmst_reg,
    pub __fpu_stmm7: Struct___darwin_mmst_reg,
    pub __fpu_xmm0: Struct___darwin_xmm_reg,
    pub __fpu_xmm1: Struct___darwin_xmm_reg,
    pub __fpu_xmm2: Struct___darwin_xmm_reg,
    pub __fpu_xmm3: Struct___darwin_xmm_reg,
    pub __fpu_xmm4: Struct___darwin_xmm_reg,
    pub __fpu_xmm5: Struct___darwin_xmm_reg,
    pub __fpu_xmm6: Struct___darwin_xmm_reg,
    pub __fpu_xmm7: Struct___darwin_xmm_reg,
    pub __fpu_xmm8: Struct___darwin_xmm_reg,
    pub __fpu_xmm9: Struct___darwin_xmm_reg,
    pub __fpu_xmm10: Struct___darwin_xmm_reg,
    pub __fpu_xmm11: Struct___darwin_xmm_reg,
    pub __fpu_xmm12: Struct___darwin_xmm_reg,
    pub __fpu_xmm13: Struct___darwin_xmm_reg,
    pub __fpu_xmm14: Struct___darwin_xmm_reg,
    pub __fpu_xmm15: Struct___darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: Struct___darwin_xmm_reg,
    pub __fpu_ymmh1: Struct___darwin_xmm_reg,
    pub __fpu_ymmh2: Struct___darwin_xmm_reg,
    pub __fpu_ymmh3: Struct___darwin_xmm_reg,
    pub __fpu_ymmh4: Struct___darwin_xmm_reg,
    pub __fpu_ymmh5: Struct___darwin_xmm_reg,
    pub __fpu_ymmh6: Struct___darwin_xmm_reg,
    pub __fpu_ymmh7: Struct___darwin_xmm_reg,
    pub __fpu_ymmh8: Struct___darwin_xmm_reg,
    pub __fpu_ymmh9: Struct___darwin_xmm_reg,
    pub __fpu_ymmh10: Struct___darwin_xmm_reg,
    pub __fpu_ymmh11: Struct___darwin_xmm_reg,
    pub __fpu_ymmh12: Struct___darwin_xmm_reg,
    pub __fpu_ymmh13: Struct___darwin_xmm_reg,
    pub __fpu_ymmh14: Struct___darwin_xmm_reg,
    pub __fpu_ymmh15: Struct___darwin_xmm_reg,
}
impl ::std::clone::Clone for Struct___darwin_x86_avx_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_avx_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_exception_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_exception_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
impl ::std::clone::Clone for Struct___darwin_x86_debug_state64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_x86_debug_state64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext32 {
    pub __es: Struct___darwin_i386_exception_state,
    pub __ss: Struct___darwin_i386_thread_state,
    pub __fs: Struct___darwin_i386_float_state,
}
impl ::std::clone::Clone for Struct___darwin_mcontext32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext_avx32 {
    pub __es: Struct___darwin_i386_exception_state,
    pub __ss: Struct___darwin_i386_thread_state,
    pub __fs: Struct___darwin_i386_avx_state,
}
impl ::std::clone::Clone for Struct___darwin_mcontext_avx32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext_avx32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext64 {
    pub __es: Struct___darwin_x86_exception_state64,
    pub __ss: Struct___darwin_x86_thread_state64,
    pub __fs: Struct___darwin_x86_float_state64,
}
impl ::std::clone::Clone for Struct___darwin_mcontext64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_mcontext_avx64 {
    pub __es: Struct___darwin_x86_exception_state64,
    pub __ss: Struct___darwin_x86_thread_state64,
    pub __fs: Struct___darwin_x86_avx_state64,
}
impl ::std::clone::Clone for Struct___darwin_mcontext_avx64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_mcontext_avx64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mcontext_t = *mut Struct___darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___darwin_sigaltstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_sigaltstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type stack_t = Struct___darwin_sigaltstack;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: Struct___darwin_sigaltstack,
    pub uc_link: *mut Struct___darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut Struct___darwin_mcontext64,
}
impl ::std::clone::Clone for Struct___darwin_ucontext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___darwin_ucontext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ucontext_t = Struct___darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy)]
pub struct Union_sigval {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_sigval {
    pub unsafe fn sival_int(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sival_ptr(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_sigval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_sigval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: Union_sigval,
    pub sigev_notify_function: ::std::option::Option<extern "C" fn(arg1:
                                                                       Union_sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
impl ::std::clone::Clone for Struct_sigevent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigevent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: Union_sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
impl ::std::clone::Clone for Struct___siginfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___siginfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type siginfo_t = Struct___siginfo;
#[repr(C)]
#[derive(Copy)]
pub struct Union___sigaction_u {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union___sigaction_u {
    pub unsafe fn __sa_handler(&mut self)
     ->
         *mut ::std::option::Option<extern "C" fn(arg1:
                                                      ::std::os::raw::c_int)> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __sa_sigaction(&mut self)
     ->
         *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                             ::std::os::raw::c_int,
                                                         arg2:
                                                             *mut Struct___siginfo,
                                                         arg3:
                                                             *mut ::std::os::raw::c_void)> {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union___sigaction_u {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union___sigaction_u {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___sigaction {
    pub __sigaction_u: Union___sigaction_u,
    pub sa_tramp: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg2:
                                                                 ::std::os::raw::c_int,
                                                             arg3:
                                                                 ::std::os::raw::c_int,
                                                             arg4:
                                                                 *mut siginfo_t,
                                                             arg5:
                                                                 *mut ::std::os::raw::c_void)>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct___sigaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___sigaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigaction {
    pub __sigaction_u: Union___sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sigaction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigaction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sig_t =
    ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigvec {
    pub sv_handler: ::std::option::Option<extern "C" fn(arg1:
                                                            ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sigvec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigvec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sigstack {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sigstack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type int8_t = ::std::os::raw::c_char;
pub type int16_t = ::std::os::raw::c_short;
pub type int32_t = ::std::os::raw::c_int;
pub type int64_t = ::std::os::raw::c_longlong;
pub type uint8_t = ::std::os::raw::c_uchar;
pub type uint16_t = ::std::os::raw::c_ushort;
pub type uint32_t = ::std::os::raw::c_uint;
pub type uint64_t = ::std::os::raw::c_ulonglong;
pub type int_least8_t = int8_t;
pub type int_least16_t = int16_t;
pub type int_least32_t = int32_t;
pub type int_least64_t = int64_t;
pub type uint_least8_t = uint8_t;
pub type uint_least16_t = uint16_t;
pub type uint_least32_t = uint32_t;
pub type uint_least64_t = uint64_t;
pub type int_fast8_t = int8_t;
pub type int_fast16_t = int16_t;
pub type int_fast32_t = int32_t;
pub type int_fast64_t = int64_t;
pub type uint_fast8_t = uint8_t;
pub type uint_fast16_t = uint16_t;
pub type uint_fast32_t = uint32_t;
pub type uint_fast64_t = uint64_t;
pub type intptr_t = __darwin_intptr_t;
pub type uintptr_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
impl ::std::clone::Clone for Struct_timeval {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timeval {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage {
    pub ru_utime: Struct_timeval,
    pub ru_stime: Struct_timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
impl ::std::clone::Clone for Struct_rusage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v0 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v0 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v0 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v1 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v2 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
    pub ri_diskio_bytesread: uint64_t,
    pub ri_diskio_byteswritten: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rusage_info_v3 {
    pub ri_uuid: [uint8_t; 16usize],
    pub ri_user_time: uint64_t,
    pub ri_system_time: uint64_t,
    pub ri_pkg_idle_wkups: uint64_t,
    pub ri_interrupt_wkups: uint64_t,
    pub ri_pageins: uint64_t,
    pub ri_wired_size: uint64_t,
    pub ri_resident_size: uint64_t,
    pub ri_phys_footprint: uint64_t,
    pub ri_proc_start_abstime: uint64_t,
    pub ri_proc_exit_abstime: uint64_t,
    pub ri_child_user_time: uint64_t,
    pub ri_child_system_time: uint64_t,
    pub ri_child_pkg_idle_wkups: uint64_t,
    pub ri_child_interrupt_wkups: uint64_t,
    pub ri_child_pageins: uint64_t,
    pub ri_child_elapsed_abstime: uint64_t,
    pub ri_diskio_bytesread: uint64_t,
    pub ri_diskio_byteswritten: uint64_t,
    pub ri_cpu_time_qos_default: uint64_t,
    pub ri_cpu_time_qos_maintenance: uint64_t,
    pub ri_cpu_time_qos_background: uint64_t,
    pub ri_cpu_time_qos_utility: uint64_t,
    pub ri_cpu_time_qos_legacy: uint64_t,
    pub ri_cpu_time_qos_user_initiated: uint64_t,
    pub ri_cpu_time_qos_user_interactive: uint64_t,
    pub ri_billed_system_time: uint64_t,
    pub ri_serviced_system_time: uint64_t,
}
impl ::std::clone::Clone for Struct_rusage_info_v3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rusage_info_v3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rusage_info_current = Struct_rusage_info_v3;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
impl ::std::clone::Clone for Struct_rlimit {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rlimit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_proc_rlimit_control_wakeupmon {
    pub wm_flags: uint32_t,
    pub wm_rate: int32_t,
}
impl ::std::clone::Clone for Struct_proc_rlimit_control_wakeupmon {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_proc_rlimit_control_wakeupmon {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_wait {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_wait {
    pub unsafe fn w_status(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w_T(&mut self) -> *mut Struct_Unnamed3 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w_S(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_wait {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_wait {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed5 {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type div_t = Struct_Unnamed5;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
impl ::std::clone::Clone for Struct_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ldiv_t = Struct_Unnamed6;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
impl ::std::clone::Clone for Struct_Unnamed7 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type lldiv_t = Struct_Unnamed7;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = int64_t;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = int64_t;
pub type user_long_t = int64_t;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = int64_t;
pub type user_off_t = int64_t;
pub type syscall_arg_t = u_int64_t;
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
pub type ptrdiff_t = ::std::os::raw::c_long;
pub type max_align_t = ::std::os::raw::c_double;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type _uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = int32_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = int32_t;
pub type swblk_t = int32_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
impl ::std::clone::Clone for Struct_fd_set {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fd_set = Struct_fd_set;
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_lconv {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_lconv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _bool = ::std::os::raw::c_char;
pub type BoolPtr = *mut _bool;
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_char;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type int128 = ::std::os::raw::c_void;
pub type uint128 = ::std::os::raw::c_void;
pub type Size = size_t;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = ::std::os::raw::c_float;
pub type float8 = ::std::os::raw::c_double;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed8 {
    pub indx: [::std::os::raw::c_int; 6usize],
}
impl ::std::clone::Clone for Struct_Unnamed8 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed8 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IntArray = Struct_Unnamed8;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_varlena {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varlena {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type bytea = Struct_varlena;
pub type text = Struct_varlena;
pub type BpChar = Struct_varlena;
pub type VarChar = Struct_varlena;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: *mut int16,
}
impl ::std::clone::Clone for Struct_Unnamed9 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type int2vector = Struct_Unnamed9;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed10 {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: *mut Oid,
}
impl ::std::clone::Clone for Struct_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type oidvector = Struct_Unnamed10;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_nameData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_nameData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NameData = Struct_nameData;
pub type Name = *mut NameData;
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
impl ::std::clone::Clone for Struct_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneEntry = Struct_Unnamed11;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed12 {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
impl ::std::clone::Clone for Struct_Unnamed12 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneRange = Struct_Unnamed12;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
impl ::std::clone::Clone for Struct_Unnamed13 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneCharClass = Struct_Unnamed13;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed14 {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *const ::std::os::raw::c_char,
                                                               arg2:
                                                                   __darwin_size_t,
                                                               arg3:
                                                                   *mut *const ::std::os::raw::c_char)
                                              -> __darwin_rune_t>,
    pub __sputrune: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   __darwin_rune_t,
                                                               arg2:
                                                                   *mut ::std::os::raw::c_char,
                                                               arg3:
                                                                   __darwin_size_t,
                                                               arg4:
                                                                   *mut *mut ::std::os::raw::c_char)
                                              -> ::std::os::raw::c_int>,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
impl ::std::clone::Clone for Struct_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _RuneLocale = Struct_Unnamed14;
pub type socklen_t = __darwin_socklen_t;
pub type sa_family_t = __uint8_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
impl ::std::clone::Clone for Struct_iovec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_iovec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *mut Struct_sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *mut Struct_sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
impl ::std::clone::Clone for Struct_sa_endpoints {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sa_endpoints {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sa_endpoints_t = Struct_sa_endpoints;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_linger {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_linger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
impl ::std::clone::Clone for Struct_so_np_extensions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_so_np_extensions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
impl ::std::clone::Clone for Struct_sockaddr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
impl ::std::clone::Clone for Struct_sockproto {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockproto {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
impl ::std::clone::Clone for Struct_sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut Struct_iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_msghdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_msghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_cmsghdr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sf_hdtr {
    pub headers: *mut Struct_iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut Struct_iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_sf_hdtr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sf_hdtr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in_addr {
    pub s_addr: in_addr_t,
}
impl ::std::clone::Clone for Struct_in_addr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: Struct_in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
impl ::std::clone::Clone for Struct_sockaddr_in {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_in {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_opts {
    pub ip_dst: Struct_in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
impl ::std::clone::Clone for Struct_ip_opts {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_opts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreq {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_ip_mreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreqn {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_address: Struct_in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ip_mreqn {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreqn {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip_mreq_source {
    pub imr_multiaddr: Struct_in_addr,
    pub imr_sourceaddr: Struct_in_addr,
    pub imr_interface: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip_mreq_source {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_req {
    pub gr_interface: uint32_t,
    pub gr_group: Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct_group_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_group_source_req {
    pub gsr_interface: uint32_t,
    pub gsr_group: Struct_sockaddr_storage,
    pub gsr_source: Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct_group_source_req {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_group_source_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___msfilterreq {
    pub msfr_ifindex: uint32_t,
    pub msfr_fmode: uint32_t,
    pub msfr_nsrcs: uint32_t,
    pub __msfr_align: uint32_t,
    pub msfr_group: Struct_sockaddr_storage,
    pub msfr_srcs: *mut Struct_sockaddr_storage,
}
impl ::std::clone::Clone for Struct___msfilterreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___msfilterreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: Struct_in_addr,
    pub ipi_addr: Struct_in_addr,
}
impl ::std::clone::Clone for Struct_in_pktinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in6_addr {
    pub __u6_addr: Union_Unnamed15,
}
impl ::std::clone::Clone for Struct_in6_addr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in6_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed15 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed15 {
    pub unsafe fn __u6_addr8(&mut self) -> *mut [__uint8_t; 16usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr16(&mut self) -> *mut [__uint16_t; 8usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __u6_addr32(&mut self) -> *mut [__uint32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: Struct_in6_addr,
    pub sin6_scope_id: __uint32_t,
}
impl ::std::clone::Clone for Struct_sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_sockaddr_in6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ipv6_mreq {
    pub ipv6mr_multiaddr: Struct_in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ipv6_mreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_in6_pktinfo {
    pub ipi6_addr: Struct_in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_in6_pktinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_in6_pktinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ip6_mtuinfo {
    pub ip6m_addr: Struct_sockaddr_in6,
    pub ip6m_mtu: uint32_t,
}
impl ::std::clone::Clone for Struct_ip6_mtuinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ip6_mtuinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_hostent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_hostent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: uint32_t,
}
impl ::std::clone::Clone for Struct_netent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_netent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_servent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_servent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_protoent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_protoent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut Struct_sockaddr,
    pub ai_next: *mut Struct_addrinfo,
}
impl ::std::clone::Clone for Struct_addrinfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_addrinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_rpcent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rpcent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: uid_t,
    pub pw_gid: gid_t,
    pub pw_change: __darwin_time_t,
    pub pw_class: *mut ::std::os::raw::c_char,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
    pub pw_expire: __darwin_time_t,
}
impl ::std::clone::Clone for Struct_passwd {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_passwd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type uuid_t = __darwin_uuid_t;
pub type uuid_string_t = __darwin_uuid_string_t;
pub type pgsocket = ::std::os::raw::c_int;
pub type qsort_arg_comparator =
    ::std::option::Option<unsafe extern "C" fn(a:
                                                   *const ::std::os::raw::c_void,
                                               b:
                                                   *const ::std::os::raw::c_void,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type pqsigfunc =
    ::std::option::Option<extern "C" fn(signo: ::std::os::raw::c_int)>;
pub type jmp_buf = [::std::os::raw::c_int; 37usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 38usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ErrorContextCallback {
    pub previous: *mut Struct_ErrorContextCallback,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg:
                                                                 *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_ErrorContextCallback {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ErrorContextCallback {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ErrorContextCallback = Struct_ErrorContextCallback;
pub enum Struct_MemoryContextData { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: _bool,
    pub output_to_client: _bool,
    pub show_funcname: _bool,
    pub hide_stmt: _bool,
    pub hide_ctx: _bool,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: *const ::std::os::raw::c_char,
    pub domain: *const ::std::os::raw::c_char,
    pub context_domain: *const ::std::os::raw::c_char,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub detail: *mut ::std::os::raw::c_char,
    pub detail_log: *mut ::std::os::raw::c_char,
    pub hint: *mut ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_char,
    pub schema_name: *mut ::std::os::raw::c_char,
    pub table_name: *mut ::std::os::raw::c_char,
    pub column_name: *mut ::std::os::raw::c_char,
    pub datatype_name: *mut ::std::os::raw::c_char,
    pub constraint_name: *mut ::std::os::raw::c_char,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: *mut ::std::os::raw::c_char,
    pub saved_errno: ::std::os::raw::c_int,
    pub assoc_context: *mut Struct_MemoryContextData,
}
impl ::std::clone::Clone for Struct_ErrorData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ErrorData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ErrorData = Struct_ErrorData;
pub type emit_log_hook_type =
    ::std::option::Option<unsafe extern "C" fn(edata: *mut ErrorData)>;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed16 {
    PGERROR_TERSE = 0,
    PGERROR_DEFAULT = 1,
    PGERROR_VERBOSE = 2,
}
pub type PGErrorVerbosity = Enum_Unnamed16;
pub type MemoryContext = *mut Struct_MemoryContextData;
pub type MemoryContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MemoryContextCallback {
    pub func: MemoryContextCallbackFunction,
    pub arg: *mut ::std::os::raw::c_void,
    pub next: *mut Struct_MemoryContextCallback,
}
impl ::std::clone::Clone for Struct_MemoryContextCallback {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MemoryContextCallback {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MemoryContextCallback = Struct_MemoryContextCallback;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
impl ::std::clone::Clone for Struct_varatt_external {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varatt_external {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_external = Struct_varatt_external;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varatt_indirect {
    pub pointer: *mut Struct_varlena,
}
impl ::std::clone::Clone for Struct_varatt_indirect {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varatt_indirect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_indirect = Struct_varatt_indirect;
pub enum Struct_ExpandedObjectHeader { }
pub type ExpandedObjectHeader = Struct_ExpandedObjectHeader;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_varatt_expanded {
    pub eohptr: *mut ExpandedObjectHeader,
}
impl ::std::clone::Clone for Struct_varatt_expanded {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_varatt_expanded {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varatt_expanded = Struct_varatt_expanded;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_vartag_external {
    VARTAG_INDIRECT = 1,
    VARTAG_EXPANDED_RO = 2,
    VARTAG_EXPANDED_RW = 3,
    VARTAG_ONDISK = 18,
}
pub type vartag_external = Enum_vartag_external;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed17 {
    pub _bindgen_data_: [u32; 2usize],
}
impl Union_Unnamed17 {
    pub unsafe fn va_4byte(&mut self) -> *mut Struct_Unnamed18 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn va_compressed(&mut self) -> *mut Struct_Unnamed19 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed17 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed18 {
    pub va_header: uint32,
    pub va_data: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed18 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed18 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed19 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed19 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_4b = Union_Unnamed17;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed20 {
    pub va_header: uint8,
    pub va_data: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed20 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed20 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_1b = Struct_Unnamed20;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed21 {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Unnamed21 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed21 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type varattrib_1b_e = Struct_Unnamed21;
pub type Datum = uintptr_t;
pub type DatumPtr = *mut Datum;
pub type fmNodePtr = *mut Struct_Node;
pub type fmAggrefPtr = *mut Struct_Aggref;
pub type fmExprContextCallbackFunction =
    ::std::option::Option<extern "C" fn(arg: Datum)>;
pub type fmStringInfo = *mut Struct_StringInfoData;
pub type FunctionCallInfo = *mut Struct_FunctionCallInfoData;
pub type PGFunction =
    ::std::option::Option<extern "C" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: _bool,
    pub fn_retset: _bool,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: *mut ::std::os::raw::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
impl ::std::clone::Clone for Struct_FmgrInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FmgrInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FmgrInfo = Struct_FmgrInfo;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FunctionCallInfoData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: _bool,
    pub nargs: ::std::os::raw::c_short,
    pub arg: [Datum; 100usize],
    pub argnull: [_bool; 100usize],
}
impl ::std::clone::Clone for Struct_FunctionCallInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FunctionCallInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FunctionCallInfoData = Struct_FunctionCallInfoData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed22 {
    pub api_version: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed22 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed22 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Pg_finfo_record = Struct_Unnamed22;
pub type PGFInfoFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed23 {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float4byval: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed23 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed23 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Pg_magic_struct = Struct_Unnamed23;
pub type PGModuleMagicFunction =
    ::std::option::Option<extern "C" fn() -> *const Pg_magic_struct>;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_FmgrHookEventType {
    FHET_START = 0,
    FHET_END = 1,
    FHET_ABORT = 2,
}
pub type FmgrHookEventType = Enum_FmgrHookEventType;
pub type needs_fmgr_hook_type =
    ::std::option::Option<extern "C" fn(fn_oid: Oid) -> _bool>;
pub type fmgr_hook_type =
    ::std::option::Option<unsafe extern "C" fn(event: FmgrHookEventType,
                                               flinfo: *mut FmgrInfo,
                                               arg: *mut Datum)>;
pub type bitmapword = uint32;
pub type signedbitmapword = int32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Bitmapset {
    pub nwords: ::std::os::raw::c_int,
    pub words: *mut bitmapword,
}
impl ::std::clone::Clone for Struct_Bitmapset {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Bitmapset {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Bitmapset = Struct_Bitmapset;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed24 {
    BMS_EQUAL = 0,
    BMS_SUBSET1 = 1,
    BMS_SUBSET2 = 2,
    BMS_DIFFERENT = 3,
}
pub type BMS_Comparison = Enum_Unnamed24;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed25 {
    BMS_EMPTY_SET = 0,
    BMS_SINGLETON = 1,
    BMS_MULTIPLE = 2,
}
pub type BMS_Membership = Enum_Unnamed25;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_LockClauseStrength {
    LCS_NONE = 0,
    LCS_FORKEYSHARE = 1,
    LCS_FORSHARE = 2,
    LCS_FORNOKEYUPDATE = 3,
    LCS_FORUPDATE = 4,
}
pub type LockClauseStrength = Enum_LockClauseStrength;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_LockWaitPolicy {
    LockWaitBlock = 0,
    LockWaitSkip = 1,
    LockWaitError = 2,
}
pub type LockWaitPolicy = Enum_LockWaitPolicy;
pub type AttrNumber = int16;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_NodeTag {
    T_Invalid = 0,
    T_IndexInfo = 10,
    T_ExprContext = 11,
    T_ProjectionInfo = 12,
    T_JunkFilter = 13,
    T_ResultRelInfo = 14,
    T_EState = 15,
    T_TupleTableSlot = 16,
    T_Plan = 100,
    T_Result = 101,
    T_ModifyTable = 102,
    T_Append = 103,
    T_MergeAppend = 104,
    T_RecursiveUnion = 105,
    T_BitmapAnd = 106,
    T_BitmapOr = 107,
    T_Scan = 108,
    T_SeqScan = 109,
    T_SampleScan = 110,
    T_IndexScan = 111,
    T_IndexOnlyScan = 112,
    T_BitmapIndexScan = 113,
    T_BitmapHeapScan = 114,
    T_TidScan = 115,
    T_SubqueryScan = 116,
    T_FunctionScan = 117,
    T_ValuesScan = 118,
    T_CteScan = 119,
    T_WorkTableScan = 120,
    T_ForeignScan = 121,
    T_CustomScan = 122,
    T_Join = 123,
    T_NestLoop = 124,
    T_MergeJoin = 125,
    T_HashJoin = 126,
    T_Material = 127,
    T_Sort = 128,
    T_Group = 129,
    T_Agg = 130,
    T_WindowAgg = 131,
    T_Unique = 132,
    T_Hash = 133,
    T_SetOp = 134,
    T_LockRows = 135,
    T_Limit = 136,
    T_NestLoopParam = 137,
    T_PlanRowMark = 138,
    T_PlanInvalItem = 139,
    T_PlanState = 200,
    T_ResultState = 201,
    T_ModifyTableState = 202,
    T_AppendState = 203,
    T_MergeAppendState = 204,
    T_RecursiveUnionState = 205,
    T_BitmapAndState = 206,
    T_BitmapOrState = 207,
    T_ScanState = 208,
    T_SeqScanState = 209,
    T_SampleScanState = 210,
    T_IndexScanState = 211,
    T_IndexOnlyScanState = 212,
    T_BitmapIndexScanState = 213,
    T_BitmapHeapScanState = 214,
    T_TidScanState = 215,
    T_SubqueryScanState = 216,
    T_FunctionScanState = 217,
    T_ValuesScanState = 218,
    T_CteScanState = 219,
    T_WorkTableScanState = 220,
    T_ForeignScanState = 221,
    T_CustomScanState = 222,
    T_JoinState = 223,
    T_NestLoopState = 224,
    T_MergeJoinState = 225,
    T_HashJoinState = 226,
    T_MaterialState = 227,
    T_SortState = 228,
    T_GroupState = 229,
    T_AggState = 230,
    T_WindowAggState = 231,
    T_UniqueState = 232,
    T_HashState = 233,
    T_SetOpState = 234,
    T_LockRowsState = 235,
    T_LimitState = 236,
    T_Alias = 300,
    T_RangeVar = 301,
    T_Expr = 302,
    T_Var = 303,
    T_Const = 304,
    T_Param = 305,
    T_Aggref = 306,
    T_GroupingFunc = 307,
    T_WindowFunc = 308,
    T_ArrayRef = 309,
    T_FuncExpr = 310,
    T_NamedArgExpr = 311,
    T_OpExpr = 312,
    T_DistinctExpr = 313,
    T_NullIfExpr = 314,
    T_ScalarArrayOpExpr = 315,
    T_BoolExpr = 316,
    T_SubLink = 317,
    T_SubPlan = 318,
    T_AlternativeSubPlan = 319,
    T_FieldSelect = 320,
    T_FieldStore = 321,
    T_RelabelType = 322,
    T_CoerceViaIO = 323,
    T_ArrayCoerceExpr = 324,
    T_ConvertRowtypeExpr = 325,
    T_CollateExpr = 326,
    T_CaseExpr = 327,
    T_CaseWhen = 328,
    T_CaseTestExpr = 329,
    T_ArrayExpr = 330,
    T_RowExpr = 331,
    T_RowCompareExpr = 332,
    T_CoalesceExpr = 333,
    T_MinMaxExpr = 334,
    T_XmlExpr = 335,
    T_NullTest = 336,
    T_BooleanTest = 337,
    T_CoerceToDomain = 338,
    T_CoerceToDomainValue = 339,
    T_SetToDefault = 340,
    T_CurrentOfExpr = 341,
    T_InferenceElem = 342,
    T_TargetEntry = 343,
    T_RangeTblRef = 344,
    T_JoinExpr = 345,
    T_FromExpr = 346,
    T_OnConflictExpr = 347,
    T_IntoClause = 348,
    T_ExprState = 400,
    T_GenericExprState = 401,
    T_WholeRowVarExprState = 402,
    T_AggrefExprState = 403,
    T_GroupingFuncExprState = 404,
    T_WindowFuncExprState = 405,
    T_ArrayRefExprState = 406,
    T_FuncExprState = 407,
    T_ScalarArrayOpExprState = 408,
    T_BoolExprState = 409,
    T_SubPlanState = 410,
    T_AlternativeSubPlanState = 411,
    T_FieldSelectState = 412,
    T_FieldStoreState = 413,
    T_CoerceViaIOState = 414,
    T_ArrayCoerceExprState = 415,
    T_ConvertRowtypeExprState = 416,
    T_CaseExprState = 417,
    T_CaseWhenState = 418,
    T_ArrayExprState = 419,
    T_RowExprState = 420,
    T_RowCompareExprState = 421,
    T_CoalesceExprState = 422,
    T_MinMaxExprState = 423,
    T_XmlExprState = 424,
    T_NullTestState = 425,
    T_CoerceToDomainState = 426,
    T_DomainConstraintState = 427,
    T_PlannerInfo = 500,
    T_PlannerGlobal = 501,
    T_RelOptInfo = 502,
    T_IndexOptInfo = 503,
    T_ParamPathInfo = 504,
    T_Path = 505,
    T_IndexPath = 506,
    T_BitmapHeapPath = 507,
    T_BitmapAndPath = 508,
    T_BitmapOrPath = 509,
    T_NestPath = 510,
    T_MergePath = 511,
    T_HashPath = 512,
    T_TidPath = 513,
    T_ForeignPath = 514,
    T_CustomPath = 515,
    T_AppendPath = 516,
    T_MergeAppendPath = 517,
    T_ResultPath = 518,
    T_MaterialPath = 519,
    T_UniquePath = 520,
    T_EquivalenceClass = 521,
    T_EquivalenceMember = 522,
    T_PathKey = 523,
    T_RestrictInfo = 524,
    T_PlaceHolderVar = 525,
    T_SpecialJoinInfo = 526,
    T_AppendRelInfo = 527,
    T_PlaceHolderInfo = 528,
    T_MinMaxAggInfo = 529,
    T_PlannerParamItem = 530,
    T_MemoryContext = 600,
    T_AllocSetContext = 601,
    T_Value = 650,
    T_Integer = 651,
    T_Float = 652,
    T_String = 653,
    T_BitString = 654,
    T_Null = 655,
    T_List = 656,
    T_IntList = 657,
    T_OidList = 658,
    T_Query = 700,
    T_PlannedStmt = 701,
    T_InsertStmt = 702,
    T_DeleteStmt = 703,
    T_UpdateStmt = 704,
    T_SelectStmt = 705,
    T_AlterTableStmt = 706,
    T_AlterTableCmd = 707,
    T_AlterDomainStmt = 708,
    T_SetOperationStmt = 709,
    T_GrantStmt = 710,
    T_GrantRoleStmt = 711,
    T_AlterDefaultPrivilegesStmt = 712,
    T_ClosePortalStmt = 713,
    T_ClusterStmt = 714,
    T_CopyStmt = 715,
    T_CreateStmt = 716,
    T_DefineStmt = 717,
    T_DropStmt = 718,
    T_TruncateStmt = 719,
    T_CommentStmt = 720,
    T_FetchStmt = 721,
    T_IndexStmt = 722,
    T_CreateFunctionStmt = 723,
    T_AlterFunctionStmt = 724,
    T_DoStmt = 725,
    T_RenameStmt = 726,
    T_RuleStmt = 727,
    T_NotifyStmt = 728,
    T_ListenStmt = 729,
    T_UnlistenStmt = 730,
    T_TransactionStmt = 731,
    T_ViewStmt = 732,
    T_LoadStmt = 733,
    T_CreateDomainStmt = 734,
    T_CreatedbStmt = 735,
    T_DropdbStmt = 736,
    T_VacuumStmt = 737,
    T_ExplainStmt = 738,
    T_CreateTableAsStmt = 739,
    T_CreateSeqStmt = 740,
    T_AlterSeqStmt = 741,
    T_VariableSetStmt = 742,
    T_VariableShowStmt = 743,
    T_DiscardStmt = 744,
    T_CreateTrigStmt = 745,
    T_CreatePLangStmt = 746,
    T_CreateRoleStmt = 747,
    T_AlterRoleStmt = 748,
    T_DropRoleStmt = 749,
    T_LockStmt = 750,
    T_ConstraintsSetStmt = 751,
    T_ReindexStmt = 752,
    T_CheckPointStmt = 753,
    T_CreateSchemaStmt = 754,
    T_AlterDatabaseStmt = 755,
    T_AlterDatabaseSetStmt = 756,
    T_AlterRoleSetStmt = 757,
    T_CreateConversionStmt = 758,
    T_CreateCastStmt = 759,
    T_CreateOpClassStmt = 760,
    T_CreateOpFamilyStmt = 761,
    T_AlterOpFamilyStmt = 762,
    T_PrepareStmt = 763,
    T_ExecuteStmt = 764,
    T_DeallocateStmt = 765,
    T_DeclareCursorStmt = 766,
    T_CreateTableSpaceStmt = 767,
    T_DropTableSpaceStmt = 768,
    T_AlterObjectSchemaStmt = 769,
    T_AlterOwnerStmt = 770,
    T_DropOwnedStmt = 771,
    T_ReassignOwnedStmt = 772,
    T_CompositeTypeStmt = 773,
    T_CreateEnumStmt = 774,
    T_CreateRangeStmt = 775,
    T_AlterEnumStmt = 776,
    T_AlterTSDictionaryStmt = 777,
    T_AlterTSConfigurationStmt = 778,
    T_CreateFdwStmt = 779,
    T_AlterFdwStmt = 780,
    T_CreateForeignServerStmt = 781,
    T_AlterForeignServerStmt = 782,
    T_CreateUserMappingStmt = 783,
    T_AlterUserMappingStmt = 784,
    T_DropUserMappingStmt = 785,
    T_AlterTableSpaceOptionsStmt = 786,
    T_AlterTableMoveAllStmt = 787,
    T_SecLabelStmt = 788,
    T_CreateForeignTableStmt = 789,
    T_ImportForeignSchemaStmt = 790,
    T_CreateExtensionStmt = 791,
    T_AlterExtensionStmt = 792,
    T_AlterExtensionContentsStmt = 793,
    T_CreateEventTrigStmt = 794,
    T_AlterEventTrigStmt = 795,
    T_RefreshMatViewStmt = 796,
    T_ReplicaIdentityStmt = 797,
    T_AlterSystemStmt = 798,
    T_CreatePolicyStmt = 799,
    T_AlterPolicyStmt = 800,
    T_CreateTransformStmt = 801,
    T_A_Expr = 900,
    T_ColumnRef = 901,
    T_ParamRef = 902,
    T_A_Const = 903,
    T_FuncCall = 904,
    T_A_Star = 905,
    T_A_Indices = 906,
    T_A_Indirection = 907,
    T_A_ArrayExpr = 908,
    T_ResTarget = 909,
    T_MultiAssignRef = 910,
    T_TypeCast = 911,
    T_CollateClause = 912,
    T_SortBy = 913,
    T_WindowDef = 914,
    T_RangeSubselect = 915,
    T_RangeFunction = 916,
    T_RangeTableSample = 917,
    T_TypeName = 918,
    T_ColumnDef = 919,
    T_IndexElem = 920,
    T_Constraint = 921,
    T_DefElem = 922,
    T_RangeTblEntry = 923,
    T_RangeTblFunction = 924,
    T_TableSampleClause = 925,
    T_WithCheckOption = 926,
    T_SortGroupClause = 927,
    T_GroupingSet = 928,
    T_WindowClause = 929,
    T_FuncWithArgs = 930,
    T_AccessPriv = 931,
    T_CreateOpClassItem = 932,
    T_TableLikeClause = 933,
    T_FunctionParameter = 934,
    T_LockingClause = 935,
    T_RowMarkClause = 936,
    T_XmlSerialize = 937,
    T_WithClause = 938,
    T_InferClause = 939,
    T_OnConflictClause = 940,
    T_CommonTableExpr = 941,
    T_RoleSpec = 942,
    T_IdentifySystemCmd = 943,
    T_BaseBackupCmd = 944,
    T_CreateReplicationSlotCmd = 945,
    T_DropReplicationSlotCmd = 946,
    T_StartReplicationCmd = 947,
    T_TimeLineHistoryCmd = 948,
    T_TriggerData = 950,
    T_EventTriggerData = 951,
    T_ReturnSetInfo = 952,
    T_WindowObjectData = 953,
    T_TIDBitmap = 954,
    T_InlineCodeBlock = 955,
    T_FdwRoutine = 956,
    T_TsmRoutine = 957,
}
pub type NodeTag = Enum_NodeTag;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Node {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_Node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Node = Struct_Node;
pub type Selectivity = ::std::os::raw::c_double;
pub type Cost = ::std::os::raw::c_double;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_CmdType {
    CMD_UNKNOWN = 0,
    CMD_SELECT = 1,
    CMD_UPDATE = 2,
    CMD_INSERT = 3,
    CMD_DELETE = 4,
    CMD_UTILITY = 5,
    CMD_NOTHING = 6,
}
pub type CmdType = Enum_CmdType;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_JoinType {
    JOIN_INNER = 0,
    JOIN_LEFT = 1,
    JOIN_FULL = 2,
    JOIN_RIGHT = 3,
    JOIN_SEMI = 4,
    JOIN_ANTI = 5,
    JOIN_UNIQUE_OUTER = 6,
    JOIN_UNIQUE_INNER = 7,
}
pub type JoinType = Enum_JoinType;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_OnConflictAction {
    ONCONFLICT_NONE = 0,
    ONCONFLICT_NOTHING = 1,
    ONCONFLICT_UPDATE = 2,
}
pub type OnConflictAction = Enum_OnConflictAction;
pub type ListCell = Struct_ListCell;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_List {
    pub _type: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub head: *mut ListCell,
    pub tail: *mut ListCell,
}
impl ::std::clone::Clone for Struct_List {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_List {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type List = Struct_List;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ListCell {
    pub data: Union_Unnamed26,
    pub next: *mut ListCell,
}
impl ::std::clone::Clone for Struct_ListCell {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ListCell {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed26 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed26 {
    pub unsafe fn ptr_value(&mut self) -> *mut *mut ::std::os::raw::c_void {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn int_value(&mut self) -> *mut ::std::os::raw::c_int {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn oid_value(&mut self) -> *mut Oid {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed26 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed26 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Alias {
    pub _type: NodeTag,
    pub aliasname: *mut ::std::os::raw::c_char,
    pub colnames: *mut List,
}
impl ::std::clone::Clone for Struct_Alias {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Alias {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Alias = Struct_Alias;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_InhOption { INH_NO = 0, INH_YES = 1, INH_DEFAULT = 2, }
pub type InhOption = Enum_InhOption;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_OnCommitAction {
    ONCOMMIT_NOOP = 0,
    ONCOMMIT_PRESERVE_ROWS = 1,
    ONCOMMIT_DELETE_ROWS = 2,
    ONCOMMIT_DROP = 3,
}
pub type OnCommitAction = Enum_OnCommitAction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeVar {
    pub _type: NodeTag,
    pub catalogname: *mut ::std::os::raw::c_char,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub inhOpt: InhOption,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_RangeVar {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeVar {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeVar = Struct_RangeVar;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IntoClause {
    pub _type: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::std::os::raw::c_char,
    pub viewQuery: *mut Node,
    pub skipData: _bool,
}
impl ::std::clone::Clone for Struct_IntoClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IntoClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IntoClause = Struct_IntoClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Expr {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_Expr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Expr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Expr = Struct_Expr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnoold: Index,
    pub varoattno: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Var {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Var {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Var = Struct_Var;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: _bool,
    pub constbyval: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Const {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Const {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Const = Struct_Const;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ParamKind {
    PARAM_EXTERN = 0,
    PARAM_EXEC = 1,
    PARAM_SUBLINK = 2,
    PARAM_MULTIEXPR = 3,
}
pub type ParamKind = Enum_ParamKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Param {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Param {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Param = Struct_Param;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: _bool,
    pub aggvariadic: _bool,
    pub aggkind: ::std::os::raw::c_char,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_Aggref {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Aggref {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Aggref = Struct_Aggref;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_GroupingFunc {
    pub xpr: Expr,
    pub args: *mut List,
    pub refs: *mut List,
    pub cols: *mut List,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_GroupingFunc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_GroupingFunc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GroupingFunc = Struct_GroupingFunc;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub winref: Index,
    pub winstar: _bool,
    pub winagg: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_WindowFunc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WindowFunc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowFunc = Struct_WindowFunc;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ArrayRef {
    pub xpr: Expr,
    pub refarraytype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
impl ::std::clone::Clone for Struct_ArrayRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ArrayRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayRef = Struct_ArrayRef;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_CoercionContext {
    COERCION_IMPLICIT = 0,
    COERCION_ASSIGNMENT = 1,
    COERCION_EXPLICIT = 2,
}
pub type CoercionContext = Enum_CoercionContext;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_CoercionForm {
    COERCE_EXPLICIT_CALL = 0,
    COERCE_EXPLICIT_CAST = 1,
    COERCE_IMPLICIT_CAST = 2,
}
pub type CoercionForm = Enum_CoercionForm;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: _bool,
    pub funcvariadic: _bool,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_FuncExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FuncExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncExpr = Struct_FuncExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::std::os::raw::c_char,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_NamedArgExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_NamedArgExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NamedArgExpr = Struct_NamedArgExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: _bool,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_OpExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OpExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OpExpr = Struct_OpExpr;
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: _bool,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ScalarArrayOpExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ScalarArrayOpExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ScalarArrayOpExpr = Struct_ScalarArrayOpExpr;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_BoolExprType { AND_EXPR = 0, OR_EXPR = 1, NOT_EXPR = 2, }
pub type BoolExprType = Enum_BoolExprType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_BoolExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BoolExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BoolExpr = Struct_BoolExpr;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_SubLinkType {
    EXISTS_SUBLINK = 0,
    ALL_SUBLINK = 1,
    ANY_SUBLINK = 2,
    ROWCOMPARE_SUBLINK = 3,
    EXPR_SUBLINK = 4,
    MULTIEXPR_SUBLINK = 5,
    ARRAY_SUBLINK = 6,
    CTE_SUBLINK = 7,
}
pub type SubLinkType = Enum_SubLinkType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub subLinkId: ::std::os::raw::c_int,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_SubLink {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SubLink {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SubLink = Struct_SubLink;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: *mut ::std::os::raw::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: _bool,
    pub unknownEqFalse: _bool,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
impl ::std::clone::Clone for Struct_SubPlan {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SubPlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SubPlan = Struct_SubPlan;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
impl ::std::clone::Clone for Struct_AlternativeSubPlan {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlternativeSubPlan {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlternativeSubPlan = Struct_AlternativeSubPlan;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
impl ::std::clone::Clone for Struct_FieldSelect {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FieldSelect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FieldSelect = Struct_FieldSelect;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
impl ::std::clone::Clone for Struct_FieldStore {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FieldStore {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FieldStore = Struct_FieldStore;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_RelabelType {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelabelType {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelabelType = Struct_RelabelType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CoerceViaIO {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CoerceViaIO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceViaIO = Struct_CoerceViaIO;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemfuncid: Oid,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub isExplicit: _bool,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ArrayCoerceExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ArrayCoerceExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayCoerceExpr = Struct_ArrayCoerceExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ConvertRowtypeExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ConvertRowtypeExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConvertRowtypeExpr = Struct_ConvertRowtypeExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CollateExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CollateExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CollateExpr = Struct_CollateExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CaseExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CaseExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseExpr = Struct_CaseExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CaseWhen {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CaseWhen {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseWhen = Struct_CaseWhen;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
impl ::std::clone::Clone for Struct_CaseTestExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CaseTestExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CaseTestExpr = Struct_CaseTestExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ArrayExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ArrayExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ArrayExpr = Struct_ArrayExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_RowExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RowExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowExpr = Struct_RowExpr;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_RowCompareType {
    ROWCOMPARE_LT = 1,
    ROWCOMPARE_LE = 2,
    ROWCOMPARE_EQ = 3,
    ROWCOMPARE_GE = 4,
    ROWCOMPARE_GT = 5,
    ROWCOMPARE_NE = 6,
}
pub type RowCompareType = Enum_RowCompareType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
impl ::std::clone::Clone for Struct_RowCompareExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RowCompareExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowCompareExpr = Struct_RowCompareExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CoalesceExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CoalesceExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoalesceExpr = Struct_CoalesceExpr;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_MinMaxOp { IS_GREATEST = 0, IS_LEAST = 1, }
pub type MinMaxOp = Enum_MinMaxOp;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_MinMaxExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MinMaxExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MinMaxExpr = Struct_MinMaxExpr;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_XmlExprOp {
    IS_XMLCONCAT = 0,
    IS_XMLELEMENT = 1,
    IS_XMLFOREST = 2,
    IS_XMLPARSE = 3,
    IS_XMLPI = 4,
    IS_XMLROOT = 5,
    IS_XMLSERIALIZE = 6,
    IS_DOCUMENT = 7,
}
pub type XmlExprOp = Enum_XmlExprOp;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed27 { XMLOPTION_DOCUMENT = 0, XMLOPTION_CONTENT = 1, }
pub type XmlOptionType = Enum_Unnamed27;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::std::os::raw::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub _type: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_XmlExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XmlExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XmlExpr = Struct_XmlExpr;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_NullTestType { IS_NULL = 0, IS_NOT_NULL = 1, }
pub type NullTestType = Enum_NullTestType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_NullTest {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_NullTest {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NullTest = Struct_NullTest;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_BoolTestType {
    IS_TRUE = 0,
    IS_NOT_TRUE = 1,
    IS_FALSE = 2,
    IS_NOT_FALSE = 3,
    IS_UNKNOWN = 4,
    IS_NOT_UNKNOWN = 5,
}
pub type BoolTestType = Enum_BoolTestType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_BooleanTest {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BooleanTest {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BooleanTest = Struct_BooleanTest;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CoerceToDomain {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CoerceToDomain {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceToDomain = Struct_CoerceToDomain;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CoerceToDomainValue {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CoerceToDomainValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CoerceToDomainValue = Struct_CoerceToDomainValue;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_SetToDefault {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SetToDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SetToDefault = Struct_SetToDefault;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::std::os::raw::c_char,
    pub cursor_param: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CurrentOfExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CurrentOfExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CurrentOfExpr = Struct_CurrentOfExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_InferenceElem {
    pub xpr: Expr,
    pub expr: *mut Node,
    pub infercollid: Oid,
    pub inferopclass: Oid,
}
impl ::std::clone::Clone for Struct_InferenceElem {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_InferenceElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type InferenceElem = Struct_InferenceElem;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::std::os::raw::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: _bool,
}
impl ::std::clone::Clone for Struct_TargetEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TargetEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TargetEntry = Struct_TargetEntry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeTblRef {
    pub _type: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_RangeTblRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeTblRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblRef = Struct_RangeTblRef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_JoinExpr {
    pub _type: NodeTag,
    pub jointype: JoinType,
    pub isNatural: _bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_JoinExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_JoinExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type JoinExpr = Struct_JoinExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FromExpr {
    pub _type: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
impl ::std::clone::Clone for Struct_FromExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FromExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FromExpr = Struct_FromExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OnConflictExpr {
    pub _type: NodeTag,
    pub action: OnConflictAction,
    pub arbiterElems: *mut List,
    pub arbiterWhere: *mut Node,
    pub constraint: Oid,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelIndex: ::std::os::raw::c_int,
    pub exclRelTlist: *mut List,
}
impl ::std::clone::Clone for Struct_OnConflictExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OnConflictExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OnConflictExpr = Struct_OnConflictExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Value {
    pub _type: NodeTag,
    pub val: Union_ValUnion,
}
impl ::std::clone::Clone for Struct_Value {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Value {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_ValUnion {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_ValUnion {
    pub unsafe fn ival(&mut self) -> *mut ::std::os::raw::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn str(&mut self) -> *mut *mut ::std::os::raw::c_char {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_ValUnion {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_ValUnion {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Value = Struct_Value;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_QuerySource {
    QSRC_ORIGINAL = 0,
    QSRC_PARSER = 1,
    QSRC_INSTEAD_RULE = 2,
    QSRC_QUAL_INSTEAD_RULE = 3,
    QSRC_NON_INSTEAD_RULE = 4,
}
pub type QuerySource = Enum_QuerySource;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_SortByDir {
    SORTBY_DEFAULT = 0,
    SORTBY_ASC = 1,
    SORTBY_DESC = 2,
    SORTBY_USING = 3,
}
pub type SortByDir = Enum_SortByDir;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_SortByNulls {
    SORTBY_NULLS_DEFAULT = 0,
    SORTBY_NULLS_FIRST = 1,
    SORTBY_NULLS_LAST = 2,
}
pub type SortByNulls = Enum_SortByNulls;
pub type AclMode = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Query {
    pub _type: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint32,
    pub canSetTag: _bool,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: _bool,
    pub hasWindowFuncs: _bool,
    pub hasSubLinks: _bool,
    pub hasDistinctOn: _bool,
    pub hasRecursive: _bool,
    pub hasModifyingCTE: _bool,
    pub hasForUpdate: _bool,
    pub hasRowSecurity: _bool,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub jointree: *mut FromExpr,
    pub targetList: *mut List,
    pub onConflict: *mut OnConflictExpr,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub groupingSets: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
    pub withCheckOptions: *mut List,
}
impl ::std::clone::Clone for Struct_Query {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Query {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Query = Struct_Query;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TypeName {
    pub _type: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: _bool,
    pub pct_type: _bool,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_TypeName {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TypeName {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TypeName = Struct_TypeName;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ColumnRef {
    pub _type: NodeTag,
    pub fields: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ColumnRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ColumnRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ColumnRef = Struct_ColumnRef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ParamRef {
    pub _type: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ParamRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ParamRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ParamRef = Struct_ParamRef;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_A_Expr_Kind {
    AEXPR_OP = 0,
    AEXPR_OP_ANY = 1,
    AEXPR_OP_ALL = 2,
    AEXPR_DISTINCT = 3,
    AEXPR_NULLIF = 4,
    AEXPR_OF = 5,
    AEXPR_IN = 6,
    AEXPR_LIKE = 7,
    AEXPR_ILIKE = 8,
    AEXPR_SIMILAR = 9,
    AEXPR_BETWEEN = 10,
    AEXPR_NOT_BETWEEN = 11,
    AEXPR_BETWEEN_SYM = 12,
    AEXPR_NOT_BETWEEN_SYM = 13,
    AEXPR_PAREN = 14,
}
pub type A_Expr_Kind = Enum_A_Expr_Kind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Expr {
    pub _type: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_A_Expr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Expr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Expr = Struct_A_Expr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Const {
    pub _type: NodeTag,
    pub val: Value,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_A_Const {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Const {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Const = Struct_A_Const;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TypeCast {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_TypeCast {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TypeCast {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TypeCast = Struct_TypeCast;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CollateClause {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_CollateClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CollateClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CollateClause = Struct_CollateClause;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_RoleSpecType {
    ROLESPEC_CSTRING = 0,
    ROLESPEC_CURRENT_USER = 1,
    ROLESPEC_SESSION_USER = 2,
    ROLESPEC_PUBLIC = 3,
}
pub type RoleSpecType = Enum_RoleSpecType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RoleSpec {
    pub _type: NodeTag,
    pub roletype: RoleSpecType,
    pub rolename: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_RoleSpec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RoleSpec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RoleSpec = Struct_RoleSpec;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FuncCall {
    pub _type: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub agg_within_group: _bool,
    pub agg_star: _bool,
    pub agg_distinct: _bool,
    pub func_variadic: _bool,
    pub over: *mut Struct_WindowDef,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_FuncCall {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FuncCall {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncCall = Struct_FuncCall;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Star {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_A_Star {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Star {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Star = Struct_A_Star;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Indices {
    pub _type: NodeTag,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
impl ::std::clone::Clone for Struct_A_Indices {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Indices {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Indices = Struct_A_Indices;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_Indirection {
    pub _type: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
impl ::std::clone::Clone for Struct_A_Indirection {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_Indirection {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_Indirection = Struct_A_Indirection;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_A_ArrayExpr {
    pub _type: NodeTag,
    pub elements: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_A_ArrayExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_A_ArrayExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type A_ArrayExpr = Struct_A_ArrayExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ResTarget {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ResTarget {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ResTarget {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ResTarget = Struct_ResTarget;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MultiAssignRef {
    pub _type: NodeTag,
    pub source: *mut Node,
    pub colno: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_MultiAssignRef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MultiAssignRef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MultiAssignRef = Struct_MultiAssignRef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SortBy {
    pub _type: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_SortBy {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SortBy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SortBy = Struct_SortBy;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WindowDef {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_WindowDef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WindowDef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowDef = Struct_WindowDef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeSubselect {
    pub _type: NodeTag,
    pub lateral: _bool,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
impl ::std::clone::Clone for Struct_RangeSubselect {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeSubselect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeSubselect = Struct_RangeSubselect;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeFunction {
    pub _type: NodeTag,
    pub lateral: _bool,
    pub ordinality: _bool,
    pub is_rowsfrom: _bool,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
impl ::std::clone::Clone for Struct_RangeFunction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeFunction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeFunction = Struct_RangeFunction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeTableSample {
    pub _type: NodeTag,
    pub relation: *mut Node,
    pub method: *mut List,
    pub args: *mut List,
    pub repeatable: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_RangeTableSample {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeTableSample {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTableSample = Struct_RangeTableSample;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ColumnDef {
    pub _type: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: _bool,
    pub is_not_null: _bool,
    pub is_from_type: _bool,
    pub storage: ::std::os::raw::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ColumnDef {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ColumnDef {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ColumnDef = Struct_ColumnDef;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TableLikeClause {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
}
impl ::std::clone::Clone for Struct_TableLikeClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TableLikeClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TableLikeClause = Struct_TableLikeClause;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_TableLikeOption {
    CREATE_TABLE_LIKE_DEFAULTS = 1,
    CREATE_TABLE_LIKE_CONSTRAINTS = 2,
    CREATE_TABLE_LIKE_INDEXES = 4,
    CREATE_TABLE_LIKE_STORAGE = 8,
    CREATE_TABLE_LIKE_COMMENTS = 16,
    CREATE_TABLE_LIKE_ALL = 2147483647,
}
pub type TableLikeOption = Enum_TableLikeOption;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IndexElem {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::std::os::raw::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
impl ::std::clone::Clone for Struct_IndexElem {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IndexElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexElem = Struct_IndexElem;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_DefElemAction {
    DEFELEM_UNSPEC = 0,
    DEFELEM_SET = 1,
    DEFELEM_ADD = 2,
    DEFELEM_DROP = 3,
}
pub type DefElemAction = Enum_DefElemAction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DefElem {
    pub _type: NodeTag,
    pub defnamespace: *mut ::std::os::raw::c_char,
    pub defname: *mut ::std::os::raw::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
}
impl ::std::clone::Clone for Struct_DefElem {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DefElem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DefElem = Struct_DefElem;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockingClause {
    pub _type: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
}
impl ::std::clone::Clone for Struct_LockingClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockingClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockingClause = Struct_LockingClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XmlSerialize {
    pub _type: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_XmlSerialize {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XmlSerialize {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XmlSerialize = Struct_XmlSerialize;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_RTEKind {
    RTE_RELATION = 0,
    RTE_SUBQUERY = 1,
    RTE_JOIN = 2,
    RTE_FUNCTION = 3,
    RTE_VALUES = 4,
    RTE_CTE = 5,
}
pub type RTEKind = Enum_RTEKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeTblEntry {
    pub _type: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub tablesample: *mut Struct_TableSampleClause,
    pub subquery: *mut Query,
    pub security_barrier: _bool,
    pub jointype: JoinType,
    pub joinaliasvars: *mut List,
    pub functions: *mut List,
    pub funcordinality: _bool,
    pub values_lists: *mut List,
    pub values_collations: *mut List,
    pub ctename: *mut ::std::os::raw::c_char,
    pub ctelevelsup: Index,
    pub self_reference: _bool,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: _bool,
    pub inh: _bool,
    pub inFromCl: _bool,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub insertedCols: *mut Bitmapset,
    pub updatedCols: *mut Bitmapset,
    pub securityQuals: *mut List,
}
impl ::std::clone::Clone for Struct_RangeTblEntry {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeTblEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblEntry = Struct_RangeTblEntry;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RangeTblFunction {
    pub _type: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::std::os::raw::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
impl ::std::clone::Clone for Struct_RangeTblFunction {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RangeTblFunction {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RangeTblFunction = Struct_RangeTblFunction;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TableSampleClause {
    pub _type: NodeTag,
    pub tsmhandler: Oid,
    pub args: *mut List,
    pub repeatable: *mut Expr,
}
impl ::std::clone::Clone for Struct_TableSampleClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TableSampleClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TableSampleClause = Struct_TableSampleClause;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_WCOKind {
    WCO_VIEW_CHECK = 0,
    WCO_RLS_INSERT_CHECK = 1,
    WCO_RLS_UPDATE_CHECK = 2,
    WCO_RLS_CONFLICT_CHECK = 3,
}
pub type WCOKind = Enum_WCOKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WithCheckOption {
    pub _type: NodeTag,
    pub kind: WCOKind,
    pub relname: *mut ::std::os::raw::c_char,
    pub polname: *mut ::std::os::raw::c_char,
    pub qual: *mut Node,
    pub cascaded: _bool,
}
impl ::std::clone::Clone for Struct_WithCheckOption {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WithCheckOption {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WithCheckOption = Struct_WithCheckOption;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SortGroupClause {
    pub _type: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: _bool,
    pub hashable: _bool,
}
impl ::std::clone::Clone for Struct_SortGroupClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SortGroupClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SortGroupClause = Struct_SortGroupClause;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed28 {
    GROUPING_SET_EMPTY = 0,
    GROUPING_SET_SIMPLE = 1,
    GROUPING_SET_ROLLUP = 2,
    GROUPING_SET_CUBE = 3,
    GROUPING_SET_SETS = 4,
}
pub type GroupingSetKind = Enum_Unnamed28;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_GroupingSet {
    pub _type: NodeTag,
    pub kind: GroupingSetKind,
    pub content: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_GroupingSet {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_GroupingSet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GroupingSet = Struct_GroupingSet;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WindowClause {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub winref: Index,
    pub copiedOrder: _bool,
}
impl ::std::clone::Clone for Struct_WindowClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WindowClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WindowClause = Struct_WindowClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RowMarkClause {
    pub _type: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub pushedDown: _bool,
}
impl ::std::clone::Clone for Struct_RowMarkClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RowMarkClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RowMarkClause = Struct_RowMarkClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_WithClause {
    pub _type: NodeTag,
    pub ctes: *mut List,
    pub recursive: _bool,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_WithClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_WithClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type WithClause = Struct_WithClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_InferClause {
    pub _type: NodeTag,
    pub indexElems: *mut List,
    pub whereClause: *mut Node,
    pub conname: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_InferClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_InferClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type InferClause = Struct_InferClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OnConflictClause {
    pub _type: NodeTag,
    pub action: OnConflictAction,
    pub infer: *mut InferClause,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_OnConflictClause {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OnConflictClause {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OnConflictClause = Struct_OnConflictClause;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CommonTableExpr {
    pub _type: NodeTag,
    pub ctename: *mut ::std::os::raw::c_char,
    pub aliascolnames: *mut List,
    pub ctequery: *mut Node,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: _bool,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
impl ::std::clone::Clone for Struct_CommonTableExpr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CommonTableExpr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CommonTableExpr = Struct_CommonTableExpr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_InsertStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub onConflictClause: *mut OnConflictClause,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::clone::Clone for Struct_InsertStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_InsertStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type InsertStmt = Struct_InsertStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DeleteStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::clone::Clone for Struct_DeleteStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DeleteStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeleteStmt = Struct_DeleteStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_UpdateStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl ::std::clone::Clone for Struct_UpdateStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_UpdateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type UpdateStmt = Struct_UpdateStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_SetOperation {
    SETOP_NONE = 0,
    SETOP_UNION = 1,
    SETOP_INTERSECT = 2,
    SETOP_EXCEPT = 3,
}
pub type SetOperation = Enum_SetOperation;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SelectStmt {
    pub _type: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: _bool,
    pub larg: *mut Struct_SelectStmt,
    pub rarg: *mut Struct_SelectStmt,
}
impl ::std::clone::Clone for Struct_SelectStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SelectStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SelectStmt = Struct_SelectStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SetOperationStmt {
    pub _type: NodeTag,
    pub op: SetOperation,
    pub all: _bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
impl ::std::clone::Clone for Struct_SetOperationStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SetOperationStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SetOperationStmt = Struct_SetOperationStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ObjectType {
    OBJECT_AGGREGATE = 0,
    OBJECT_AMOP = 1,
    OBJECT_AMPROC = 2,
    OBJECT_ATTRIBUTE = 3,
    OBJECT_CAST = 4,
    OBJECT_COLUMN = 5,
    OBJECT_COLLATION = 6,
    OBJECT_CONVERSION = 7,
    OBJECT_DATABASE = 8,
    OBJECT_DEFAULT = 9,
    OBJECT_DEFACL = 10,
    OBJECT_DOMAIN = 11,
    OBJECT_DOMCONSTRAINT = 12,
    OBJECT_EVENT_TRIGGER = 13,
    OBJECT_EXTENSION = 14,
    OBJECT_FDW = 15,
    OBJECT_FOREIGN_SERVER = 16,
    OBJECT_FOREIGN_TABLE = 17,
    OBJECT_FUNCTION = 18,
    OBJECT_INDEX = 19,
    OBJECT_LANGUAGE = 20,
    OBJECT_LARGEOBJECT = 21,
    OBJECT_MATVIEW = 22,
    OBJECT_OPCLASS = 23,
    OBJECT_OPERATOR = 24,
    OBJECT_OPFAMILY = 25,
    OBJECT_POLICY = 26,
    OBJECT_ROLE = 27,
    OBJECT_RULE = 28,
    OBJECT_SCHEMA = 29,
    OBJECT_SEQUENCE = 30,
    OBJECT_TABCONSTRAINT = 31,
    OBJECT_TABLE = 32,
    OBJECT_TABLESPACE = 33,
    OBJECT_TRANSFORM = 34,
    OBJECT_TRIGGER = 35,
    OBJECT_TSCONFIGURATION = 36,
    OBJECT_TSDICTIONARY = 37,
    OBJECT_TSPARSER = 38,
    OBJECT_TSTEMPLATE = 39,
    OBJECT_TYPE = 40,
    OBJECT_USER_MAPPING = 41,
    OBJECT_VIEW = 42,
}
pub type ObjectType = Enum_ObjectType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateSchemaStmt {
    pub _type: NodeTag,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub authrole: *mut Node,
    pub schemaElts: *mut List,
    pub if_not_exists: _bool,
}
impl ::std::clone::Clone for Struct_CreateSchemaStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateSchemaStmt = Struct_CreateSchemaStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_DropBehavior { DROP_RESTRICT = 0, DROP_CASCADE = 1, }
pub type DropBehavior = Enum_DropBehavior;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTableStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub relkind: ObjectType,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterTableStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTableStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableStmt = Struct_AlterTableStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_AlterTableType {
    AT_AddColumn = 0,
    AT_AddColumnRecurse = 1,
    AT_AddColumnToView = 2,
    AT_ColumnDefault = 3,
    AT_DropNotNull = 4,
    AT_SetNotNull = 5,
    AT_SetStatistics = 6,
    AT_SetOptions = 7,
    AT_ResetOptions = 8,
    AT_SetStorage = 9,
    AT_DropColumn = 10,
    AT_DropColumnRecurse = 11,
    AT_AddIndex = 12,
    AT_ReAddIndex = 13,
    AT_AddConstraint = 14,
    AT_AddConstraintRecurse = 15,
    AT_ReAddConstraint = 16,
    AT_AlterConstraint = 17,
    AT_ValidateConstraint = 18,
    AT_ValidateConstraintRecurse = 19,
    AT_ProcessedConstraint = 20,
    AT_AddIndexConstraint = 21,
    AT_DropConstraint = 22,
    AT_DropConstraintRecurse = 23,
    AT_ReAddComment = 24,
    AT_AlterColumnType = 25,
    AT_AlterColumnGenericOptions = 26,
    AT_ChangeOwner = 27,
    AT_ClusterOn = 28,
    AT_DropCluster = 29,
    AT_SetLogged = 30,
    AT_SetUnLogged = 31,
    AT_AddOids = 32,
    AT_AddOidsRecurse = 33,
    AT_DropOids = 34,
    AT_SetTableSpace = 35,
    AT_SetRelOptions = 36,
    AT_ResetRelOptions = 37,
    AT_ReplaceRelOptions = 38,
    AT_EnableTrig = 39,
    AT_EnableAlwaysTrig = 40,
    AT_EnableReplicaTrig = 41,
    AT_DisableTrig = 42,
    AT_EnableTrigAll = 43,
    AT_DisableTrigAll = 44,
    AT_EnableTrigUser = 45,
    AT_DisableTrigUser = 46,
    AT_EnableRule = 47,
    AT_EnableAlwaysRule = 48,
    AT_EnableReplicaRule = 49,
    AT_DisableRule = 50,
    AT_AddInherit = 51,
    AT_DropInherit = 52,
    AT_AddOf = 53,
    AT_DropOf = 54,
    AT_ReplicaIdentity = 55,
    AT_EnableRowSecurity = 56,
    AT_DisableRowSecurity = 57,
    AT_ForceRowSecurity = 58,
    AT_NoForceRowSecurity = 59,
    AT_GenericOptions = 60,
}
pub type AlterTableType = Enum_AlterTableType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicaIdentityStmt {
    pub _type: NodeTag,
    pub identity_type: ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_ReplicaIdentityStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicaIdentityStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicaIdentityStmt = Struct_ReplicaIdentityStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTableCmd {
    pub _type: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::std::os::raw::c_char,
    pub newowner: *mut Node,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterTableCmd {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTableCmd {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableCmd = Struct_AlterTableCmd;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterDomainStmt {
    pub _type: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: *mut List,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterDomainStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterDomainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDomainStmt = Struct_AlterDomainStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_GrantTargetType {
    ACL_TARGET_OBJECT = 0,
    ACL_TARGET_ALL_IN_SCHEMA = 1,
    ACL_TARGET_DEFAULTS = 2,
}
pub type GrantTargetType = Enum_GrantTargetType;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_GrantObjectType {
    ACL_OBJECT_COLUMN = 0,
    ACL_OBJECT_RELATION = 1,
    ACL_OBJECT_SEQUENCE = 2,
    ACL_OBJECT_DATABASE = 3,
    ACL_OBJECT_DOMAIN = 4,
    ACL_OBJECT_FDW = 5,
    ACL_OBJECT_FOREIGN_SERVER = 6,
    ACL_OBJECT_FUNCTION = 7,
    ACL_OBJECT_LANGUAGE = 8,
    ACL_OBJECT_LARGEOBJECT = 9,
    ACL_OBJECT_NAMESPACE = 10,
    ACL_OBJECT_TABLESPACE = 11,
    ACL_OBJECT_TYPE = 12,
}
pub type GrantObjectType = Enum_GrantObjectType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_GrantStmt {
    pub _type: NodeTag,
    pub is_grant: _bool,
    pub targtype: GrantTargetType,
    pub objtype: GrantObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: _bool,
    pub behavior: DropBehavior,
}
impl ::std::clone::Clone for Struct_GrantStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_GrantStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GrantStmt = Struct_GrantStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FuncWithArgs {
    pub _type: NodeTag,
    pub funcname: *mut List,
    pub funcargs: *mut List,
}
impl ::std::clone::Clone for Struct_FuncWithArgs {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FuncWithArgs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FuncWithArgs = Struct_FuncWithArgs;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AccessPriv {
    pub _type: NodeTag,
    pub priv_name: *mut ::std::os::raw::c_char,
    pub cols: *mut List,
}
impl ::std::clone::Clone for Struct_AccessPriv {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AccessPriv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AccessPriv = Struct_AccessPriv;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_GrantRoleStmt {
    pub _type: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: _bool,
    pub admin_opt: _bool,
    pub grantor: *mut Node,
    pub behavior: DropBehavior,
}
impl ::std::clone::Clone for Struct_GrantRoleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_GrantRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GrantRoleStmt = Struct_GrantRoleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterDefaultPrivilegesStmt {
    pub _type: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
impl ::std::clone::Clone for Struct_AlterDefaultPrivilegesStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterDefaultPrivilegesStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDefaultPrivilegesStmt = Struct_AlterDefaultPrivilegesStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CopyStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: _bool,
    pub is_program: _bool,
    pub filename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CopyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CopyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CopyStmt = Struct_CopyStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed29 {
    VAR_SET_VALUE = 0,
    VAR_SET_DEFAULT = 1,
    VAR_SET_CURRENT = 2,
    VAR_SET_MULTI = 3,
    VAR_RESET = 4,
    VAR_RESET_ALL = 5,
}
pub type VariableSetKind = Enum_Unnamed29;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VariableSetStmt {
    pub _type: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut List,
    pub is_local: _bool,
}
impl ::std::clone::Clone for Struct_VariableSetStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VariableSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableSetStmt = Struct_VariableSetStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VariableShowStmt {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_VariableShowStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VariableShowStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableShowStmt = Struct_VariableShowStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub if_not_exists: _bool,
}
impl ::std::clone::Clone for Struct_CreateStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateStmt = Struct_CreateStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ConstrType {
    CONSTR_NULL = 0,
    CONSTR_NOTNULL = 1,
    CONSTR_DEFAULT = 2,
    CONSTR_CHECK = 3,
    CONSTR_PRIMARY = 4,
    CONSTR_UNIQUE = 5,
    CONSTR_EXCLUSION = 6,
    CONSTR_FOREIGN = 7,
    CONSTR_ATTR_DEFERRABLE = 8,
    CONSTR_ATTR_NOT_DEFERRABLE = 9,
    CONSTR_ATTR_DEFERRED = 10,
    CONSTR_ATTR_IMMEDIATE = 11,
}
pub type ConstrType = Enum_ConstrType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Constraint {
    pub _type: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::std::os::raw::c_char,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: _bool,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::std::os::raw::c_char,
    pub keys: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexspace: *mut ::std::os::raw::c_char,
    pub access_method: *mut ::std::os::raw::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub skip_validation: _bool,
    pub initially_valid: _bool,
}
impl ::std::clone::Clone for Struct_Constraint {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Constraint {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Constraint = Struct_Constraint;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateTableSpaceStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub owner: *mut Node,
    pub location: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateTableSpaceStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateTableSpaceStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTableSpaceStmt = Struct_CreateTableSpaceStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropTableSpaceStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_DropTableSpaceStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropTableSpaceStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropTableSpaceStmt = Struct_DropTableSpaceStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTableSpaceOptionsStmt {
    pub _type: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub isReset: _bool,
}
impl ::std::clone::Clone for Struct_AlterTableSpaceOptionsStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTableSpaceOptionsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableSpaceOptionsStmt = Struct_AlterTableSpaceOptionsStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTableMoveAllStmt {
    pub _type: NodeTag,
    pub orig_tablespacename: *mut ::std::os::raw::c_char,
    pub objtype: ObjectType,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::std::os::raw::c_char,
    pub nowait: _bool,
}
impl ::std::clone::Clone for Struct_AlterTableMoveAllStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTableMoveAllStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTableMoveAllStmt = Struct_AlterTableMoveAllStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateExtensionStmt {
    pub _type: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub if_not_exists: _bool,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateExtensionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateExtensionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateExtensionStmt = Struct_CreateExtensionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterExtensionStmt {
    pub _type: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterExtensionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterExtensionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterExtensionStmt = Struct_AlterExtensionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterExtensionContentsStmt {
    pub _type: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
}
impl ::std::clone::Clone for Struct_AlterExtensionContentsStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterExtensionContentsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterExtensionContentsStmt = Struct_AlterExtensionContentsStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateFdwStmt {
    pub _type: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateFdwStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateFdwStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateFdwStmt = Struct_CreateFdwStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterFdwStmt {
    pub _type: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterFdwStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterFdwStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterFdwStmt = Struct_AlterFdwStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateForeignServerStmt {
    pub _type: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateForeignServerStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateForeignServerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateForeignServerStmt = Struct_CreateForeignServerStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterForeignServerStmt {
    pub _type: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub has_version: _bool,
}
impl ::std::clone::Clone for Struct_AlterForeignServerStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterForeignServerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterForeignServerStmt = Struct_AlterForeignServerStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateForeignTableStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateForeignTableStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateForeignTableStmt = Struct_CreateForeignTableStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateUserMappingStmt {
    pub _type: NodeTag,
    pub user: *mut Node,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateUserMappingStmt = Struct_CreateUserMappingStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterUserMappingStmt {
    pub _type: NodeTag,
    pub user: *mut Node,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterUserMappingStmt = Struct_AlterUserMappingStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropUserMappingStmt {
    pub _type: NodeTag,
    pub user: *mut Node,
    pub servername: *mut ::std::os::raw::c_char,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_DropUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropUserMappingStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropUserMappingStmt = Struct_DropUserMappingStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ImportForeignSchemaType {
    FDW_IMPORT_SCHEMA_ALL = 0,
    FDW_IMPORT_SCHEMA_LIMIT_TO = 1,
    FDW_IMPORT_SCHEMA_EXCEPT = 2,
}
pub type ImportForeignSchemaType = Enum_ImportForeignSchemaType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ImportForeignSchemaStmt {
    pub _type: NodeTag,
    pub server_name: *mut ::std::os::raw::c_char,
    pub remote_schema: *mut ::std::os::raw::c_char,
    pub local_schema: *mut ::std::os::raw::c_char,
    pub list_type: ImportForeignSchemaType,
    pub table_list: *mut List,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_ImportForeignSchemaStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ImportForeignSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ImportForeignSchemaStmt = Struct_ImportForeignSchemaStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreatePolicyStmt {
    pub _type: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub cmd_name: *mut ::std::os::raw::c_char,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
impl ::std::clone::Clone for Struct_CreatePolicyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreatePolicyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreatePolicyStmt = Struct_CreatePolicyStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterPolicyStmt {
    pub _type: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
impl ::std::clone::Clone for Struct_AlterPolicyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterPolicyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterPolicyStmt = Struct_AlterPolicyStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: _bool,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub isconstraint: _bool,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub constrrel: *mut RangeVar,
}
impl ::std::clone::Clone for Struct_CreateTrigStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTrigStmt = Struct_CreateTrigStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateEventTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub eventname: *mut ::std::os::raw::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
impl ::std::clone::Clone for Struct_CreateEventTrigStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateEventTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateEventTrigStmt = Struct_CreateEventTrigStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterEventTrigStmt {
    pub _type: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub tgenabled: ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_AlterEventTrigStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterEventTrigStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterEventTrigStmt = Struct_AlterEventTrigStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreatePLangStmt {
    pub _type: NodeTag,
    pub replace: _bool,
    pub plname: *mut ::std::os::raw::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: _bool,
}
impl ::std::clone::Clone for Struct_CreatePLangStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreatePLangStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreatePLangStmt = Struct_CreatePLangStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_RoleStmtType {
    ROLESTMT_ROLE = 0,
    ROLESTMT_USER = 1,
    ROLESTMT_GROUP = 2,
}
pub type RoleStmtType = Enum_RoleStmtType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateRoleStmt {
    pub _type: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreateRoleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateRoleStmt = Struct_CreateRoleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterRoleStmt {
    pub _type: NodeTag,
    pub role: *mut Node,
    pub options: *mut List,
    pub action: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_AlterRoleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterRoleStmt = Struct_AlterRoleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterRoleSetStmt {
    pub _type: NodeTag,
    pub role: *mut Node,
    pub database: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::clone::Clone for Struct_AlterRoleSetStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterRoleSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterRoleSetStmt = Struct_AlterRoleSetStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropRoleStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_DropRoleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropRoleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropRoleStmt = Struct_DropRoleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateSeqStmt {
    pub _type: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
    pub if_not_exists: _bool,
}
impl ::std::clone::Clone for Struct_CreateSeqStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateSeqStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateSeqStmt = Struct_CreateSeqStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterSeqStmt {
    pub _type: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterSeqStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterSeqStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterSeqStmt = Struct_AlterSeqStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DefineStmt {
    pub _type: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: _bool,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
}
impl ::std::clone::Clone for Struct_DefineStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DefineStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DefineStmt = Struct_DefineStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateDomainStmt {
    pub _type: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
impl ::std::clone::Clone for Struct_CreateDomainStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateDomainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateDomainStmt = Struct_CreateDomainStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateOpClassStmt {
    pub _type: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: _bool,
}
impl ::std::clone::Clone for Struct_CreateOpClassStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateOpClassStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpClassStmt = Struct_CreateOpClassStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateOpClassItem {
    pub _type: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: *mut List,
    pub args: *mut List,
    pub number: ::std::os::raw::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
impl ::std::clone::Clone for Struct_CreateOpClassItem {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateOpClassItem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpClassItem = Struct_CreateOpClassItem;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateOpFamilyStmt {
    pub _type: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_CreateOpFamilyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateOpFamilyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateOpFamilyStmt = Struct_CreateOpFamilyStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterOpFamilyStmt {
    pub _type: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub isDrop: _bool,
    pub items: *mut List,
}
impl ::std::clone::Clone for Struct_AlterOpFamilyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterOpFamilyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterOpFamilyStmt = Struct_AlterOpFamilyStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropStmt {
    pub _type: NodeTag,
    pub objects: *mut List,
    pub arguments: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
    pub concurrent: _bool,
}
impl ::std::clone::Clone for Struct_DropStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropStmt = Struct_DropStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TruncateStmt {
    pub _type: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: _bool,
    pub behavior: DropBehavior,
}
impl ::std::clone::Clone for Struct_TruncateStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TruncateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TruncateStmt = Struct_TruncateStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CommentStmt {
    pub _type: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub comment: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_CommentStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CommentStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CommentStmt = Struct_CommentStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SecLabelStmt {
    pub _type: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub provider: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_SecLabelStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SecLabelStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SecLabelStmt = Struct_SecLabelStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DeclareCursorStmt {
    pub _type: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub query: *mut Node,
}
impl ::std::clone::Clone for Struct_DeclareCursorStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DeclareCursorStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeclareCursorStmt = Struct_DeclareCursorStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ClosePortalStmt {
    pub _type: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_ClosePortalStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ClosePortalStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ClosePortalStmt = Struct_ClosePortalStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_FetchDirection {
    FETCH_FORWARD = 0,
    FETCH_BACKWARD = 1,
    FETCH_ABSOLUTE = 2,
    FETCH_RELATIVE = 3,
}
pub type FetchDirection = Enum_FetchDirection;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FetchStmt {
    pub _type: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: *mut ::std::os::raw::c_char,
    pub ismove: _bool,
}
impl ::std::clone::Clone for Struct_FetchStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FetchStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FetchStmt = Struct_FetchStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_IndexStmt {
    pub _type: NodeTag,
    pub idxname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub tableSpace: *mut ::std::os::raw::c_char,
    pub indexParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::std::os::raw::c_char,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub unique: _bool,
    pub primary: _bool,
    pub isconstraint: _bool,
    pub deferrable: _bool,
    pub initdeferred: _bool,
    pub transformed: _bool,
    pub concurrent: _bool,
    pub if_not_exists: _bool,
}
impl ::std::clone::Clone for Struct_IndexStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_IndexStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type IndexStmt = Struct_IndexStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateFunctionStmt {
    pub _type: NodeTag,
    pub replace: _bool,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
    pub withClause: *mut List,
}
impl ::std::clone::Clone for Struct_CreateFunctionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateFunctionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateFunctionStmt = Struct_CreateFunctionStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_FunctionParameterMode {
    FUNC_PARAM_IN = 105,
    FUNC_PARAM_OUT = 111,
    FUNC_PARAM_INOUT = 98,
    FUNC_PARAM_VARIADIC = 118,
    FUNC_PARAM_TABLE = 116,
}
pub type FunctionParameterMode = Enum_FunctionParameterMode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FunctionParameter {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
impl ::std::clone::Clone for Struct_FunctionParameter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FunctionParameter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FunctionParameter = Struct_FunctionParameter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterFunctionStmt {
    pub _type: NodeTag,
    pub func: *mut FuncWithArgs,
    pub actions: *mut List,
}
impl ::std::clone::Clone for Struct_AlterFunctionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterFunctionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterFunctionStmt = Struct_AlterFunctionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DoStmt {
    pub _type: NodeTag,
    pub args: *mut List,
}
impl ::std::clone::Clone for Struct_DoStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DoStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DoStmt = Struct_DoStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_InlineCodeBlock {
    pub _type: NodeTag,
    pub source_text: *mut ::std::os::raw::c_char,
    pub langOid: Oid,
    pub langIsTrusted: _bool,
}
impl ::std::clone::Clone for Struct_InlineCodeBlock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_InlineCodeBlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type InlineCodeBlock = Struct_InlineCodeBlock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RenameStmt {
    pub _type: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub subname: *mut ::std::os::raw::c_char,
    pub newname: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_RenameStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RenameStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RenameStmt = Struct_RenameStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterObjectSchemaStmt {
    pub _type: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newschema: *mut ::std::os::raw::c_char,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterObjectSchemaStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterObjectSchemaStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterObjectSchemaStmt = Struct_AlterObjectSchemaStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterOwnerStmt {
    pub _type: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newowner: *mut Node,
}
impl ::std::clone::Clone for Struct_AlterOwnerStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterOwnerStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterOwnerStmt = Struct_AlterOwnerStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RuleStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::std::os::raw::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: _bool,
    pub actions: *mut List,
    pub replace: _bool,
}
impl ::std::clone::Clone for Struct_RuleStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RuleStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RuleStmt = Struct_RuleStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_NotifyStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_NotifyStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_NotifyStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type NotifyStmt = Struct_NotifyStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ListenStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_ListenStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ListenStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ListenStmt = Struct_ListenStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_UnlistenStmt {
    pub _type: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_UnlistenStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_UnlistenStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type UnlistenStmt = Struct_UnlistenStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_TransactionStmtKind {
    TRANS_STMT_BEGIN = 0,
    TRANS_STMT_START = 1,
    TRANS_STMT_COMMIT = 2,
    TRANS_STMT_ROLLBACK = 3,
    TRANS_STMT_SAVEPOINT = 4,
    TRANS_STMT_RELEASE = 5,
    TRANS_STMT_ROLLBACK_TO = 6,
    TRANS_STMT_PREPARE = 7,
    TRANS_STMT_COMMIT_PREPARED = 8,
    TRANS_STMT_ROLLBACK_PREPARED = 9,
}
pub type TransactionStmtKind = Enum_TransactionStmtKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TransactionStmt {
    pub _type: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub gid: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_TransactionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TransactionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TransactionStmt = Struct_TransactionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CompositeTypeStmt {
    pub _type: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
impl ::std::clone::Clone for Struct_CompositeTypeStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CompositeTypeStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CompositeTypeStmt = Struct_CompositeTypeStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateEnumStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
impl ::std::clone::Clone for Struct_CreateEnumStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateEnumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateEnumStmt = Struct_CreateEnumStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateRangeStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
impl ::std::clone::Clone for Struct_CreateRangeStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateRangeStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateRangeStmt = Struct_CreateRangeStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterEnumStmt {
    pub _type: NodeTag,
    pub typeName: *mut List,
    pub newVal: *mut ::std::os::raw::c_char,
    pub newValNeighbor: *mut ::std::os::raw::c_char,
    pub newValIsAfter: _bool,
    pub skipIfExists: _bool,
}
impl ::std::clone::Clone for Struct_AlterEnumStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterEnumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterEnumStmt = Struct_AlterEnumStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ViewCheckOption {
    NO_CHECK_OPTION = 0,
    LOCAL_CHECK_OPTION = 1,
    CASCADED_CHECK_OPTION = 2,
}
pub type ViewCheckOption = Enum_ViewCheckOption;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ViewStmt {
    pub _type: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: _bool,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption,
}
impl ::std::clone::Clone for Struct_ViewStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ViewStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ViewStmt = Struct_ViewStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LoadStmt {
    pub _type: NodeTag,
    pub filename: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_LoadStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LoadStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LoadStmt = Struct_LoadStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreatedbStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_CreatedbStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreatedbStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreatedbStmt = Struct_CreatedbStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterDatabaseStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterDatabaseStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterDatabaseStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDatabaseStmt = Struct_AlterDatabaseStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterDatabaseSetStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::clone::Clone for Struct_AlterDatabaseSetStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterDatabaseSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterDatabaseSetStmt = Struct_AlterDatabaseSetStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropdbStmt {
    pub _type: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_DropdbStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropdbStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropdbStmt = Struct_DropdbStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterSystemStmt {
    pub _type: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
impl ::std::clone::Clone for Struct_AlterSystemStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterSystemStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterSystemStmt = Struct_AlterSystemStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ClusterStmt {
    pub _type: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::std::os::raw::c_char,
    pub verbose: _bool,
}
impl ::std::clone::Clone for Struct_ClusterStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ClusterStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ClusterStmt = Struct_ClusterStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_VacuumOption {
    VACOPT_VACUUM = 1,
    VACOPT_ANALYZE = 2,
    VACOPT_VERBOSE = 4,
    VACOPT_FREEZE = 8,
    VACOPT_FULL = 16,
    VACOPT_NOWAIT = 32,
    VACOPT_SKIPTOAST = 64,
}
pub type VacuumOption = Enum_VacuumOption;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VacuumStmt {
    pub _type: NodeTag,
    pub options: ::std::os::raw::c_int,
    pub relation: *mut RangeVar,
    pub va_cols: *mut List,
}
impl ::std::clone::Clone for Struct_VacuumStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VacuumStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VacuumStmt = Struct_VacuumStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ExplainStmt {
    pub _type: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_ExplainStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ExplainStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExplainStmt = Struct_ExplainStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateTableAsStmt {
    pub _type: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub relkind: ObjectType,
    pub is_select_into: _bool,
    pub if_not_exists: _bool,
}
impl ::std::clone::Clone for Struct_CreateTableAsStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateTableAsStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTableAsStmt = Struct_CreateTableAsStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RefreshMatViewStmt {
    pub _type: NodeTag,
    pub concurrent: _bool,
    pub skipData: _bool,
    pub relation: *mut RangeVar,
}
impl ::std::clone::Clone for Struct_RefreshMatViewStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RefreshMatViewStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RefreshMatViewStmt = Struct_RefreshMatViewStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CheckPointStmt {
    pub _type: NodeTag,
}
impl ::std::clone::Clone for Struct_CheckPointStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CheckPointStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheckPointStmt = Struct_CheckPointStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_DiscardMode {
    DISCARD_ALL = 0,
    DISCARD_PLANS = 1,
    DISCARD_SEQUENCES = 2,
    DISCARD_TEMP = 3,
}
pub type DiscardMode = Enum_DiscardMode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DiscardStmt {
    pub _type: NodeTag,
    pub target: DiscardMode,
}
impl ::std::clone::Clone for Struct_DiscardStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DiscardStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DiscardStmt = Struct_DiscardStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockStmt {
    pub _type: NodeTag,
    pub relations: *mut List,
    pub mode: ::std::os::raw::c_int,
    pub nowait: _bool,
}
impl ::std::clone::Clone for Struct_LockStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockStmt = Struct_LockStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ConstraintsSetStmt {
    pub _type: NodeTag,
    pub constraints: *mut List,
    pub deferred: _bool,
}
impl ::std::clone::Clone for Struct_ConstraintsSetStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ConstraintsSetStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConstraintsSetStmt = Struct_ConstraintsSetStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ReindexObjectType {
    REINDEX_OBJECT_INDEX = 0,
    REINDEX_OBJECT_TABLE = 1,
    REINDEX_OBJECT_SCHEMA = 2,
    REINDEX_OBJECT_SYSTEM = 3,
    REINDEX_OBJECT_DATABASE = 4,
}
pub type ReindexObjectType = Enum_ReindexObjectType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReindexStmt {
    pub _type: NodeTag,
    pub kind: ReindexObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ReindexStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReindexStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReindexStmt = Struct_ReindexStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateConversionStmt {
    pub _type: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::std::os::raw::c_char,
    pub to_encoding_name: *mut ::std::os::raw::c_char,
    pub func_name: *mut List,
    pub def: _bool,
}
impl ::std::clone::Clone for Struct_CreateConversionStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateConversionStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateConversionStmt = Struct_CreateConversionStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateCastStmt {
    pub _type: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut FuncWithArgs,
    pub context: CoercionContext,
    pub inout: _bool,
}
impl ::std::clone::Clone for Struct_CreateCastStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateCastStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateCastStmt = Struct_CreateCastStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CreateTransformStmt {
    pub _type: NodeTag,
    pub replace: _bool,
    pub type_name: *mut TypeName,
    pub lang: *mut ::std::os::raw::c_char,
    pub fromsql: *mut FuncWithArgs,
    pub tosql: *mut FuncWithArgs,
}
impl ::std::clone::Clone for Struct_CreateTransformStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CreateTransformStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateTransformStmt = Struct_CreateTransformStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PrepareStmt {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
impl ::std::clone::Clone for Struct_PrepareStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PrepareStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PrepareStmt = Struct_PrepareStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ExecuteStmt {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
impl ::std::clone::Clone for Struct_ExecuteStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ExecuteStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExecuteStmt = Struct_ExecuteStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DeallocateStmt {
    pub _type: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_DeallocateStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DeallocateStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DeallocateStmt = Struct_DeallocateStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DropOwnedStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
impl ::std::clone::Clone for Struct_DropOwnedStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DropOwnedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DropOwnedStmt = Struct_DropOwnedStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReassignOwnedStmt {
    pub _type: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut Node,
}
impl ::std::clone::Clone for Struct_ReassignOwnedStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReassignOwnedStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReassignOwnedStmt = Struct_ReassignOwnedStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTSDictionaryStmt {
    pub _type: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
impl ::std::clone::Clone for Struct_AlterTSDictionaryStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTSDictionaryStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTSDictionaryStmt = Struct_AlterTSDictionaryStmt;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_AlterTSConfigType {
    ALTER_TSCONFIG_ADD_MAPPING = 0,
    ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN = 1,
    ALTER_TSCONFIG_REPLACE_DICT = 2,
    ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN = 3,
    ALTER_TSCONFIG_DROP_MAPPING = 4,
}
pub type AlterTSConfigType = Enum_AlterTSConfigType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AlterTSConfigurationStmt {
    pub _type: NodeTag,
    pub kind: AlterTSConfigType,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub _override: _bool,
    pub replace: _bool,
    pub missing_ok: _bool,
}
impl ::std::clone::Clone for Struct_AlterTSConfigurationStmt {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AlterTSConfigurationStmt {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AlterTSConfigurationStmt = Struct_AlterTSConfigurationStmt;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_StringInfoData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_StringInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_StringInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StringInfoData = Struct_StringInfoData;
pub type StringInfo = *mut StringInfoData;
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
impl ::std::clone::Clone for Struct_BlockIdData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_BlockIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type BlockIdData = Struct_BlockIdData;
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ItemIdData {
    pub _bindgen_bitfield_1_: ::std::os::raw::c_uint,
}
impl ::std::clone::Clone for Struct_ItemIdData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ItemIdData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemIdData = Struct_ItemIdData;
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C, packed)]
#[derive(Copy)]
pub struct Struct_ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
impl ::std::clone::Clone for Struct_ItemPointerData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ItemPointerData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ItemPointerData = Struct_ItemPointerData;
pub type ItemPointer = *mut ItemPointerData;
pub type HeapTupleHeaderData = Struct_HeapTupleHeaderData;
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
pub type MinimalTupleData = Struct_MinimalTupleData;
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
impl ::std::clone::Clone for Struct_HeapTupleData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTupleData = Struct_HeapTupleData;
pub type HeapTuple = *mut HeapTupleData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
impl ::std::clone::Clone for Struct_OpBtreeInterpretation {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OpBtreeInterpretation {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OpBtreeInterpretation = Struct_OpBtreeInterpretation;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_IOFuncSelector {
    IOFunc_input = 0,
    IOFunc_output = 1,
    IOFunc_receive = 2,
    IOFunc_send = 3,
}
pub type IOFuncSelector = Enum_IOFuncSelector;
pub type get_attavgwidth_hook_type =
    ::std::option::Option<extern "C" fn(relid: Oid, attnum: AttrNumber)
                              -> int32>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: _bool,
    pub attstorage: ::std::os::raw::c_char,
    pub attalign: ::std::os::raw::c_char,
    pub attnotnull: _bool,
    pub atthasdef: _bool,
    pub attisdropped: _bool,
    pub attislocal: _bool,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
impl ::std::clone::Clone for Struct_FormData_pg_attribute {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_attribute {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_attribute = Struct_FormData_pg_attribute;
pub type Form_pg_attribute = *mut FormData_pg_attribute;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_attrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_attrDefault {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_attrDefault {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AttrDefault = Struct_attrDefault;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_constrCheck {
    pub ccname: *mut ::std::os::raw::c_char,
    pub ccbin: *mut ::std::os::raw::c_char,
    pub ccvalid: _bool,
    pub ccnoinherit: _bool,
}
impl ::std::clone::Clone for Struct_constrCheck {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_constrCheck {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConstrCheck = Struct_constrCheck;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: _bool,
}
impl ::std::clone::Clone for Struct_tupleConstr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_tupleConstr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleConstr = Struct_tupleConstr;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_tupleDesc {
    pub natts: ::std::os::raw::c_int,
    pub attrs: *mut Form_pg_attribute,
    pub constr: *mut TupleConstr,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdhasoid: _bool,
    pub tdrefcount: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_tupleDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_tupleDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TupleDesc = *mut Struct_tupleDesc;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
impl ::std::clone::Clone for Struct_flock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_flock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
impl ::std::clone::Clone for Struct_timespec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_flocktimeout {
    pub fl: Struct_flock,
    pub timeout: Struct_timespec,
}
impl ::std::clone::Clone for Struct_flocktimeout {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_flocktimeout {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_radvisory {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_radvisory {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fcodeblobs {
    pub f_cd_hash: *mut ::std::os::raw::c_void,
    pub f_hash_size: size_t,
    pub f_cd_buffer: *mut ::std::os::raw::c_void,
    pub f_cd_size: size_t,
    pub f_out_size: *mut ::std::os::raw::c_uint,
    pub f_arch: ::std::os::raw::c_int,
    pub __padding: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_fcodeblobs {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fcodeblobs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fcodeblobs_t = Struct_fcodeblobs;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::std::os::raw::c_void,
    pub fs_blob_size: size_t,
}
impl ::std::clone::Clone for Struct_fsignatures {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fsignatures {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fsignatures_t = Struct_fsignatures;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
impl ::std::clone::Clone for Struct_fstore {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fstore {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fstore_t = Struct_fstore;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_fbootstraptransfer {
    pub fbt_offset: off_t,
    pub fbt_length: size_t,
    pub fbt_buffer: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct_fbootstraptransfer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_fbootstraptransfer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type fbootstraptransfer_t = Struct_fbootstraptransfer;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_log2phys {
    pub l2p_flags: ::std::os::raw::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
impl ::std::clone::Clone for Struct_log2phys {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_log2phys {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__filesec { }
pub type filesec_t = *mut Struct__filesec;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed30 {
    FILESEC_OWNER = 1,
    FILESEC_GROUP = 2,
    FILESEC_UUID = 3,
    FILESEC_MODE = 4,
    FILESEC_ACL = 5,
    FILESEC_GRPUUID = 6,
    FILESEC_ACL_RAW = 100,
    FILESEC_ACL_ALLOCSIZE = 101,
}
pub type filesec_property_t = Enum_Unnamed30;
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type RepOriginId = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_VariableCacheData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextXid: TransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub oldestCommitTsXid: TransactionId,
    pub newestCommitTsXid: TransactionId,
    pub latestCompletedXid: TransactionId,
}
impl ::std::clone::Clone for Struct_VariableCacheData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_VariableCacheData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type VariableCacheData = Struct_VariableCacheData;
pub type VariableCache = *mut VariableCacheData;
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed31 {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
impl ::std::clone::Clone for Struct_Unnamed31 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed31 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageXLogRecPtr = Struct_Unnamed31;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: *mut ItemIdData,
}
impl ::std::clone::Clone for Struct_PageHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PageHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageHeaderData = Struct_PageHeaderData;
pub type PageHeader = *mut PageHeaderData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: Union_Unnamed32,
}
impl ::std::clone::Clone for Struct_HeapTupleFields {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleFields {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed32 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed32 {
    pub unsafe fn t_cid(&mut self) -> *mut CommandId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn t_xvac(&mut self) -> *mut TransactionId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HeapTupleFields = Struct_HeapTupleFields;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
impl ::std::clone::Clone for Struct_DatumTupleFields {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_DatumTupleFields {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DatumTupleFields = Struct_DatumTupleFields;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HeapTupleHeaderData {
    pub t_choice: Union_Unnamed33,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: *mut bits8,
}
impl ::std::clone::Clone for Struct_HeapTupleHeaderData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HeapTupleHeaderData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed33 {
    pub _bindgen_data_: [u32; 3usize],
}
impl Union_Unnamed33 {
    pub unsafe fn t_heap(&mut self) -> *mut HeapTupleFields {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn t_datum(&mut self) -> *mut DatumTupleFields {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed33 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed33 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::std::os::raw::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: *mut bits8,
}
impl ::std::clone::Clone for Struct_MinimalTupleData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_MinimalTupleData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_node = Struct_dlist_node;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_head {
    pub head: dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_head {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_head = Struct_dlist_head;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_iter = Struct_dlist_iter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl ::std::clone::Clone for Struct_dlist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dlist_mutable_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type dlist_mutable_iter = Struct_dlist_mutable_iter;
pub type slist_node = Struct_slist_node;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_node {
    pub next: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_head {
    pub head: slist_node,
}
impl ::std::clone::Clone for Struct_slist_head {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_head = Struct_slist_head;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_iter {
    pub cur: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_iter = Struct_slist_iter;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
impl ::std::clone::Clone for Struct_slist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_slist_mutable_iter {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type slist_mutable_iter = Struct_slist_mutable_iter;
#[derive(Clone, Copy)]
#[repr(i32)]
pub enum Enum_ForkNumber {
    InvalidForkNumber = -1,
    MAIN_FORKNUM = 0,
    FSM_FORKNUM = 1,
    VISIBILITYMAP_FORKNUM = 2,
    INIT_FORKNUM = 3,
}
pub type ForkNumber = Enum_ForkNumber;
pub type BackendId = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
impl ::std::clone::Clone for Struct_RelFileNode {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelFileNode {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelFileNode = Struct_RelFileNode;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
impl ::std::clone::Clone for Struct_RelFileNodeBackend {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelFileNodeBackend {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelFileNodeBackend = Struct_RelFileNodeBackend;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed34 {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
impl ::std::clone::Clone for Struct_Unnamed34 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed34 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalCatcacheMsg = Struct_Unnamed34;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed35 {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed35 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed35 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalCatalogMsg = Struct_Unnamed35;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed36 {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed36 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed36 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalRelcacheMsg = Struct_Unnamed36;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed37 {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rnode: RelFileNode,
}
impl ::std::clone::Clone for Struct_Unnamed37 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed37 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalSmgrMsg = Struct_Unnamed37;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed38 {
    pub id: int8,
    pub dbId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed38 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed38 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalRelmapMsg = Struct_Unnamed38;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed39 {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl ::std::clone::Clone for Struct_Unnamed39 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed39 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalSnapshotMsg = Struct_Unnamed39;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed40 {
    pub _bindgen_data_: [u32; 4usize],
}
impl Union_Unnamed40 {
    pub unsafe fn id(&mut self) -> *mut int8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cc(&mut self) -> *mut SharedInvalCatcacheMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn cat(&mut self) -> *mut SharedInvalCatalogMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn rc(&mut self) -> *mut SharedInvalRelcacheMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sm(&mut self) -> *mut SharedInvalSmgrMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn rm(&mut self) -> *mut SharedInvalRelmapMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn sn(&mut self) -> *mut SharedInvalSnapshotMsg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed40 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed40 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SharedInvalidationMessage = Union_Unnamed40;
pub type HashValueFunc =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size) -> uint32>;
pub type HashCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(key1:
                                                   *const ::std::os::raw::c_void,
                                               key2:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> ::std::os::raw::c_int>;
pub type HashCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(dest:
                                                   *mut ::std::os::raw::c_void,
                                               src:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> *mut ::std::os::raw::c_void>;
pub type HashAllocFunc =
    ::std::option::Option<extern "C" fn(request: Size)
                              -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HASHELEMENT {
    pub link: *mut Struct_HASHELEMENT,
    pub hashvalue: uint32,
}
impl ::std::clone::Clone for Struct_HASHELEMENT {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HASHELEMENT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASHELEMENT = Struct_HASHELEMENT;
pub enum Struct_HASHHDR { }
pub type HASHHDR = Struct_HASHHDR;
pub enum Struct_HTAB { }
pub type HTAB = Struct_HTAB;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub ffactor: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub _match: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
impl ::std::clone::Clone for Struct_HASHCTL {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_HASHCTL {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASHCTL = Struct_HASHCTL;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed41 {
    HASH_FIND = 0,
    HASH_ENTER = 1,
    HASH_REMOVE = 2,
    HASH_ENTER_NULL = 3,
}
pub type HASHACTION = Enum_Unnamed41;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed42 {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
impl ::std::clone::Clone for Struct_Unnamed42 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed42 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HASH_SEQ_STATUS = Struct_Unnamed42;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_am {
    pub amname: NameData,
    pub amstrategies: int16,
    pub amsupport: int16,
    pub amcanorder: _bool,
    pub amcanorderbyop: _bool,
    pub amcanbackward: _bool,
    pub amcanunique: _bool,
    pub amcanmulticol: _bool,
    pub amoptionalkey: _bool,
    pub amsearcharray: _bool,
    pub amsearchnulls: _bool,
    pub amstorage: _bool,
    pub amclusterable: _bool,
    pub ampredlocks: _bool,
    pub amkeytype: Oid,
    pub aminsert: regproc,
    pub ambeginscan: regproc,
    pub amgettuple: regproc,
    pub amgetbitmap: regproc,
    pub amrescan: regproc,
    pub amendscan: regproc,
    pub ammarkpos: regproc,
    pub amrestrpos: regproc,
    pub ambuild: regproc,
    pub ambuildempty: regproc,
    pub ambulkdelete: regproc,
    pub amvacuumcleanup: regproc,
    pub amcanreturn: regproc,
    pub amcostestimate: regproc,
    pub amoptions: regproc,
}
impl ::std::clone::Clone for Struct_FormData_pg_am {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_am {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_am = Struct_FormData_pg_am;
pub type Form_pg_am = *mut FormData_pg_am;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_class {
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: _bool,
    pub relisshared: _bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasoids: _bool,
    pub relhaspkey: _bool,
    pub relhasrules: _bool,
    pub relhastriggers: _bool,
    pub relhassubclass: _bool,
    pub relrowsecurity: _bool,
    pub relforcerowsecurity: _bool,
    pub relispopulated: _bool,
    pub relreplident: ::std::os::raw::c_char,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
impl ::std::clone::Clone for Struct_FormData_pg_class {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_class {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_class = Struct_FormData_pg_class;
pub type Form_pg_class = *mut FormData_pg_class;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indisunique: _bool,
    pub indisprimary: _bool,
    pub indisexclusion: _bool,
    pub indimmediate: _bool,
    pub indisclustered: _bool,
    pub indisvalid: _bool,
    pub indcheckxmin: _bool,
    pub indisready: _bool,
    pub indislive: _bool,
    pub indisreplident: _bool,
    pub indkey: int2vector,
}
impl ::std::clone::Clone for Struct_FormData_pg_index {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_FormData_pg_index {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FormData_pg_index = Struct_FormData_pg_index;
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::std::os::raw::c_char,
    pub isInstead: _bool,
}
impl ::std::clone::Clone for Struct_RewriteRule {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RewriteRule {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RewriteRule = Struct_RewriteRule;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RuleLock {
    pub numLocks: ::std::os::raw::c_int,
    pub rules: *mut *mut RewriteRule,
}
impl ::std::clone::Clone for Struct_RuleLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RuleLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RuleLock = Struct_RuleLock;
pub type Relation = *mut Struct_RelationData;
pub type RelationPtr = *mut Relation;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_IndexAttrBitmapKind {
    INDEX_ATTR_BITMAP_ALL = 0,
    INDEX_ATTR_BITMAP_KEY = 1,
    INDEX_ATTR_BITMAP_IDENTITY_KEY = 2,
}
pub type IndexAttrBitmapKind = Enum_IndexAttrBitmapKind;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::std::os::raw::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: _bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: _bool,
    pub tginitdeferred: _bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::std::os::raw::c_char,
    pub tgqual: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_Trigger {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Trigger {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Trigger = Struct_Trigger;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: _bool,
    pub trig_insert_after_row: _bool,
    pub trig_insert_instead_row: _bool,
    pub trig_insert_before_statement: _bool,
    pub trig_insert_after_statement: _bool,
    pub trig_update_before_row: _bool,
    pub trig_update_after_row: _bool,
    pub trig_update_instead_row: _bool,
    pub trig_update_before_statement: _bool,
    pub trig_update_after_statement: _bool,
    pub trig_delete_before_row: _bool,
    pub trig_delete_after_row: _bool,
    pub trig_delete_instead_row: _bool,
    pub trig_delete_before_statement: _bool,
    pub trig_delete_after_statement: _bool,
    pub trig_truncate_before_statement: _bool,
    pub trig_truncate_after_statement: _bool,
}
impl ::std::clone::Clone for Struct_TriggerDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_TriggerDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TriggerDesc = Struct_TriggerDesc;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
impl ::std::clone::Clone for Struct_LockRelId {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockRelId {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockRelId = Struct_LockRelId;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LockInfoData {
    pub lockRelId: LockRelId,
}
impl ::std::clone::Clone for Struct_LockInfoData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LockInfoData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LockInfoData = Struct_LockInfoData;
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelationAmInfo {
    pub aminsert: FmgrInfo,
    pub ambeginscan: FmgrInfo,
    pub amgettuple: FmgrInfo,
    pub amgetbitmap: FmgrInfo,
    pub amrescan: FmgrInfo,
    pub amendscan: FmgrInfo,
    pub ammarkpos: FmgrInfo,
    pub amrestrpos: FmgrInfo,
    pub amcanreturn: FmgrInfo,
}
impl ::std::clone::Clone for Struct_RelationAmInfo {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelationAmInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelationAmInfo = Struct_RelationAmInfo;
pub enum Struct_SMgrRelationData { }
pub enum Struct_RowSecurityDesc { }
pub enum Struct_FdwRoutine { }
pub enum Struct_PgStat_TableStatus { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: *mut Struct_SMgrRelationData,
    pub rd_refcnt: ::std::os::raw::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: _bool,
    pub rd_isnailed: _bool,
    pub rd_isvalid: _bool,
    pub rd_indexvalid: ::std::os::raw::c_char,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_rsdesc: *mut Struct_RowSecurityDesc,
    pub rd_indexlist: *mut List,
    pub rd_oidindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_indexattr: *mut Bitmapset,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_options: *mut bytea,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut Struct_HeapTupleData,
    pub rd_am: Form_pg_am,
    pub rd_indexcxt: MemoryContext,
    pub rd_aminfo: *mut RelationAmInfo,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_amcache: *mut ::std::os::raw::c_void,
    pub rd_indcollation: *mut Oid,
    pub rd_fdwroutine: *mut Struct_FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_info: *mut Struct_PgStat_TableStatus,
}
impl ::std::clone::Clone for Struct_RelationData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RelationData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RelationData = Struct_RelationData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_AutoVacOpts {
    pub enabled: _bool,
    pub vacuum_threshold: ::std::os::raw::c_int,
    pub analyze_threshold: ::std::os::raw::c_int,
    pub vacuum_cost_delay: ::std::os::raw::c_int,
    pub vacuum_cost_limit: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_max_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_max_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub log_min_duration: ::std::os::raw::c_int,
    pub vacuum_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
impl ::std::clone::Clone for Struct_AutoVacOpts {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_AutoVacOpts {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type AutoVacOpts = Struct_AutoVacOpts;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::std::os::raw::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: _bool,
}
impl ::std::clone::Clone for Struct_StdRdOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_StdRdOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type StdRdOptions = Struct_StdRdOptions;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: _bool,
    pub check_option_offset: ::std::os::raw::c_int,
}
impl ::std::clone::Clone for Struct_ViewOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ViewOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ViewOptions = Struct_ViewOptions;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pairingheap_node {
    pub first_child: *mut Struct_pairingheap_node,
    pub next_sibling: *mut Struct_pairingheap_node,
    pub prev_or_parent: *mut Struct_pairingheap_node,
}
impl ::std::clone::Clone for Struct_pairingheap_node {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pairingheap_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pairingheap_node = Struct_pairingheap_node;
pub type pairingheap_comparator =
    ::std::option::Option<unsafe extern "C" fn(a: *const pairingheap_node,
                                               b: *const pairingheap_node,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pairingheap {
    pub ph_compare: pairingheap_comparator,
    pub ph_arg: *mut ::std::os::raw::c_void,
    pub ph_root: *mut pairingheap_node,
}
impl ::std::clone::Clone for Struct_pairingheap {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pairingheap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pairingheap = Struct_pairingheap;
pub type Buffer = ::std::os::raw::c_int;
pub enum Struct_BufferAccessStrategyData { }
pub type BufferAccessStrategy = *mut Struct_BufferAccessStrategyData;
pub type Snapshot = *mut Struct_SnapshotData;
pub type SnapshotSatisfiesFunc =
    ::std::option::Option<extern "C" fn(htup: HeapTuple, snapshot: Snapshot,
                                        buffer: Buffer) -> _bool>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SnapshotData {
    pub satisfies: SnapshotSatisfiesFunc,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxip: *mut TransactionId,
    pub subxcnt: int32,
    pub suboverflowed: _bool,
    pub takenDuringRecovery: _bool,
    pub copied: _bool,
    pub curcid: CommandId,
    pub speculativeToken: uint32,
    pub active_count: uint32,
    pub regd_count: uint32,
    pub ph_node: pairingheap_node,
}
impl ::std::clone::Clone for Struct_SnapshotData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SnapshotData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SnapshotData = Struct_SnapshotData;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed43 {
    HeapTupleMayBeUpdated = 0,
    HeapTupleInvisible = 1,
    HeapTupleSelfUpdated = 2,
    HeapTupleUpdated = 3,
    HeapTupleBeingUpdated = 4,
    HeapTupleWouldBlock = 5,
}
pub type HTSU_Result = Enum_Unnamed43;
pub type float_t = ::std::os::raw::c_float;
pub type double_t = ::std::os::raw::c_double;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___float2 {
    pub __sinval: ::std::os::raw::c_float,
    pub __cosval: ::std::os::raw::c_float,
}
impl ::std::clone::Clone for Struct___float2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___float2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct___double2 {
    pub __sinval: ::std::os::raw::c_double,
    pub __cosval: ::std::os::raw::c_double,
}
impl ::std::clone::Clone for Struct___double2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___double2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_exception {
    pub _type: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: ::std::os::raw::c_double,
    pub arg2: ::std::os::raw::c_double,
    pub retval: ::std::os::raw::c_double,
}
impl ::std::clone::Clone for Struct_exception {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_exception {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed44 {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
impl ::std::clone::Clone for Struct_Unnamed44 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed44 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Interval = Struct_Unnamed44;
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pg_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_pg_tm {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pg_tm {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_pg_tz { }
pub type pg_tz = Struct_pg_tz;
pub enum Struct_pg_tzenum { }
pub type pg_tzenum = Struct_pg_tzenum;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferTupleBuf {
    pub node: slist_node,
    pub tuple: HeapTupleData,
    pub t_data: Union_Unnamed45,
}
impl ::std::clone::Clone for Struct_ReorderBufferTupleBuf {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferTupleBuf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed45 {
    pub _bindgen_data_: [u64; 1020usize],
}
impl Union_Unnamed45 {
    pub unsafe fn header(&mut self) -> *mut HeapTupleHeaderData {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn data(&mut self)
     -> *mut [::std::os::raw::c_char; 8160usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn align_it(&mut self) -> *mut ::std::os::raw::c_double {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed45 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed45 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferTupleBuf = Struct_ReorderBufferTupleBuf;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ReorderBufferChangeType {
    REORDER_BUFFER_CHANGE_INSERT = 0,
    REORDER_BUFFER_CHANGE_UPDATE = 1,
    REORDER_BUFFER_CHANGE_DELETE = 2,
    REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT = 3,
    REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID = 4,
    REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID = 5,
    REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT = 6,
    REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM = 7,
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferChange {
    pub lsn: XLogRecPtr,
    pub action: Enum_ReorderBufferChangeType,
    pub origin_id: RepOriginId,
    pub data: Union_Unnamed46,
    pub node: dlist_node,
}
impl ::std::clone::Clone for Struct_ReorderBufferChange {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferChange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed46 {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_Unnamed46 {
    pub unsafe fn tp(&mut self) -> *mut Struct_Unnamed47 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn snapshot(&mut self) -> *mut Snapshot {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn command_id(&mut self) -> *mut CommandId {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn tuplecid(&mut self) -> *mut Struct_Unnamed48 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed46 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed46 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed47 {
    pub relnode: RelFileNode,
    pub clear_toast_afterwards: _bool,
    pub oldtuple: *mut ReorderBufferTupleBuf,
    pub newtuple: *mut ReorderBufferTupleBuf,
}
impl ::std::clone::Clone for Struct_Unnamed47 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed47 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed48 {
    pub node: RelFileNode,
    pub tid: ItemPointerData,
    pub cmin: CommandId,
    pub cmax: CommandId,
    pub combocid: CommandId,
}
impl ::std::clone::Clone for Struct_Unnamed48 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed48 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferChange = Struct_ReorderBufferChange;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBufferTXN {
    pub xid: TransactionId,
    pub has_catalog_changes: _bool,
    pub is_known_as_subxact: _bool,
    pub first_lsn: XLogRecPtr,
    pub final_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub restart_decoding_lsn: XLogRecPtr,
    pub origin_id: RepOriginId,
    pub origin_lsn: XLogRecPtr,
    pub commit_time: TimestampTz,
    pub base_snapshot: Snapshot,
    pub base_snapshot_lsn: XLogRecPtr,
    pub nentries: uint64,
    pub nentries_mem: uint64,
    pub changes: dlist_head,
    pub tuplecids: dlist_head,
    pub ntuplecids: uint64,
    pub tuplecid_hash: *mut HTAB,
    pub toast_hash: *mut HTAB,
    pub subtxns: dlist_head,
    pub nsubtxns: uint32,
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
    pub node: dlist_node,
}
impl ::std::clone::Clone for Struct_ReorderBufferTXN {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBufferTXN {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReorderBufferTXN = Struct_ReorderBufferTXN;
pub type ReorderBuffer = Struct_ReorderBuffer;
pub type ReorderBufferApplyChangeCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN,
                                               relation: Relation,
                                               change:
                                                   *mut ReorderBufferChange)>;
pub type ReorderBufferBeginCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN)>;
pub type ReorderBufferCommitCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer,
                                               txn: *mut ReorderBufferTXN,
                                               commit_lsn: XLogRecPtr)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReorderBuffer {
    pub by_txn: *mut HTAB,
    pub toplevel_by_lsn: dlist_head,
    pub by_txn_last_xid: TransactionId,
    pub by_txn_last_txn: *mut ReorderBufferTXN,
    pub begin: ReorderBufferBeginCB,
    pub apply_change: ReorderBufferApplyChangeCB,
    pub commit: ReorderBufferCommitCB,
    pub private_data: *mut ::std::os::raw::c_void,
    pub context: MemoryContext,
    pub cached_transactions: dlist_head,
    pub nr_cached_transactions: Size,
    pub cached_changes: dlist_head,
    pub nr_cached_changes: Size,
    pub cached_tuplebufs: slist_head,
    pub nr_cached_tuplebufs: Size,
    pub current_restart_decoding_lsn: XLogRecPtr,
    pub outbuf: *mut ::std::os::raw::c_char,
    pub outbufsize: Size,
}
impl ::std::clone::Clone for Struct_ReorderBuffer {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReorderBuffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_OutputPluginOutputType {
    OUTPUT_PLUGIN_BINARY_OUTPUT = 0,
    OUTPUT_PLUGIN_TEXTUAL_OUTPUT = 1,
}
pub type OutputPluginOutputType = Enum_OutputPluginOutputType;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OutputPluginOptions {
    pub output_type: OutputPluginOutputType,
}
impl ::std::clone::Clone for Struct_OutputPluginOptions {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OutputPluginOptions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputPluginOptions = Struct_OutputPluginOptions;
pub type LogicalOutputPluginInit =
    ::std::option::Option<unsafe extern "C" fn(cb:
                                                   *mut Struct_OutputPluginCallbacks)>;
pub type LogicalDecodeStartupCB =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut Struct_LogicalDecodingContext,
                                               options:
                                                   *mut OutputPluginOptions,
                                               is_init: _bool)>;
pub type LogicalDecodeBeginCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN)>;
pub type LogicalDecodeChangeCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN,
                                               relation: Relation,
                                               change:
                                                   *mut ReorderBufferChange)>;
pub type LogicalDecodeCommitCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext,
                                               txn: *mut ReorderBufferTXN,
                                               commit_lsn: XLogRecPtr)>;
pub type LogicalDecodeFilterByOriginCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext,
                                               origin_id: RepOriginId)
                              -> _bool>;
pub type LogicalDecodeShutdownCB =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut Struct_LogicalDecodingContext)>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_OutputPluginCallbacks {
    pub startup_cb: LogicalDecodeStartupCB,
    pub begin_cb: LogicalDecodeBeginCB,
    pub change_cb: LogicalDecodeChangeCB,
    pub commit_cb: LogicalDecodeCommitCB,
    pub filter_by_origin_cb: LogicalDecodeFilterByOriginCB,
    pub shutdown_cb: LogicalDecodeShutdownCB,
}
impl ::std::clone::Clone for Struct_OutputPluginCallbacks {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_OutputPluginCallbacks {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputPluginCallbacks = Struct_OutputPluginCallbacks;
pub type RmgrId = uint8;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_RmgrIds {
    RM_XLOG_ID = 0,
    RM_XACT_ID = 1,
    RM_SMGR_ID = 2,
    RM_CLOG_ID = 3,
    RM_DBASE_ID = 4,
    RM_TBLSPC_ID = 5,
    RM_MULTIXACT_ID = 6,
    RM_RELMAP_ID = 7,
    RM_STANDBY_ID = 8,
    RM_HEAP2_ID = 9,
    RM_HEAP_ID = 10,
    RM_BTREE_ID = 11,
    RM_HASH_ID = 12,
    RM_GIN_ID = 13,
    RM_GIST_ID = 14,
    RM_SEQ_ID = 15,
    RM_SPGIST_ID = 16,
    RM_BRIN_ID = 17,
    RM_COMMIT_TS_ID = 18,
    RM_REPLORIGIN_ID = 19,
    RM_NEXT_ID = 20,
}
pub type RmgrIds = Enum_RmgrIds;
pub type pg_crc32c = uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_prev: XLogRecPtr,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_crc: pg_crc32c,
}
impl ::std::clone::Clone for Struct_XLogRecord {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecord {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecord = Struct_XLogRecord;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecordBlockHeader {
    pub id: uint8,
    pub fork_flags: uint8,
    pub data_length: uint16,
}
impl ::std::clone::Clone for Struct_XLogRecordBlockHeader {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecordBlockHeader {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecordBlockHeader = Struct_XLogRecordBlockHeader;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecordBlockImageHeader {
    pub length: uint16,
    pub hole_offset: uint16,
    pub bimg_info: uint8,
}
impl ::std::clone::Clone for Struct_XLogRecordBlockImageHeader {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecordBlockImageHeader {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecordBlockImageHeader = Struct_XLogRecordBlockImageHeader;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecordBlockCompressHeader {
    pub hole_length: uint16,
}
impl ::std::clone::Clone for Struct_XLogRecordBlockCompressHeader {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecordBlockCompressHeader {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecordBlockCompressHeader = Struct_XLogRecordBlockCompressHeader;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecordDataHeaderShort {
    pub id: uint8,
    pub data_length: uint8,
}
impl ::std::clone::Clone for Struct_XLogRecordDataHeaderShort {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecordDataHeaderShort {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecordDataHeaderShort = Struct_XLogRecordDataHeaderShort;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogRecordDataHeaderLong {
    pub id: uint8,
}
impl ::std::clone::Clone for Struct_XLogRecordDataHeaderLong {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogRecordDataHeaderLong {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type XLogRecordDataHeaderLong = Struct_XLogRecordDataHeaderLong;
pub type XLogReaderState = Struct_XLogReaderState;
pub type XLogPageReadCB =
    ::std::option::Option<unsafe extern "C" fn(xlogreader:
                                                   *mut XLogReaderState,
                                               targetPagePtr: XLogRecPtr,
                                               reqLen: ::std::os::raw::c_int,
                                               targetRecPtr: XLogRecPtr,
                                               readBuf:
                                                   *mut ::std::os::raw::c_char,
                                               pageTLI: *mut TimeLineID)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed49 {
    pub in_use: _bool,
    pub rnode: RelFileNode,
    pub forknum: ForkNumber,
    pub blkno: BlockNumber,
    pub flags: uint8,
    pub has_image: _bool,
    pub bkp_image: *mut ::std::os::raw::c_char,
    pub hole_offset: uint16,
    pub hole_length: uint16,
    pub bimg_len: uint16,
    pub bimg_info: uint8,
    pub has_data: _bool,
    pub data: *mut ::std::os::raw::c_char,
    pub data_len: uint16,
    pub data_bufsz: uint16,
}
impl ::std::clone::Clone for Struct_Unnamed49 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed49 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DecodedBkpBlock = Struct_Unnamed49;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_XLogReaderState {
    pub read_page: XLogPageReadCB,
    pub system_identifier: uint64,
    pub private_data: *mut ::std::os::raw::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub decoded_record: *mut XLogRecord,
    pub main_data: *mut ::std::os::raw::c_char,
    pub main_data_len: uint32,
    pub main_data_bufsz: uint32,
    pub record_origin: RepOriginId,
    pub blocks: [DecodedBkpBlock; 33usize],
    pub max_block_id: ::std::os::raw::c_int,
    pub readBuf: *mut ::std::os::raw::c_char,
    pub readSegNo: XLogSegNo,
    pub readOff: uint32,
    pub readLen: uint32,
    pub readPageTLI: TimeLineID,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub readRecordBuf: *mut ::std::os::raw::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_XLogReaderState {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_XLogReaderState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 1024usize],
}
impl ::std::clone::Clone for Struct_dirent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_dirent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct__telldir { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed50 {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: *mut ::std::os::raw::c_char,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __dd_rewind: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut Struct__telldir,
}
impl ::std::clone::Clone for Struct_Unnamed50 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed50 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DIR = Struct_Unnamed50;
pub type FileName = *mut ::std::os::raw::c_char;
pub type File = ::std::os::raw::c_int;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed51 {
    STANDBY_DISABLED = 0,
    STANDBY_INITIALIZED = 1,
    STANDBY_SNAPSHOT_PENDING = 2,
    STANDBY_SNAPSHOT_READY = 3,
}
pub type HotStandbyState = Enum_Unnamed51;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_Unnamed52 {
    RECOVERY_TARGET_UNSET = 0,
    RECOVERY_TARGET_XID = 1,
    RECOVERY_TARGET_TIME = 2,
    RECOVERY_TARGET_NAME = 3,
    RECOVERY_TARGET_IMMEDIATE = 4,
}
pub type RecoveryTargetType = Enum_Unnamed52;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ArchiveMode {
    ARCHIVE_MODE_OFF = 0,
    ARCHIVE_MODE_ON = 1,
    ARCHIVE_MODE_ALWAYS = 2,
}
pub type ArchiveMode = Enum_ArchiveMode;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_WalLevel {
    WAL_LEVEL_MINIMAL = 0,
    WAL_LEVEL_ARCHIVE = 1,
    WAL_LEVEL_HOT_STANDBY = 2,
    WAL_LEVEL_LOGICAL = 3,
}
pub type WalLevel = Enum_WalLevel;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::std::os::raw::c_int,
    pub ckpt_segs_added: ::std::os::raw::c_int,
    pub ckpt_segs_removed: ::std::os::raw::c_int,
    pub ckpt_segs_recycled: ::std::os::raw::c_int,
    pub ckpt_sync_rels: ::std::os::raw::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
impl ::std::clone::Clone for Struct_CheckpointStatsData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_CheckpointStatsData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CheckpointStatsData = Struct_CheckpointStatsData;
pub enum Struct_XLogRecData { }
pub type slock_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pg_atomic_flag {
    pub value: ::std::os::raw::c_char,
}
impl ::std::clone::Clone for Struct_pg_atomic_flag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pg_atomic_flag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pg_atomic_flag = Struct_pg_atomic_flag;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pg_atomic_uint32 {
    pub value: uint32,
}
impl ::std::clone::Clone for Struct_pg_atomic_uint32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pg_atomic_uint32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pg_atomic_uint32 = Struct_pg_atomic_uint32;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_pg_atomic_uint64 {
    pub value: uint64,
}
impl ::std::clone::Clone for Struct_pg_atomic_uint64 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_pg_atomic_uint64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pg_atomic_uint64 = Struct_pg_atomic_uint64;
pub enum Struct_PGPROC { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LWLockTranche {
    pub name: *const ::std::os::raw::c_char,
    pub array_base: *mut ::std::os::raw::c_void,
    pub array_stride: Size,
}
impl ::std::clone::Clone for Struct_LWLockTranche {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LWLockTranche {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLockTranche = Struct_LWLockTranche;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LWLock {
    pub mutex: slock_t,
    pub tranche: uint16,
    pub state: pg_atomic_uint32,
    pub waiters: dlist_head,
}
impl ::std::clone::Clone for Struct_LWLock {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LWLock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLock = Struct_LWLock;
#[repr(C)]
#[derive(Copy)]
pub struct Union_LWLockPadded {
    pub _bindgen_data_: [u64; 4usize],
}
impl Union_LWLockPadded {
    pub unsafe fn lock(&mut self) -> *mut LWLock {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn pad(&mut self) -> *mut [::std::os::raw::c_char; 32usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_LWLockPadded {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_LWLockPadded {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LWLockPadded = Union_LWLockPadded;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_LWLockMode {
    LW_EXCLUSIVE = 0,
    LW_SHARED = 1,
    LW_WAIT_UNTIL_FREE = 2,
}
pub type LWLockMode = Enum_LWLockMode;
pub type LWLockId = *mut LWLock;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_SHM_QUEUE {
    pub prev: *mut Struct_SHM_QUEUE,
    pub next: *mut Struct_SHM_QUEUE,
}
impl ::std::clone::Clone for Struct_SHM_QUEUE {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_SHM_QUEUE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SHM_QUEUE = Struct_SHM_QUEUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed53 {
    pub key: [::std::os::raw::c_char; 48usize],
    pub location: *mut ::std::os::raw::c_void,
    pub size: Size,
}
impl ::std::clone::Clone for Struct_Unnamed53 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed53 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ShmemIndexEnt = Struct_Unnamed53;
#[derive(Clone, Copy)]
#[repr(u32)]
pub enum Enum_ReplicationSlotPersistency {
    RS_PERSISTENT = 0,
    RS_EPHEMERAL = 1,
}
pub type ReplicationSlotPersistency = Enum_ReplicationSlotPersistency;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlotPersistentData {
    pub name: NameData,
    pub database: Oid,
    pub persistency: ReplicationSlotPersistency,
    pub xmin: TransactionId,
    pub catalog_xmin: TransactionId,
    pub restart_lsn: XLogRecPtr,
    pub confirmed_flush: XLogRecPtr,
    pub plugin: NameData,
}
impl ::std::clone::Clone for Struct_ReplicationSlotPersistentData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlotPersistentData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlotPersistentData = Struct_ReplicationSlotPersistentData;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlot {
    pub mutex: slock_t,
    pub in_use: _bool,
    pub active_pid: pid_t,
    pub just_dirtied: _bool,
    pub dirty: _bool,
    pub effective_xmin: TransactionId,
    pub effective_catalog_xmin: TransactionId,
    pub data: ReplicationSlotPersistentData,
    pub io_in_progress_lock: *mut LWLock,
    pub candidate_catalog_xmin: TransactionId,
    pub candidate_xmin_lsn: XLogRecPtr,
    pub candidate_restart_valid: XLogRecPtr,
    pub candidate_restart_lsn: XLogRecPtr,
}
impl ::std::clone::Clone for Struct_ReplicationSlot {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlot {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlot = Struct_ReplicationSlot;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ReplicationSlotCtlData {
    pub replication_slots: [ReplicationSlot; 1usize],
}
impl ::std::clone::Clone for Struct_ReplicationSlotCtlData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ReplicationSlotCtlData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ReplicationSlotCtlData = Struct_ReplicationSlotCtlData;
pub type LogicalOutputPluginWriterWrite =
    ::std::option::Option<unsafe extern "C" fn(lr:
                                                   *mut Struct_LogicalDecodingContext,
                                               Ptr: XLogRecPtr,
                                               xid: TransactionId,
                                               last_write: _bool)>;
pub type LogicalOutputPluginWriterPrepareWrite =
    LogicalOutputPluginWriterWrite;
pub enum Struct_SnapBuild { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_LogicalDecodingContext {
    pub context: MemoryContext,
    pub reader: *mut XLogReaderState,
    pub slot: *mut ReplicationSlot,
    pub reorder: *mut Struct_ReorderBuffer,
    pub snapshot_builder: *mut Struct_SnapBuild,
    pub callbacks: OutputPluginCallbacks,
    pub options: OutputPluginOptions,
    pub output_plugin_options: *mut List,
    pub prepare_write: LogicalOutputPluginWriterPrepareWrite,
    pub write: LogicalOutputPluginWriterWrite,
    pub out: StringInfo,
    pub output_plugin_private: *mut ::std::os::raw::c_void,
    pub output_writer_private: *mut ::std::os::raw::c_void,
    pub accept_writes: _bool,
    pub prepared_write: _bool,
    pub write_location: XLogRecPtr,
    pub write_xid: TransactionId,
}
impl ::std::clone::Clone for Struct_LogicalDecodingContext {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_LogicalDecodingContext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type LogicalDecodingContext = Struct_LogicalDecodingContext;
pub type __builtin_va_list = [__va_list_tag; 1usize];
pub type __va_list_tag = Struct___va_list_tag;
#[repr(C)]
#[derive(Copy)]
pub struct Struct___va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl ::std::clone::Clone for Struct___va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct___va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub static mut __stdinp: *mut FILE;
    pub static mut __stdoutp: *mut FILE;
    pub static mut __stderrp: *mut FILE;
    pub static sys_nerr: ::std::os::raw::c_int;
    pub static mut sys_errlist: *const *const ::std::os::raw::c_char;
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
    pub static mut _DefaultRuneLocale: _RuneLocale;
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
    pub static in6addr_any: Struct_in6_addr;
    pub static in6addr_loopback: Struct_in6_addr;
    pub static in6addr_nodelocal_allnodes: Struct_in6_addr;
    pub static in6addr_linklocal_allnodes: Struct_in6_addr;
    pub static in6addr_linklocal_allrouters: Struct_in6_addr;
    pub static in6addr_linklocal_allv2routers: Struct_in6_addr;
    pub static mut h_errno: ::std::os::raw::c_int;
    pub static mut error_context_stack: *mut ErrorContextCallback;
    pub static mut PG_exception_stack: *mut sigjmp_buf;
    pub static mut emit_log_hook: emit_log_hook_type;
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
    pub static mut Log_line_prefix: *mut ::std::os::raw::c_char;
    pub static mut Log_destination: ::std::os::raw::c_int;
    pub static mut Log_destination_string: *mut ::std::os::raw::c_char;
    pub static mut CurrentMemoryContext: MemoryContext;
    pub static mut Dynamic_library_path: *mut ::std::os::raw::c_char;
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
    pub static mut fmgr_hook: fmgr_hook_type;
    pub static mut extra_float_digits: ::std::os::raw::c_int;
    pub static mut quote_all_identifiers: _bool;
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
    pub static mut ShmemVariableCache: VariableCache;
    pub static mut sys_signame: [*const ::std::os::raw::c_char; 32usize];
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 32usize];
    pub static mut forkNames: *const *const ::std::os::raw::c_char;
    pub static mut MyBackendId: BackendId;
    pub static mut SharedInvalidMessageCounter: uint64;
    pub static mut catchupInterruptPending: sig_atomic_t;
    pub static mut no_such_variable: ::std::os::raw::c_int;
    pub static mut criticalRelcachesBuilt: _bool;
    pub static mut criticalSharedRelcachesBuilt: _bool;
    pub static mut signgam: ::std::os::raw::c_int;
    pub static mut session_timezone: *mut pg_tz;
    pub static mut log_timezone: *mut pg_tz;
    pub static mut PgStartTime: TimestampTz;
    pub static mut PgReloadTime: TimestampTz;
    pub static mut pg_comp_crc32c:
               ::std::option::Option<unsafe extern "C" fn(crc: pg_crc32c,
                                                          data:
                                                              *const ::std::os::raw::c_void,
                                                          len: size_t)
                                         -> pg_crc32c>;
    pub static mut max_files_per_process: ::std::os::raw::c_int;
    pub static mut max_safe_fds: ::std::os::raw::c_int;
    pub static mut sync_method: ::std::os::raw::c_int;
    pub static mut ThisTimeLineID: TimeLineID;
    pub static mut InRecovery: _bool;
    pub static mut standbyState: HotStandbyState;
    pub static mut XactLastRecEnd: XLogRecPtr;
    pub static mut XactLastCommitEnd: XLogRecPtr;
    pub static mut reachedConsistency: _bool;
    pub static mut min_wal_size: ::std::os::raw::c_int;
    pub static mut max_wal_size: ::std::os::raw::c_int;
    pub static mut wal_keep_segments: ::std::os::raw::c_int;
    pub static mut XLOGbuffers: ::std::os::raw::c_int;
    pub static mut XLogArchiveTimeout: ::std::os::raw::c_int;
    pub static mut wal_retrieve_retry_interval: ::std::os::raw::c_int;
    pub static mut XLogArchiveCommand: *mut ::std::os::raw::c_char;
    pub static mut EnableHotStandby: _bool;
    pub static mut fullPageWrites: _bool;
    pub static mut wal_log_hints: _bool;
    pub static mut wal_compression: _bool;
    pub static mut log_checkpoints: _bool;
    pub static mut CheckPointSegments: ::std::os::raw::c_int;
    pub static mut XLogArchiveMode: ::std::os::raw::c_int;
    pub static mut wal_level: ::std::os::raw::c_int;
    pub static mut CheckpointStats: CheckpointStatsData;
    pub static mut dummy_spinlock: slock_t;
    pub static mut MainLWLockArray: *mut LWLockPadded;
    pub static mut ReplicationSlotCtl: *mut ReplicationSlotCtlData;
    pub static mut MyReplicationSlot: *mut ReplicationSlot;
    pub static mut max_replication_slots: ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn clearerr(arg1: *mut FILE);
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
    pub fn fopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn fread(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                 arg3: size_t, arg4: *mut FILE) -> size_t;
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
    pub fn fwrite(arg1: *const ::std::os::raw::c_void, arg2: size_t,
                  arg3: size_t, arg4: *mut FILE) -> size_t;
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar() -> ::std::os::raw::c_int;
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn perror(arg1: *const ::std::os::raw::c_char);
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rename(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn rewind(arg1: *mut FILE);
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: size_t)
     -> ::std::os::raw::c_int;
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: va_list) -> ::std::os::raw::c_int;
    pub fn vprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list)
     -> ::std::os::raw::c_int;
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, arg3: va_list)
     -> ::std::os::raw::c_int;
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: va_list) -> ::std::os::raw::c_int;
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn __sputc(_c: ::std::os::raw::c_int, _p: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn flockfile(arg1: *mut FILE);
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn funlockfile(arg1: *mut FILE);
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
    pub fn tempnam(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ftello(arg1: *mut FILE) -> off_t;
    pub fn snprintf(arg1: *mut ::std::os::raw::c_char, arg2: size_t,
                    arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                   arg3: va_list) -> ::std::os::raw::c_int;
    pub fn vscanf(arg1: *const ::std::os::raw::c_char, arg2: va_list)
     -> ::std::os::raw::c_int;
    pub fn vsnprintf(arg1: *mut ::std::os::raw::c_char, arg2: size_t,
                     arg3: *const ::std::os::raw::c_char, arg4: va_list)
     -> ::std::os::raw::c_int;
    pub fn vsscanf(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: va_list)
     -> ::std::os::raw::c_int;
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char, arg3: va_list)
     -> ::std::os::raw::c_int;
    pub fn getdelim(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut size_t,
                    arg3: ::std::os::raw::c_int, arg4: *mut FILE) -> ssize_t;
    pub fn getline(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut size_t,
                   arg3: *mut FILE) -> ssize_t;
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char, arg3: va_list)
     -> ::std::os::raw::c_int;
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: size_t,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: size_t,
                          arg3: ::std::os::raw::c_int, arg4: size_t,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: size_t,
                          arg4: *const ::std::os::raw::c_char, arg5: va_list)
     -> ::std::os::raw::c_int;
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: size_t,
                           arg3: ::std::os::raw::c_int, arg4: size_t,
                           arg5: *const ::std::os::raw::c_char, arg6: va_list)
     -> ::std::os::raw::c_int;
    pub fn signal(arg1: ::std::os::raw::c_int,
                  arg2:
                      ::std::option::Option<extern "C" fn(arg1:
                                                              ::std::os::raw::c_int)>)
     ->
         ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int,
                                             arg2:
                                                 ::std::option::Option<extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int)>)>;
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t)
     -> ::std::os::raw::c_int;
    pub fn getiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut Struct_rlimit)
     -> ::std::os::raw::c_int;
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut Struct_rusage)
     -> ::std::os::raw::c_int;
    pub fn setpriority(arg1: ::std::os::raw::c_int, arg2: id_t,
                       arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn setiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const Struct_rlimit)
     -> ::std::os::raw::c_int;
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
    pub fn waitpid(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int) -> pid_t;
    pub fn waitid(arg1: idtype_t, arg2: id_t, arg3: *mut siginfo_t,
                  arg4: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn wait3(arg1: *mut ::std::os::raw::c_int,
                 arg2: ::std::os::raw::c_int, arg3: *mut Struct_rusage)
     -> pid_t;
    pub fn wait4(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                 arg3: ::std::os::raw::c_int, arg4: *mut Struct_rusage)
     -> pid_t;
    pub fn alloca(arg1: size_t) -> *mut ::std::os::raw::c_void;
    pub fn abort();
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn atexit(arg1: ::std::option::Option<extern "C" fn()>)
     -> ::std::os::raw::c_int;
    pub fn atof(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn atol(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
    pub fn atoll(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
    pub fn bsearch(arg1: *const ::std::os::raw::c_void,
                   arg2: *const ::std::os::raw::c_void, arg3: size_t,
                   arg4: size_t,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
    pub fn calloc(arg1: size_t, arg2: size_t) -> *mut ::std::os::raw::c_void;
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> div_t;
    pub fn exit(arg1: ::std::os::raw::c_int);
    pub fn free(arg1: *mut ::std::os::raw::c_void);
    pub fn getenv(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long)
     -> ldiv_t;
    pub fn llabs(arg1: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
    pub fn lldiv(arg1: ::std::os::raw::c_longlong,
                 arg2: ::std::os::raw::c_longlong) -> lldiv_t;
    pub fn malloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: size_t)
     -> ::std::os::raw::c_int;
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                    arg3: size_t) -> size_t;
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                  arg3: size_t) -> ::std::os::raw::c_int;
    pub fn posix_memalign(arg1: *mut *mut ::std::os::raw::c_void,
                          arg2: size_t, arg3: size_t)
     -> ::std::os::raw::c_int;
    pub fn qsort(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                 arg3: size_t,
                 arg4:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
    pub fn rand() -> ::std::os::raw::c_int;
    pub fn realloc(arg1: *mut ::std::os::raw::c_void, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn srand(arg1: ::std::os::raw::c_uint);
    pub fn strtod(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn strtof(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn strtol(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn strtold(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn strtoll(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_longlong;
    pub fn strtoul(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
    pub fn strtoull(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn system(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t,
                    arg3: size_t) -> size_t;
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t)
     -> ::std::os::raw::c_int;
    pub fn _Exit(arg1: ::std::os::raw::c_int);
    pub fn a64l(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
    pub fn drand48() -> ::std::os::raw::c_double;
    pub fn ecvt(arg1: ::std::os::raw::c_double, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_double;
    pub fn fcvt(arg1: ::std::os::raw::c_double, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn gcvt(arg1: ::std::os::raw::c_double, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn getsubopt(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const *mut ::std::os::raw::c_char,
                     arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn initstate(arg1: ::std::os::raw::c_uint,
                     arg2: *mut ::std::os::raw::c_char, arg3: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
    pub fn lrand48() -> ::std::os::raw::c_long;
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn mrand48() -> ::std::os::raw::c_long;
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ptsname(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn random() -> ::std::os::raw::c_long;
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn realpath(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
    pub fn setenv(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
    pub fn setstate(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn srand48(arg1: ::std::os::raw::c_long);
    pub fn srandom(arg1: ::std::os::raw::c_uint);
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn arc4random() -> u_int32_t;
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar,
                                arg2: ::std::os::raw::c_int);
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
    pub fn arc4random_stir();
    pub fn arc4random_uniform(arg1: u_int32_t) -> u_int32_t;
    pub fn atexit_b(arg1: ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    pub fn bsearch_b(arg1: *const ::std::os::raw::c_void,
                     arg2: *const ::std::os::raw::c_void, arg3: size_t,
                     arg4: size_t, arg5: ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn cgetcap(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn cgetclose() -> ::std::os::raw::c_int;
    pub fn cgetent(arg1: *mut *mut ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn cgetfirst(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn cgetmatch(arg1: *const ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn cgetnext(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn cgetnum(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn cgetset(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn cgetstr(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn cgetustr(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn daemon(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
    pub fn devname_r(arg1: dev_t, arg2: mode_t,
                     buf: *mut ::std::os::raw::c_char,
                     len: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn getbsize(arg1: *mut ::std::os::raw::c_int,
                    arg2: *mut ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
    pub fn getloadavg(arg1: *mut ::std::os::raw::c_double,
                      arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getprogname() -> *const ::std::os::raw::c_char;
    pub fn heapsort(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                    arg3: size_t,
                    arg4:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
    pub fn heapsort_b(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                      arg3: size_t, arg4: ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn mergesort(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                     arg3: size_t,
                     arg4:
                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *const ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
    pub fn mergesort_b(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                       arg3: size_t, arg4: ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn psort(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                 arg3: size_t,
                 arg4:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
    pub fn psort_b(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                   arg3: size_t, arg4: ::std::os::raw::c_void);
    pub fn psort_r(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                   arg3: size_t, arg4: *mut ::std::os::raw::c_void,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
    pub fn qsort_b(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                   arg3: size_t, arg4: ::std::os::raw::c_void);
    pub fn qsort_r(arg1: *mut ::std::os::raw::c_void, arg2: size_t,
                   arg3: size_t, arg4: *mut ::std::os::raw::c_void,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
    pub fn radixsort(arg1: *mut *const ::std::os::raw::c_uchar,
                     arg2: ::std::os::raw::c_int,
                     arg3: *const ::std::os::raw::c_uchar,
                     arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
    pub fn sradixsort(arg1: *mut *const ::std::os::raw::c_uchar,
                      arg2: ::std::os::raw::c_int,
                      arg3: *const ::std::os::raw::c_uchar,
                      arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn sranddev();
    pub fn srandomdev();
    pub fn reallocf(arg1: *mut ::std::os::raw::c_void, arg2: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn strtoq(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_longlong;
    pub fn strtouq(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
    pub fn memchr(arg1: *const ::std::os::raw::c_void,
                  arg2: ::std::os::raw::c_int, arg3: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memcmp(arg1: *const ::std::os::raw::c_void,
                  arg2: *const ::std::os::raw::c_void, arg3: size_t)
     -> ::std::os::raw::c_int;
    pub fn memcpy(arg1: *mut ::std::os::raw::c_void,
                  arg2: *const ::std::os::raw::c_void, arg3: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memmove(arg1: *mut ::std::os::raw::c_void,
                   arg2: *const ::std::os::raw::c_void, arg3: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memset(arg1: *mut ::std::os::raw::c_void,
                  arg2: ::std::os::raw::c_int, arg3: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn strcat(arg1: *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strchr(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn strcmp(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strcoll(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strcpy(arg1: *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strcspn(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char) -> size_t;
    pub fn strerror(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> size_t;
    pub fn strncat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strncmp(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> ::std::os::raw::c_int;
    pub fn strncpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strpbrk(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strrchr(arg1: *const ::std::os::raw::c_char,
                   arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn strspn(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char) -> size_t;
    pub fn strstr(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strtok(arg1: *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strxfrm(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> size_t;
    pub fn strtok_r(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strerror_r(arg1: ::std::os::raw::c_int,
                      arg2: *mut ::std::os::raw::c_char, arg3: size_t)
     -> ::std::os::raw::c_int;
    pub fn strdup(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn memccpy(arg1: *mut ::std::os::raw::c_void,
                   arg2: *const ::std::os::raw::c_void,
                   arg3: ::std::os::raw::c_int, arg4: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn stpcpy(arg1: *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn stpncpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strndup(arg1: *const ::std::os::raw::c_char, arg2: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: size_t)
     -> size_t;
    pub fn strsignal(sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn memset_s(arg1: *mut ::std::os::raw::c_void, arg2: rsize_t,
                    arg3: ::std::os::raw::c_int, arg4: rsize_t) -> errno_t;
    pub fn memmem(arg1: *const ::std::os::raw::c_void, arg2: size_t,
                  arg3: *const ::std::os::raw::c_void, arg4: size_t)
     -> *mut ::std::os::raw::c_void;
    pub fn memset_pattern4(arg1: *mut ::std::os::raw::c_void,
                           arg2: *const ::std::os::raw::c_void, arg3: size_t);
    pub fn memset_pattern8(arg1: *mut ::std::os::raw::c_void,
                           arg2: *const ::std::os::raw::c_void, arg3: size_t);
    pub fn memset_pattern16(arg1: *mut ::std::os::raw::c_void,
                            arg2: *const ::std::os::raw::c_void,
                            arg3: size_t);
    pub fn strcasestr(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn strnstr(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn strlcat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> size_t;
    pub fn strlcpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> size_t;
    pub fn strmode(arg1: ::std::os::raw::c_int,
                   arg2: *mut ::std::os::raw::c_char);
    pub fn strsep(arg1: *mut *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn swab(arg1: *const ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void, arg3: ssize_t);
    pub fn bcmp(arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void, arg3: size_t)
     -> ::std::os::raw::c_int;
    pub fn bcopy(arg1: *const ::std::os::raw::c_void,
                 arg2: *mut ::std::os::raw::c_void, arg3: size_t);
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
    pub fn index(arg1: *const ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn rindex(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn strcasecmp(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn strncasecmp(arg1: *const ::std::os::raw::c_char,
                       arg2: *const ::std::os::raw::c_char, arg3: size_t)
     -> ::std::os::raw::c_int;
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
    pub fn __error() -> *mut ::std::os::raw::c_int;
    pub fn localeconv() -> *mut Struct_lconv;
    pub fn setlocale(arg1: ::std::os::raw::c_int,
                     arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn fdatasync(fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn isascii(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn __maskrune(arg1: __darwin_ct_rune_t, arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn __istype(_c: __darwin_ct_rune_t, _f: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
    pub fn __isctype(_c: __darwin_ct_rune_t, _f: ::std::os::raw::c_ulong)
     -> __darwin_ct_rune_t;
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
    pub fn __wcwidth(_c: __darwin_ct_rune_t) -> ::std::os::raw::c_int;
    pub fn isalnum(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isalpha(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isblank(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn iscntrl(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isdigit(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isgraph(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn islower(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isprint(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ispunct(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isspace(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isupper(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isxdigit(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn toascii(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn tolower(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn toupper(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn digittoint(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ishexnumber(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isideogram(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isnumber(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isphonogram(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isrune(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn isspecial(_c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn accept(arg1: ::std::os::raw::c_int, arg2: *mut Struct_sockaddr,
                  arg3: *mut socklen_t) -> ::std::os::raw::c_int;
    pub fn bind(arg1: ::std::os::raw::c_int, arg2: *const Struct_sockaddr,
                arg3: socklen_t) -> ::std::os::raw::c_int;
    pub fn connect(arg1: ::std::os::raw::c_int, arg2: *const Struct_sockaddr,
                   arg3: socklen_t) -> ::std::os::raw::c_int;
    pub fn getpeername(arg1: ::std::os::raw::c_int,
                       arg2: *mut Struct_sockaddr, arg3: *mut socklen_t)
     -> ::std::os::raw::c_int;
    pub fn getsockname(arg1: ::std::os::raw::c_int,
                       arg2: *mut Struct_sockaddr, arg3: *mut socklen_t)
     -> ::std::os::raw::c_int;
    pub fn getsockopt(arg1: ::std::os::raw::c_int,
                      arg2: ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int,
                      arg4: *mut ::std::os::raw::c_void, arg5: *mut socklen_t)
     -> ::std::os::raw::c_int;
    pub fn listen(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn recv(arg1: ::std::os::raw::c_int,
                arg2: *mut ::std::os::raw::c_void, arg3: size_t,
                arg4: ::std::os::raw::c_int) -> ssize_t;
    pub fn recvfrom(arg1: ::std::os::raw::c_int,
                    arg2: *mut ::std::os::raw::c_void, arg3: size_t,
                    arg4: ::std::os::raw::c_int, arg5: *mut Struct_sockaddr,
                    arg6: *mut socklen_t) -> ssize_t;
    pub fn recvmsg(arg1: ::std::os::raw::c_int, arg2: *mut Struct_msghdr,
                   arg3: ::std::os::raw::c_int) -> ssize_t;
    pub fn send(arg1: ::std::os::raw::c_int,
                arg2: *const ::std::os::raw::c_void, arg3: size_t,
                arg4: ::std::os::raw::c_int) -> ssize_t;
    pub fn sendmsg(arg1: ::std::os::raw::c_int, arg2: *const Struct_msghdr,
                   arg3: ::std::os::raw::c_int) -> ssize_t;
    pub fn sendto(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_void, arg3: size_t,
                  arg4: ::std::os::raw::c_int, arg5: *const Struct_sockaddr,
                  arg6: socklen_t) -> ssize_t;
    pub fn setsockopt(arg1: ::std::os::raw::c_int,
                      arg2: ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int,
                      arg4: *const ::std::os::raw::c_void, arg5: socklen_t)
     -> ::std::os::raw::c_int;
    pub fn shutdown(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn socket(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn socketpair(arg1: ::std::os::raw::c_int,
                      arg2: ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int,
                      arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sendfile(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int,
                    arg3: off_t, arg4: *mut off_t, arg5: *mut Struct_sf_hdtr,
                    arg6: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pfctlinput(arg1: ::std::os::raw::c_int,
                      arg2: *mut Struct_sockaddr);
    pub fn connectx(arg1: ::std::os::raw::c_int, arg2: *const sa_endpoints_t,
                    arg3: sae_associd_t, arg4: ::std::os::raw::c_uint,
                    arg5: *const Struct_iovec, arg6: ::std::os::raw::c_uint,
                    arg7: *mut size_t, arg8: *mut sae_connid_t)
     -> ::std::os::raw::c_int;
    pub fn disconnectx(arg1: ::std::os::raw::c_int, arg2: sae_associd_t,
                       arg3: sae_connid_t) -> ::std::os::raw::c_int;
    pub fn setipv4sourcefilter(arg1: ::std::os::raw::c_int,
                               arg2: Struct_in_addr, arg3: Struct_in_addr,
                               arg4: uint32_t, arg5: uint32_t,
                               arg6: *mut Struct_in_addr)
     -> ::std::os::raw::c_int;
    pub fn getipv4sourcefilter(arg1: ::std::os::raw::c_int,
                               arg2: Struct_in_addr, arg3: Struct_in_addr,
                               arg4: *mut uint32_t, arg5: *mut uint32_t,
                               arg6: *mut Struct_in_addr)
     -> ::std::os::raw::c_int;
    pub fn setsourcefilter(arg1: ::std::os::raw::c_int, arg2: uint32_t,
                           arg3: *mut Struct_sockaddr, arg4: socklen_t,
                           arg5: uint32_t, arg6: uint32_t,
                           arg7: *mut Struct_sockaddr_storage)
     -> ::std::os::raw::c_int;
    pub fn getsourcefilter(arg1: ::std::os::raw::c_int, arg2: uint32_t,
                           arg3: *mut Struct_sockaddr, arg4: socklen_t,
                           arg5: *mut uint32_t, arg6: *mut uint32_t,
                           arg7: *mut Struct_sockaddr_storage)
     -> ::std::os::raw::c_int;
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn inet6_option_init(arg1: *mut ::std::os::raw::c_void,
                             arg2: *mut *mut Struct_cmsghdr,
                             arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn inet6_option_append(arg1: *mut Struct_cmsghdr,
                               arg2: *const __uint8_t,
                               arg3: ::std::os::raw::c_int,
                               arg4: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn inet6_option_alloc(arg1: *mut Struct_cmsghdr,
                              arg2: ::std::os::raw::c_int,
                              arg3: ::std::os::raw::c_int,
                              arg4: ::std::os::raw::c_int) -> *mut __uint8_t;
    pub fn inet6_option_next(arg1: *const Struct_cmsghdr,
                             arg2: *mut *mut __uint8_t)
     -> ::std::os::raw::c_int;
    pub fn inet6_option_find(arg1: *const Struct_cmsghdr,
                             arg2: *mut *mut __uint8_t,
                             arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int,
                             arg2: ::std::os::raw::c_int) -> size_t;
    pub fn inet6_rthdr_init(arg1: *mut ::std::os::raw::c_void,
                            arg2: ::std::os::raw::c_int)
     -> *mut Struct_cmsghdr;
    pub fn inet6_rthdr_add(arg1: *mut Struct_cmsghdr,
                           arg2: *const Struct_in6_addr,
                           arg3: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn inet6_rthdr_lasthop(arg1: *mut Struct_cmsghdr,
                               arg2: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn inet6_rthdr_segments(arg1: *const Struct_cmsghdr)
     -> ::std::os::raw::c_int;
    pub fn inet6_rthdr_getaddr(arg1: *mut Struct_cmsghdr,
                               arg2: ::std::os::raw::c_int)
     -> *mut Struct_in6_addr;
    pub fn inet6_rthdr_getflags(arg1: *const Struct_cmsghdr,
                                arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn inet6_opt_init(arg1: *mut ::std::os::raw::c_void, arg2: socklen_t)
     -> ::std::os::raw::c_int;
    pub fn inet6_opt_append(arg1: *mut ::std::os::raw::c_void,
                            arg2: socklen_t, arg3: ::std::os::raw::c_int,
                            arg4: __uint8_t, arg5: socklen_t, arg6: __uint8_t,
                            arg7: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn inet6_opt_finish(arg1: *mut ::std::os::raw::c_void,
                            arg2: socklen_t, arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn inet6_opt_set_val(arg1: *mut ::std::os::raw::c_void,
                             arg2: ::std::os::raw::c_int,
                             arg3: *mut ::std::os::raw::c_void,
                             arg4: socklen_t) -> ::std::os::raw::c_int;
    pub fn inet6_opt_next(arg1: *mut ::std::os::raw::c_void, arg2: socklen_t,
                          arg3: ::std::os::raw::c_int, arg4: *mut __uint8_t,
                          arg5: *mut socklen_t,
                          arg6: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn inet6_opt_find(arg1: *mut ::std::os::raw::c_void, arg2: socklen_t,
                          arg3: ::std::os::raw::c_int, arg4: __uint8_t,
                          arg5: *mut socklen_t,
                          arg6: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn inet6_opt_get_val(arg1: *mut ::std::os::raw::c_void,
                             arg2: ::std::os::raw::c_int,
                             arg3: *mut ::std::os::raw::c_void,
                             arg4: socklen_t) -> ::std::os::raw::c_int;
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int,
                           arg2: ::std::os::raw::c_int) -> socklen_t;
    pub fn inet6_rth_init(arg1: *mut ::std::os::raw::c_void, arg2: socklen_t,
                          arg3: ::std::os::raw::c_int,
                          arg4: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
    pub fn inet6_rth_add(arg1: *mut ::std::os::raw::c_void,
                         arg2: *const Struct_in6_addr)
     -> ::std::os::raw::c_int;
    pub fn inet6_rth_reverse(arg1: *const ::std::os::raw::c_void,
                             arg2: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn inet6_rth_getaddr(arg1: *const ::std::os::raw::c_void,
                             arg2: ::std::os::raw::c_int)
     -> *mut Struct_in6_addr;
    pub fn addrsel_policy_init();
    pub fn bindresvport(arg1: ::std::os::raw::c_int,
                        arg2: *mut Struct_sockaddr_in)
     -> ::std::os::raw::c_int;
    pub fn bindresvport_sa(arg1: ::std::os::raw::c_int,
                           arg2: *mut Struct_sockaddr)
     -> ::std::os::raw::c_int;
    pub fn endhostent();
    pub fn endnetent();
    pub fn endprotoent();
    pub fn endservent();
    pub fn freeaddrinfo(arg1: *mut Struct_addrinfo);
    pub fn gai_strerror(arg1: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn getaddrinfo(arg1: *const ::std::os::raw::c_char,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *const Struct_addrinfo,
                       arg4: *mut *mut Struct_addrinfo)
     -> ::std::os::raw::c_int;
    pub fn gethostbyaddr(arg1: *const ::std::os::raw::c_void, arg2: socklen_t,
                         arg3: ::std::os::raw::c_int) -> *mut Struct_hostent;
    pub fn gethostbyname(arg1: *const ::std::os::raw::c_char)
     -> *mut Struct_hostent;
    pub fn gethostent() -> *mut Struct_hostent;
    pub fn getnameinfo(arg1: *const Struct_sockaddr, arg2: socklen_t,
                       arg3: *mut ::std::os::raw::c_char, arg4: socklen_t,
                       arg5: *mut ::std::os::raw::c_char, arg6: socklen_t,
                       arg7: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getnetbyaddr(arg1: uint32_t, arg2: ::std::os::raw::c_int)
     -> *mut Struct_netent;
    pub fn getnetbyname(arg1: *const ::std::os::raw::c_char)
     -> *mut Struct_netent;
    pub fn getnetent() -> *mut Struct_netent;
    pub fn getprotobyname(arg1: *const ::std::os::raw::c_char)
     -> *mut Struct_protoent;
    pub fn getprotobynumber(arg1: ::std::os::raw::c_int)
     -> *mut Struct_protoent;
    pub fn getprotoent() -> *mut Struct_protoent;
    pub fn getservbyname(arg1: *const ::std::os::raw::c_char,
                         arg2: *const ::std::os::raw::c_char)
     -> *mut Struct_servent;
    pub fn getservbyport(arg1: ::std::os::raw::c_int,
                         arg2: *const ::std::os::raw::c_char)
     -> *mut Struct_servent;
    pub fn getservent() -> *mut Struct_servent;
    pub fn sethostent(arg1: ::std::os::raw::c_int);
    pub fn setnetent(arg1: ::std::os::raw::c_int);
    pub fn setprotoent(arg1: ::std::os::raw::c_int);
    pub fn setservent(arg1: ::std::os::raw::c_int);
    pub fn freehostent(arg1: *mut Struct_hostent);
    pub fn gethostbyname2(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int) -> *mut Struct_hostent;
    pub fn getipnodebyaddr(arg1: *const ::std::os::raw::c_void, arg2: size_t,
                           arg3: ::std::os::raw::c_int,
                           arg4: *mut ::std::os::raw::c_int)
     -> *mut Struct_hostent;
    pub fn getipnodebyname(arg1: *const ::std::os::raw::c_char,
                           arg2: ::std::os::raw::c_int,
                           arg3: ::std::os::raw::c_int,
                           arg4: *mut ::std::os::raw::c_int)
     -> *mut Struct_hostent;
    pub fn getrpcbyname(name: *const ::std::os::raw::c_char)
     -> *mut Struct_rpcent;
    pub fn getrpcbynumber(number: ::std::os::raw::c_int)
     -> *mut Struct_rpcent;
    pub fn getrpcent() -> *mut Struct_rpcent;
    pub fn setrpcent(stayopen: ::std::os::raw::c_int);
    pub fn endrpcent();
    pub fn herror(arg1: *const ::std::os::raw::c_char);
    pub fn hstrerror(arg1: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
    pub fn innetgr(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *const ::std::os::raw::c_char,
                   arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn getnetgrent(arg1: *mut *mut ::std::os::raw::c_char,
                       arg2: *mut *mut ::std::os::raw::c_char,
                       arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn endnetgrent();
    pub fn setnetgrent(arg1: *const ::std::os::raw::c_char);
    pub fn getpwuid(arg1: uid_t) -> *mut Struct_passwd;
    pub fn getpwnam(arg1: *const ::std::os::raw::c_char)
     -> *mut Struct_passwd;
    pub fn getpwuid_r(arg1: uid_t, arg2: *mut Struct_passwd,
                      arg3: *mut ::std::os::raw::c_char, arg4: size_t,
                      arg5: *mut *mut Struct_passwd) -> ::std::os::raw::c_int;
    pub fn getpwnam_r(arg1: *const ::std::os::raw::c_char,
                      arg2: *mut Struct_passwd,
                      arg3: *mut ::std::os::raw::c_char, arg4: size_t,
                      arg5: *mut *mut Struct_passwd) -> ::std::os::raw::c_int;
    pub fn getpwent() -> *mut Struct_passwd;
    pub fn setpwent();
    pub fn endpwent();
    pub fn uuid_clear(uu: uuid_t);
    pub fn uuid_compare(uu1: uuid_t, uu2: uuid_t) -> ::std::os::raw::c_int;
    pub fn uuid_copy(dst: uuid_t, src: uuid_t);
    pub fn uuid_generate(out: uuid_t);
    pub fn uuid_generate_random(out: uuid_t);
    pub fn uuid_generate_time(out: uuid_t);
    pub fn uuid_is_null(uu: uuid_t) -> ::std::os::raw::c_int;
    pub fn uuid_parse(_in: uuid_string_t, uu: uuid_t)
     -> ::std::os::raw::c_int;
    pub fn uuid_unparse(uu: uuid_t, out: uuid_string_t);
    pub fn uuid_unparse_lower(uu: uuid_t, out: uuid_string_t);
    pub fn uuid_unparse_upper(uu: uuid_t, out: uuid_string_t);
    pub fn setpassent(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn user_from_uid(arg1: uid_t, arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn getpwuuid(arg1: uuid_t) -> *mut Struct_passwd;
    pub fn getpwuuid_r(arg1: uuid_t, arg2: *mut Struct_passwd,
                       arg3: *mut ::std::os::raw::c_char, arg4: size_t,
                       arg5: *mut *mut Struct_passwd)
     -> ::std::os::raw::c_int;
    pub fn pg_set_noblock(sock: pgsocket) -> _bool;
    pub fn pg_set_block(sock: pgsocket) -> _bool;
    pub fn has_drive_prefix(filename: *const ::std::os::raw::c_char) -> _bool;
    pub fn first_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn last_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn first_path_var_separator(pathlist: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn join_path_components(ret_path: *mut ::std::os::raw::c_char,
                                head: *const ::std::os::raw::c_char,
                                tail: *const ::std::os::raw::c_char);
    pub fn canonicalize_path(path: *mut ::std::os::raw::c_char);
    pub fn make_native_path(path: *mut ::std::os::raw::c_char);
    pub fn path_contains_parent_reference(path: *const ::std::os::raw::c_char)
     -> _bool;
    pub fn path_is_relative_and_below_cwd(path: *const ::std::os::raw::c_char)
     -> _bool;
    pub fn path_is_prefix_of_path(path1: *const ::std::os::raw::c_char,
                                  path2: *const ::std::os::raw::c_char)
     -> _bool;
    pub fn make_absolute_path(path: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn get_progname(argv0: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn get_share_path(my_exec_path: *const ::std::os::raw::c_char,
                          ret_path: *mut ::std::os::raw::c_char);
    pub fn get_etc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_include_path(my_exec_path: *const ::std::os::raw::c_char,
                            ret_path: *mut ::std::os::raw::c_char);
    pub fn get_pkginclude_path(my_exec_path: *const ::std::os::raw::c_char,
                               ret_path: *mut ::std::os::raw::c_char);
    pub fn get_includeserver_path(my_exec_path: *const ::std::os::raw::c_char,
                                  ret_path: *mut ::std::os::raw::c_char);
    pub fn get_lib_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_pkglib_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
    pub fn get_locale_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
    pub fn get_doc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_html_path(my_exec_path: *const ::std::os::raw::c_char,
                         ret_path: *mut ::std::os::raw::c_char);
    pub fn get_man_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
    pub fn get_home_path(ret_path: *mut ::std::os::raw::c_char) -> _bool;
    pub fn get_parent_directory(path: *mut ::std::os::raw::c_char);
    pub fn pgfnames(path: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
    pub fn pgfnames_cleanup(filenames: *mut *mut ::std::os::raw::c_char);
    pub fn set_pglocale_pgservice(argv0: *const ::std::os::raw::c_char,
                                  app: *const ::std::os::raw::c_char);
    pub fn find_my_exec(argv0: *const ::std::os::raw::c_char,
                        retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn find_other_exec(argv0: *const ::std::os::raw::c_char,
                           target: *const ::std::os::raw::c_char,
                           versionstr: *const ::std::os::raw::c_char,
                           retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_usleep(microsec: ::std::os::raw::c_long);
    pub fn pg_strcasecmp(s1: *const ::std::os::raw::c_char,
                         s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_strncasecmp(s1: *const ::std::os::raw::c_char,
                          s2: *const ::std::os::raw::c_char, n: size_t)
     -> ::std::os::raw::c_int;
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
    pub fn simple_prompt(prompt: *const ::std::os::raw::c_char,
                         maxlen: ::std::os::raw::c_int, echo: _bool)
     -> *mut ::std::os::raw::c_char;
    pub fn pclose_check(stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn rmtree(path: *const ::std::os::raw::c_char, rmtopdir: _bool)
     -> _bool;
    pub fn pg_erand48(xseed: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_double;
    pub fn pg_lrand48() -> ::std::os::raw::c_long;
    pub fn pg_srand48(seed: ::std::os::raw::c_long);
    pub fn pqStrerror(errnum: ::std::os::raw::c_int,
                      strerrbuf: *mut ::std::os::raw::c_char, buflen: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn pqGetpwuid(uid: uid_t, resultbuf: *mut Struct_passwd,
                      buffer: *mut ::std::os::raw::c_char, buflen: size_t,
                      result: *mut *mut Struct_passwd)
     -> ::std::os::raw::c_int;
    pub fn pqGethostbyname(name: *const ::std::os::raw::c_char,
                           resultbuf: *mut Struct_hostent,
                           buffer: *mut ::std::os::raw::c_char,
                           buflen: size_t, result: *mut *mut Struct_hostent,
                           herrno: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pg_qsort(base: *mut ::std::os::raw::c_void, nel: size_t,
                    elsize: size_t,
                    cmp:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>);
    pub fn pg_qsort_strcmp(a: *const ::std::os::raw::c_void,
                           b: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn qsort_arg(base: *mut ::std::os::raw::c_void, nel: size_t,
                     elsize: size_t, cmp: qsort_arg_comparator,
                     arg: *mut ::std::os::raw::c_void);
    pub fn pg_get_encoding_from_locale(ctype: *const ::std::os::raw::c_char,
                                       write_message: _bool)
     -> ::std::os::raw::c_int;
    pub fn inet_net_ntop(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_void,
                         bits: ::std::os::raw::c_int,
                         dst: *mut ::std::os::raw::c_char, size: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn pg_check_dir(dir: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn pg_mkdir_p(path: *mut ::std::os::raw::c_char,
                      omode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pqsignal(signo: ::std::os::raw::c_int, func: pqsigfunc)
     -> pqsigfunc;
    pub fn escape_single_quotes_ascii(src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn wait_result_to_str(exit_status: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn setjmp(arg1: jmp_buf) -> ::std::os::raw::c_int;
    pub fn longjmp(arg1: jmp_buf, arg2: ::std::os::raw::c_int);
    pub fn _setjmp(arg1: jmp_buf) -> ::std::os::raw::c_int;
    pub fn _longjmp(arg1: jmp_buf, arg2: ::std::os::raw::c_int);
    pub fn sigsetjmp(arg1: sigjmp_buf, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn siglongjmp(arg1: sigjmp_buf, arg2: ::std::os::raw::c_int);
    pub fn longjmperror();
    pub fn errstart(elevel: ::std::os::raw::c_int,
                    filename: *const ::std::os::raw::c_char,
                    lineno: ::std::os::raw::c_int,
                    funcname: *const ::std::os::raw::c_char,
                    domain: *const ::std::os::raw::c_char) -> _bool;
    pub fn errfinish(dummy: ::std::os::raw::c_int, ...);
    pub fn errcode(sqlerrcode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn errcode_for_file_access() -> ::std::os::raw::c_int;
    pub fn errcode_for_socket_access() -> ::std::os::raw::c_int;
    pub fn errmsg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errmsg_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errmsg_plural(fmt_singular: *const ::std::os::raw::c_char,
                         fmt_plural: *const ::std::os::raw::c_char,
                         n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_log(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_log_plural(fmt_singular: *const ::std::os::raw::c_char,
                                fmt_plural: *const ::std::os::raw::c_char,
                                n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
    pub fn errdetail_plural(fmt_singular: *const ::std::os::raw::c_char,
                            fmt_plural: *const ::std::os::raw::c_char,
                            n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
    pub fn errhint(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn set_errcontext_domain(domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errcontext_msg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
    pub fn errhidestmt(hide_stmt: _bool) -> ::std::os::raw::c_int;
    pub fn errhidecontext(hide_ctx: _bool) -> ::std::os::raw::c_int;
    pub fn errfunction(funcname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn internalerrposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn internalerrquery(query: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn err_generic_string(field: ::std::os::raw::c_int,
                              str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn geterrcode() -> ::std::os::raw::c_int;
    pub fn geterrposition() -> ::std::os::raw::c_int;
    pub fn getinternalerrposition() -> ::std::os::raw::c_int;
    pub fn elog_start(filename: *const ::std::os::raw::c_char,
                      lineno: ::std::os::raw::c_int,
                      funcname: *const ::std::os::raw::c_char);
    pub fn elog_finish(elevel: ::std::os::raw::c_int,
                       fmt: *const ::std::os::raw::c_char, ...);
    pub fn pre_format_elog_string(errnumber: ::std::os::raw::c_int,
                                  domain: *const ::std::os::raw::c_char);
    pub fn format_elog_string(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
    pub fn EmitErrorReport();
    pub fn CopyErrorData() -> *mut ErrorData;
    pub fn FreeErrorData(edata: *mut ErrorData);
    pub fn FlushErrorState();
    pub fn ReThrowError(edata: *mut ErrorData);
    pub fn ThrowErrorData(edata: *mut ErrorData);
    pub fn pg_re_throw();
    pub fn GetErrorContextStack() -> *mut ::std::os::raw::c_char;
    pub fn DebugFileOpen();
    pub fn unpack_sql_state(sql_state: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
    pub fn in_error_recursion_trouble() -> _bool;
    pub fn set_syslog_parameters(ident: *const ::std::os::raw::c_char,
                                 facility: ::std::os::raw::c_int);
    pub fn write_stderr(fmt: *const ::std::os::raw::c_char, ...);
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocZero(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocZeroAligned(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocExtended(context: MemoryContext, size: Size,
                                      flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
    pub fn palloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn palloc0(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn palloc_extended(size: Size, flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
    pub fn repalloc(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn pfree(pointer: *mut ::std::os::raw::c_void);
    pub fn MemoryContextAllocHuge(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn repalloc_huge(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextRegisterResetCallback(context: MemoryContext,
                                              cb: *mut MemoryContextCallback);
    pub fn MemoryContextStrdup(context: MemoryContext,
                               string: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pstrdup(_in: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn pnstrdup(_in: *const ::std::os::raw::c_char, len: Size)
     -> *mut ::std::os::raw::c_char;
    pub fn psprintf(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
    pub fn pvsnprintf(buf: *mut ::std::os::raw::c_char, len: size_t,
                      fmt: *const ::std::os::raw::c_char, args: va_list)
     -> size_t;
    pub fn DatumGetFloat4(X: Datum) -> float4;
    pub fn Float4GetDatum(X: float4) -> Datum;
    pub fn DatumGetFloat8(X: Datum) -> float8;
    pub fn Float8GetDatum(X: float8) -> Datum;
    pub fn ExceptionalCondition(conditionName: *const ::std::os::raw::c_char,
                                errorType: *const ::std::os::raw::c_char,
                                fileName: *const ::std::os::raw::c_char,
                                lineNumber: ::std::os::raw::c_int);
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo);
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo,
                         mcxt: MemoryContext);
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo,
                          destcxt: MemoryContext);
    pub fn pg_detoast_datum(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn pg_detoast_datum_copy(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn pg_detoast_datum_slice(datum: *mut Struct_varlena, first: int32,
                                  count: int32) -> *mut Struct_varlena;
    pub fn pg_detoast_datum_packed(datum: *mut Struct_varlena)
     -> *mut Struct_varlena;
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum) -> Datum;
    pub fn DirectFunctionCall2Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum) -> Datum;
    pub fn DirectFunctionCall3Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum)
     -> Datum;
    pub fn DirectFunctionCall4Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum) -> Datum;
    pub fn DirectFunctionCall5Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum) -> Datum;
    pub fn DirectFunctionCall6Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum)
     -> Datum;
    pub fn DirectFunctionCall7Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum) -> Datum;
    pub fn DirectFunctionCall8Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum) -> Datum;
    pub fn DirectFunctionCall9Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum, arg9: Datum)
     -> Datum;
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum) -> Datum;
    pub fn FunctionCall2Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum) -> Datum;
    pub fn FunctionCall3Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum) -> Datum;
    pub fn FunctionCall4Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum) -> Datum;
    pub fn FunctionCall5Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum) -> Datum;
    pub fn FunctionCall6Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum) -> Datum;
    pub fn FunctionCall7Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum) -> Datum;
    pub fn FunctionCall8Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum) -> Datum;
    pub fn FunctionCall9Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum, arg9: Datum) -> Datum;
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum)
     -> Datum;
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum) -> Datum;
    pub fn OidFunctionCall3Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum) -> Datum;
    pub fn OidFunctionCall4Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum)
     -> Datum;
    pub fn OidFunctionCall5Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum) -> Datum;
    pub fn OidFunctionCall6Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum) -> Datum;
    pub fn OidFunctionCall7Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum)
     -> Datum;
    pub fn OidFunctionCall8Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum) -> Datum;
    pub fn OidFunctionCall9Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum, arg9: Datum) -> Datum;
    pub fn InputFunctionCall(flinfo: *mut FmgrInfo,
                             str: *mut ::std::os::raw::c_char,
                             typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidInputFunctionCall(functionId: Oid,
                                str: *mut ::std::os::raw::c_char,
                                typioparam: Oid, typmod: int32) -> Datum;
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum)
     -> *mut ::std::os::raw::c_char;
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum)
     -> *mut ::std::os::raw::c_char;
    pub fn ReceiveFunctionCall(flinfo: *mut FmgrInfo, buf: fmStringInfo,
                               typioparam: Oid, typmod: int32) -> Datum;
    pub fn OidReceiveFunctionCall(functionId: Oid, buf: fmStringInfo,
                                  typioparam: Oid, typmod: int32) -> Datum;
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
    pub fn fetch_finfo_record(filehandle: *mut ::std::os::raw::c_void,
                              funcname: *mut ::std::os::raw::c_char)
     -> *const Pg_finfo_record;
    pub fn clear_external_function_hash(filehandle:
                                            *mut ::std::os::raw::c_void);
    pub fn fmgr_internal_function(proname: *const ::std::os::raw::c_char)
     -> Oid;
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo,
                               argnum: ::std::os::raw::c_int) -> Oid;
    pub fn get_call_expr_argtype(expr: fmNodePtr,
                                 argnum: ::std::os::raw::c_int) -> Oid;
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo,
                                  argnum: ::std::os::raw::c_int) -> _bool;
    pub fn get_call_expr_arg_stable(expr: fmNodePtr,
                                    argnum: ::std::os::raw::c_int) -> _bool;
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> _bool;
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid)
     -> _bool;
    pub fn load_external_function(filename: *mut ::std::os::raw::c_char,
                                  funcname: *mut ::std::os::raw::c_char,
                                  signalNotFound: _bool,
                                  filehandle:
                                      *mut *mut ::std::os::raw::c_void)
     -> PGFunction;
    pub fn lookup_external_function(filehandle: *mut ::std::os::raw::c_void,
                                    funcname: *mut ::std::os::raw::c_char)
     -> PGFunction;
    pub fn load_file(filename: *const ::std::os::raw::c_char,
                     restricted: _bool);
    pub fn find_rendezvous_variable(varName: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_void;
    pub fn EstimateLibraryStateSpace() -> Size;
    pub fn SerializeLibraryState(maxsize: Size,
                                 start_address: *mut ::std::os::raw::c_char);
    pub fn RestoreLibraryState(start_address: *mut ::std::os::raw::c_char);
    pub fn AggCheckCallContext(fcinfo: FunctionCallInfo,
                               aggcontext: *mut MemoryContext)
     -> ::std::os::raw::c_int;
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
    pub fn AggRegisterCallback(fcinfo: FunctionCallInfo,
                               func: fmExprContextCallbackFunction,
                               arg: Datum);
    pub fn fmgr(procedureId: Oid, ...) -> *mut ::std::os::raw::c_char;
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_make_singleton(x: ::std::os::raw::c_int) -> *mut Bitmapset;
    pub fn bms_free(a: *mut Bitmapset);
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset)
     -> BMS_Comparison;
    pub fn bms_is_member(x: ::std::os::raw::c_int, a: *const Bitmapset)
     -> _bool;
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> _bool;
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> _bool;
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_get_singleton_member(a: *const Bitmapset,
                                    member: *mut ::std::os::raw::c_int)
     -> _bool;
    pub fn bms_num_members(a: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
    pub fn bms_is_empty(a: *const Bitmapset) -> _bool;
    pub fn bms_add_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
    pub fn bms_del_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
    pub fn bms_first_member(a: *mut Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_next_member(a: *const Bitmapset,
                           prevbit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
    pub fn nodeToString(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_char;
    pub fn stringToNode(str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
    pub fn copyObject(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
    pub fn equal(a: *const ::std::os::raw::c_void,
                 b: *const ::std::os::raw::c_void) -> _bool;
    pub fn lappend(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn lappend_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn lappend_cell(list: *mut List, prev: *mut ListCell,
                        datum: *mut ::std::os::raw::c_void) -> *mut ListCell;
    pub fn lappend_cell_int(list: *mut List, prev: *mut ListCell,
                            datum: ::std::os::raw::c_int) -> *mut ListCell;
    pub fn lappend_cell_oid(list: *mut List, prev: *mut ListCell, datum: Oid)
     -> *mut ListCell;
    pub fn lcons(datum: *mut ::std::os::raw::c_void, list: *mut List)
     -> *mut List;
    pub fn lcons_int(datum: ::std::os::raw::c_int, list: *mut List)
     -> *mut List;
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
    pub fn list_concat(list1: *mut List, list2: *mut List) -> *mut List;
    pub fn list_truncate(list: *mut List, new_size: ::std::os::raw::c_int)
     -> *mut List;
    pub fn list_nth_cell(list: *const List, n: ::std::os::raw::c_int)
     -> *mut ListCell;
    pub fn list_nth(list: *const List, n: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
    pub fn list_nth_int(list: *const List, n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn list_nth_oid(list: *const List, n: ::std::os::raw::c_int) -> Oid;
    pub fn list_member(list: *const List,
                       datum: *const ::std::os::raw::c_void) -> _bool;
    pub fn list_member_ptr(list: *const List,
                           datum: *const ::std::os::raw::c_void) -> _bool;
    pub fn list_member_int(list: *const List, datum: ::std::os::raw::c_int)
     -> _bool;
    pub fn list_member_oid(list: *const List, datum: Oid) -> _bool;
    pub fn list_delete(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_delete_ptr(list: *mut List,
                           datum: *mut ::std::os::raw::c_void) -> *mut List;
    pub fn list_delete_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_delete_first(list: *mut List) -> *mut List;
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell,
                            prev: *mut ListCell) -> *mut List;
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_union_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_intersection(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_intersection_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_ptr(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_int(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_difference_oid(list1: *const List, list2: *const List)
     -> *mut List;
    pub fn list_append_unique(list: *mut List,
                              datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_append_unique_ptr(list: *mut List,
                                  datum: *mut ::std::os::raw::c_void)
     -> *mut List;
    pub fn list_append_unique_int(list: *mut List,
                                  datum: ::std::os::raw::c_int) -> *mut List;
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_concat_unique(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_int(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_concat_unique_oid(list1: *mut List, list2: *mut List)
     -> *mut List;
    pub fn list_free(list: *mut List);
    pub fn list_free_deep(list: *mut List);
    pub fn list_copy(list: *const List) -> *mut List;
    pub fn list_copy_tail(list: *const List, nskip: ::std::os::raw::c_int)
     -> *mut List;
    pub fn makeInteger(i: ::std::os::raw::c_long) -> *mut Value;
    pub fn makeFloat(numericStr: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn makeString(str: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn makeBitString(str: *mut ::std::os::raw::c_char) -> *mut Value;
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo:
                                                            FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_alltrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_anytrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn parse_bool(value: *const ::std::os::raw::c_char,
                      result: *mut _bool) -> _bool;
    pub fn parse_bool_with_len(value: *const ::std::os::raw::c_char,
                               len: size_t, result: *mut _bool) -> _bool;
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_check(value: Datum, isnull: _bool, domainType: Oid,
                        extra: *mut *mut ::std::os::raw::c_void,
                        mcxt: MemoryContext);
    pub fn errdatatype(datatypeOid: Oid) -> ::std::os::raw::c_int;
    pub fn errdomainconstraint(datatypeOid: Oid,
                               conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hex_encode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
    pub fn hex_decode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn buildint2vector(int2s: *const int16, n: ::std::os::raw::c_int)
     -> *mut int2vector;
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namecpy(n1: Name, n2: Name) -> ::std::os::raw::c_int;
    pub fn namestrcpy(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn namestrcmp(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_atoi(s: *const ::std::os::raw::c_char,
                   size: ::std::os::raw::c_int, c: ::std::os::raw::c_int)
     -> int32;
    pub fn pg_itoa(i: int16, a: *mut ::std::os::raw::c_char);
    pub fn pg_ltoa(l: int32, a: *mut ::std::os::raw::c_char);
    pub fn pg_lltoa(ll: int64, a: *mut ::std::os::raw::c_char);
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btabstimecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btreltimecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttintervalcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn get_float8_infinity() -> ::std::os::raw::c_double;
    pub fn get_float4_infinity() -> ::std::os::raw::c_float;
    pub fn get_float8_nan() -> ::std::os::raw::c_double;
    pub fn get_float4_nan() -> ::std::os::raw::c_float;
    pub fn is_infinite(val: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_filenode_relation(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_file_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn buildoidvector(oids: *const Oid, n: ::std::os::raw::c_int)
     -> *mut oidvector;
    pub fn oidparse(node: *mut Node) -> Oid;
    pub fn ordered_set_transition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn mode_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn opaque_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn opaque_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_fixed_prefix(text_re: *mut text, case_insensitive: _bool,
                               collation: Oid, exact: *mut _bool)
     -> *mut ::std::os::raw::c_char;
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regproc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regprocedure(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoperator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regtype(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regroleout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regrole(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespaceout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regnamespace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn stringToQualifiedNameList(string: *const ::std::os::raw::c_char)
     -> *mut List;
    pub fn format_procedure(procedure_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_procedure_qualified(procedure_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_procedure_parts(operator_oid: Oid, objnames: *mut *mut List,
                                  objargs: *mut *mut List);
    pub fn format_operator(operator_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn format_operator_qualified(operator_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_operator_parts(operator_oid: Oid, objnames: *mut *mut List,
                                 objargs: *mut *mut List);
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordimagecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_identifier(ident: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
    pub fn quote_qualified_identifier(qualifier:
                                          *const ::std::os::raw::c_char,
                                      ident: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byreloid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_to_text(s: *const ::std::os::raw::c_char) -> *mut text;
    pub fn cstring_to_text_with_len(s: *const ::std::os::raw::c_char,
                                    len: ::std::os::raw::c_int) -> *mut text;
    pub fn text_to_cstring(t: *const text) -> *mut ::std::os::raw::c_char;
    pub fn text_to_cstring_buffer(src: *const text,
                                  dst: *mut ::std::os::raw::c_char,
                                  dst_len: size_t);
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varstr_cmp(arg1: *mut ::std::os::raw::c_char,
                      len1: ::std::os::raw::c_int,
                      arg2: *mut ::std::os::raw::c_char,
                      len2: ::std::os::raw::c_int, collid: Oid)
     -> ::std::os::raw::c_int;
    pub fn varstr_levenshtein(source: *const ::std::os::raw::c_char,
                              slen: ::std::os::raw::c_int,
                              target: *const ::std::os::raw::c_char,
                              tlen: ::std::os::raw::c_int,
                              ins_c: ::std::os::raw::c_int,
                              del_c: ::std::os::raw::c_int,
                              sub_c: ::std::os::raw::c_int, trusted: _bool)
     -> ::std::os::raw::c_int;
    pub fn varstr_levenshtein_less_equal(source:
                                             *const ::std::os::raw::c_char,
                                         slen: ::std::os::raw::c_int,
                                         target:
                                             *const ::std::os::raw::c_char,
                                         tlen: ::std::os::raw::c_int,
                                         ins_c: ::std::os::raw::c_int,
                                         del_c: ::std::os::raw::c_int,
                                         sub_c: ::std::os::raw::c_int,
                                         max_d: ::std::os::raw::c_int,
                                         trusted: _bool)
     -> ::std::os::raw::c_int;
    pub fn textToQualifiedNameList(textval: *mut text) -> *mut List;
    pub fn SplitIdentifierString(rawstring: *mut ::std::os::raw::c_char,
                                 separator: ::std::os::raw::c_char,
                                 namelist: *mut *mut List) -> _bool;
    pub fn SplitDirectoriesString(rawstring: *mut ::std::os::raw::c_char,
                                  separator: ::std::os::raw::c_char,
                                  namelist: *mut *mut List) -> _bool;
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn replace_text_regexp(src_text: *mut text,
                               regexp: *mut ::std::os::raw::c_void,
                               replace_text: *mut text, glob: _bool)
     -> *mut text;
    pub fn split_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mxid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidComparator(arg1: *const ::std::os::raw::c_void,
                         arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_cidr_ntop(af: ::std::os::raw::c_int,
                          src: *const ::std::os::raw::c_void,
                          bits: ::std::os::raw::c_int,
                          dst: *mut ::std::os::raw::c_char, size: size_t)
     -> *mut ::std::os::raw::c_char;
    pub fn inet_net_pton(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_char,
                         dst: *mut ::std::os::raw::c_void, size: size_t)
     -> ::std::os::raw::c_int;
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn convert_network_to_scalar(value: Datum, typid: Oid)
     -> ::std::os::raw::c_double;
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_scan_first(_in: Datum) -> Datum;
    pub fn network_scan_last(_in: Datum) -> Datum;
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clean_ipv6_addr(addr_family: ::std::os::raw::c_int,
                           addr: *mut ::std::os::raw::c_char);
    pub fn inet_same_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_merge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_character_set(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_character_set_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_character_set_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type_be(type_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn format_type_be_qualified(type_oid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32)
     -> *mut ::std::os::raw::c_char;
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal_cstr(rawstr: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_file_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_security_active(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_security_active_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_current(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
    pub fn txid_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarraytriconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_bernoulli_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_system_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_xact_commit_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_committed_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object_as_address(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_object_address(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_event_trigger_table_rewrite_oid(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_event_trigger_table_rewrite_reason(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_event_trigger_ddl_commands(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn makeStringInfo() -> StringInfo;
    pub fn initStringInfo(str: StringInfo);
    pub fn resetStringInfo(str: StringInfo);
    pub fn appendStringInfo(str: StringInfo,
                            fmt: *const ::std::os::raw::c_char, ...);
    pub fn appendStringInfoVA(str: StringInfo,
                              fmt: *const ::std::os::raw::c_char,
                              args: va_list) -> ::std::os::raw::c_int;
    pub fn appendStringInfoString(str: StringInfo,
                                  s: *const ::std::os::raw::c_char);
    pub fn appendStringInfoChar(str: StringInfo, ch: ::std::os::raw::c_char);
    pub fn appendStringInfoSpaces(str: StringInfo,
                                  count: ::std::os::raw::c_int);
    pub fn appendBinaryStringInfo(str: StringInfo,
                                  data: *const ::std::os::raw::c_char,
                                  datalen: ::std::os::raw::c_int);
    pub fn enlargeStringInfo(str: StringInfo, needed: ::std::os::raw::c_int);
    pub fn json_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn escape_json(buf: StringInfo, str: *const ::std::os::raw::c_char);
    pub fn json_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer)
     -> _bool;
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderAdjustCmax(tup: HeapTupleHeader,
                                     cmax: *mut CommandId,
                                     iscombo: *mut _bool);
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> _bool;
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid)
     -> ::std::os::raw::c_int;
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
    pub fn get_op_opfamily_properties(opno: Oid, opfamily: Oid,
                                      ordering_op: _bool,
                                      strategy: *mut ::std::os::raw::c_int,
                                      lefttype: *mut Oid,
                                      righttype: *mut Oid);
    pub fn get_opfamily_member(opfamily: Oid, lefttype: Oid, righttype: Oid,
                               strategy: int16) -> Oid;
    pub fn get_ordering_op_properties(opno: Oid, opfamily: *mut Oid,
                                      opcintype: *mut Oid,
                                      strategy: *mut int16) -> _bool;
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: *mut _bool)
     -> Oid;
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: _bool)
     -> Oid;
    pub fn get_mergejoin_opfamilies(opno: Oid) -> *mut List;
    pub fn get_compatible_hash_operators(opno: Oid, lhs_opno: *mut Oid,
                                         rhs_opno: *mut Oid) -> _bool;
    pub fn get_op_hash_functions(opno: Oid, lhs_procno: *mut RegProcedure,
                                 rhs_procno: *mut RegProcedure) -> _bool;
    pub fn get_op_btree_interpretation(opno: Oid) -> *mut List;
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> _bool;
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid,
                             procnum: int16) -> Oid;
    pub fn get_attname(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn get_relid_attribute_name(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn get_attnum(relid: Oid, attname: *const ::std::os::raw::c_char)
     -> AttrNumber;
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
    pub fn get_atttypmod(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_atttypetypmodcoll(relid: Oid, attnum: AttrNumber,
                                 typid: *mut Oid, typmod: *mut int32,
                                 collid: *mut Oid);
    pub fn get_collation_name(colloid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_constraint_name(conoid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_language_name(langoid: Oid, missing_ok: _bool)
     -> *mut ::std::os::raw::c_char;
    pub fn get_opclass_family(opclass: Oid) -> Oid;
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
    pub fn get_opcode(opno: Oid) -> RegProcedure;
    pub fn get_opname(opno: Oid) -> *mut ::std::os::raw::c_char;
    pub fn op_input_types(opno: Oid, lefttype: *mut Oid, righttype: *mut Oid);
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> _bool;
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> _bool;
    pub fn op_strict(opno: Oid) -> _bool;
    pub fn op_volatile(opno: Oid) -> ::std::os::raw::c_char;
    pub fn get_commutator(opno: Oid) -> Oid;
    pub fn get_negator(opno: Oid) -> Oid;
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
    pub fn get_func_name(funcid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_func_namespace(funcid: Oid) -> Oid;
    pub fn get_func_rettype(funcid: Oid) -> Oid;
    pub fn get_func_nargs(funcid: Oid) -> ::std::os::raw::c_int;
    pub fn get_func_signature(funcid: Oid, argtypes: *mut *mut Oid,
                              nargs: *mut ::std::os::raw::c_int) -> Oid;
    pub fn get_func_variadictype(funcid: Oid) -> Oid;
    pub fn get_func_retset(funcid: Oid) -> _bool;
    pub fn func_strict(funcid: Oid) -> _bool;
    pub fn func_volatile(funcid: Oid) -> ::std::os::raw::c_char;
    pub fn get_func_leakproof(funcid: Oid) -> _bool;
    pub fn get_func_cost(funcid: Oid) -> float4;
    pub fn get_func_rows(funcid: Oid) -> float4;
    pub fn get_relname_relid(relname: *const ::std::os::raw::c_char,
                             relnamespace: Oid) -> Oid;
    pub fn get_rel_name(relid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_rel_namespace(relid: Oid) -> Oid;
    pub fn get_rel_type_id(relid: Oid) -> Oid;
    pub fn get_rel_relkind(relid: Oid) -> ::std::os::raw::c_char;
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
    pub fn get_transform_fromsql(typid: Oid, langid: Oid, trftypes: *mut List)
     -> Oid;
    pub fn get_transform_tosql(typid: Oid, langid: Oid, trftypes: *mut List)
     -> Oid;
    pub fn get_typisdefined(typid: Oid) -> _bool;
    pub fn get_typlen(typid: Oid) -> int16;
    pub fn get_typbyval(typid: Oid) -> _bool;
    pub fn get_typlenbyval(typid: Oid, typlen: *mut int16,
                           typbyval: *mut _bool);
    pub fn get_typlenbyvalalign(typid: Oid, typlen: *mut int16,
                                typbyval: *mut _bool,
                                typalign: *mut ::std::os::raw::c_char);
    pub fn getTypeIOParam(typeTuple: HeapTuple) -> Oid;
    pub fn get_type_io_data(typid: Oid, which_func: IOFuncSelector,
                            typlen: *mut int16, typbyval: *mut _bool,
                            typalign: *mut ::std::os::raw::c_char,
                            typdelim: *mut ::std::os::raw::c_char,
                            typioparam: *mut Oid, func: *mut Oid);
    pub fn get_typstorage(typid: Oid) -> ::std::os::raw::c_char;
    pub fn get_typdefault(typid: Oid) -> *mut Node;
    pub fn get_typtype(typid: Oid) -> ::std::os::raw::c_char;
    pub fn type_is_rowtype(typid: Oid) -> _bool;
    pub fn type_is_enum(typid: Oid) -> _bool;
    pub fn type_is_range(typid: Oid) -> _bool;
    pub fn get_type_category_preferred(typid: Oid,
                                       typcategory:
                                           *mut ::std::os::raw::c_char,
                                       typispreferred: *mut _bool);
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
    pub fn get_element_type(typid: Oid) -> Oid;
    pub fn get_array_type(typid: Oid) -> Oid;
    pub fn get_promoted_array_type(typid: Oid) -> Oid;
    pub fn get_base_element_type(typid: Oid) -> Oid;
    pub fn getTypeInputInfo(_type: Oid, typInput: *mut Oid,
                            typIOParam: *mut Oid);
    pub fn getTypeOutputInfo(_type: Oid, typOutput: *mut Oid,
                             typIsVarlena: *mut _bool);
    pub fn getTypeBinaryInputInfo(_type: Oid, typReceive: *mut Oid,
                                  typIOParam: *mut Oid);
    pub fn getTypeBinaryOutputInfo(_type: Oid, typSend: *mut Oid,
                                   typIsVarlena: *mut _bool);
    pub fn get_typmodin(typid: Oid) -> Oid;
    pub fn get_typcollation(typid: Oid) -> Oid;
    pub fn type_is_collatable(typid: Oid) -> _bool;
    pub fn getBaseType(typid: Oid) -> Oid;
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: *mut int32) -> Oid;
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_attstatsslot(statstuple: HeapTuple, atttype: Oid,
                            atttypmod: int32, reqkind: ::std::os::raw::c_int,
                            reqop: Oid, actualop: *mut Oid,
                            values: *mut *mut Datum,
                            nvalues: *mut ::std::os::raw::c_int,
                            numbers: *mut *mut float4,
                            nnumbers: *mut ::std::os::raw::c_int) -> _bool;
    pub fn free_attstatsslot(atttype: Oid, values: *mut Datum,
                             nvalues: ::std::os::raw::c_int,
                             numbers: *mut float4,
                             nnumbers: ::std::os::raw::c_int);
    pub fn get_namespace_name(nspid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_namespace_name_or_temp(nspid: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
    pub fn CreateTemplateTupleDesc(natts: ::std::os::raw::c_int,
                                   hasoid: _bool) -> TupleDesc;
    pub fn CreateTupleDesc(natts: ::std::os::raw::c_int, hasoid: _bool,
                           attrs: *mut Form_pg_attribute) -> TupleDesc;
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
    pub fn TupleDescCopyEntry(dst: TupleDesc, dstAttno: AttrNumber,
                              src: TupleDesc, srcAttno: AttrNumber);
    pub fn FreeTupleDesc(tupdesc: TupleDesc);
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> _bool;
    pub fn TupleDescInitEntry(desc: TupleDesc, attributeNumber: AttrNumber,
                              attributeName: *const ::std::os::raw::c_char,
                              oidtypeid: Oid, typmod: int32,
                              attdim: ::std::os::raw::c_int);
    pub fn TupleDescInitEntryCollation(desc: TupleDesc,
                                       attributeNumber: AttrNumber,
                                       collationid: Oid);
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
    pub fn BuildDescFromLists(names: *mut List, types: *mut List,
                              typmods: *mut List, collations: *mut List)
     -> TupleDesc;
    pub fn open(arg1: *const ::std::os::raw::c_char,
                arg2: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
    pub fn openat(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
    pub fn creat(arg1: *const ::std::os::raw::c_char, arg2: mode_t)
     -> ::std::os::raw::c_int;
    pub fn fcntl(arg1: ::std::os::raw::c_int,
                 arg2: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
    pub fn openx_np(arg1: *const ::std::os::raw::c_char,
                    arg2: ::std::os::raw::c_int, arg3: filesec_t)
     -> ::std::os::raw::c_int;
    pub fn open_dprotected_np(arg1: *const ::std::os::raw::c_char,
                              arg2: ::std::os::raw::c_int,
                              arg3: ::std::os::raw::c_int,
                              arg4: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
    pub fn flock(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn filesec_init() -> filesec_t;
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
    pub fn filesec_free(arg1: filesec_t);
    pub fn filesec_get_property(arg1: filesec_t, arg2: filesec_property_t,
                                arg3: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn filesec_query_property(arg1: filesec_t, arg2: filesec_property_t,
                                  arg3: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn filesec_set_property(arg1: filesec_t, arg2: filesec_property_t,
                                arg3: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn filesec_unset_property(arg1: filesec_t, arg2: filesec_property_t)
     -> ::std::os::raw::c_int;
    pub fn TransactionStartedDuringRecovery() -> _bool;
    pub fn TransactionIdDidCommit(transactionId: TransactionId) -> _bool;
    pub fn TransactionIdDidAbort(transactionId: TransactionId) -> _bool;
    pub fn TransactionIdIsKnownCompleted(transactionId: TransactionId)
     -> _bool;
    pub fn TransactionIdAbort(transactionId: TransactionId);
    pub fn TransactionIdCommitTree(xid: TransactionId,
                                   nxids: ::std::os::raw::c_int,
                                   xids: *mut TransactionId);
    pub fn TransactionIdAsyncCommitTree(xid: TransactionId,
                                        nxids: ::std::os::raw::c_int,
                                        xids: *mut TransactionId,
                                        lsn: XLogRecPtr);
    pub fn TransactionIdAbortTree(xid: TransactionId,
                                  nxids: ::std::os::raw::c_int,
                                  xids: *mut TransactionId);
    pub fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId)
     -> _bool;
    pub fn TransactionIdPrecedesOrEquals(id1: TransactionId,
                                         id2: TransactionId) -> _bool;
    pub fn TransactionIdFollows(id1: TransactionId, id2: TransactionId)
     -> _bool;
    pub fn TransactionIdFollowsOrEquals(id1: TransactionId,
                                        id2: TransactionId) -> _bool;
    pub fn TransactionIdLatest(mainxid: TransactionId,
                               nxids: ::std::os::raw::c_int,
                               xids: *const TransactionId) -> TransactionId;
    pub fn TransactionIdGetCommitLSN(xid: TransactionId) -> XLogRecPtr;
    pub fn GetNewTransactionId(isSubXact: _bool) -> TransactionId;
    pub fn ReadNewTransactionId() -> TransactionId;
    pub fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId,
                                 oldest_datoid: Oid);
    pub fn ForceTransactionIdLimitUpdate() -> _bool;
    pub fn GetNewObjectId() -> Oid;
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> _bool;
    pub fn PageAddItem(page: Page, item: Item, size: Size,
                       offsetNumber: OffsetNumber, overwrite: _bool,
                       is_heap: _bool) -> OffsetNumber;
    pub fn PageGetTempPage(page: Page) -> Page;
    pub fn PageGetTempPageCopy(page: Page) -> Page;
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
    pub fn PageRepairFragmentation(page: Page);
    pub fn PageGetFreeSpace(page: Page) -> Size;
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber);
    pub fn PageIndexMultiDelete(page: Page, itemnos: *mut OffsetNumber,
                                nitems: ::std::os::raw::c_int);
    pub fn PageIndexDeleteNoCompact(page: Page, itemnos: *mut OffsetNumber,
                                    nitems: ::std::os::raw::c_int);
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
    pub fn heap_compute_data_size(tupleDesc: TupleDesc, values: *mut Datum,
                                  isnull: *mut _bool) -> Size;
    pub fn heap_fill_tuple(tupleDesc: TupleDesc, values: *mut Datum,
                           isnull: *mut _bool,
                           data: *mut ::std::os::raw::c_char, data_size: Size,
                           infomask: *mut uint16, bit: *mut bits8);
    pub fn heap_attisnull(tup: HeapTuple, attnum: ::std::os::raw::c_int)
     -> _bool;
    pub fn nocachegetattr(tup: HeapTuple, attnum: ::std::os::raw::c_int,
                          att: TupleDesc) -> Datum;
    pub fn heap_getsysattr(tup: HeapTuple, attnum: ::std::os::raw::c_int,
                           tupleDesc: TupleDesc, isnull: *mut _bool) -> Datum;
    pub fn heap_copytuple(tuple: HeapTuple) -> HeapTuple;
    pub fn heap_copytuple_with_tuple(src: HeapTuple, dest: HeapTuple);
    pub fn heap_copy_tuple_as_datum(tuple: HeapTuple, tupleDesc: TupleDesc)
     -> Datum;
    pub fn heap_form_tuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                           isnull: *mut _bool) -> HeapTuple;
    pub fn heap_modify_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             replValues: *mut Datum, replIsnull: *mut _bool,
                             doReplace: *mut _bool) -> HeapTuple;
    pub fn heap_deform_tuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                             values: *mut Datum, isnull: *mut _bool);
    pub fn heap_formtuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                          nulls: *mut ::std::os::raw::c_char) -> HeapTuple;
    pub fn heap_modifytuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                            replValues: *mut Datum,
                            replNulls: *mut ::std::os::raw::c_char,
                            replActions: *mut ::std::os::raw::c_char)
     -> HeapTuple;
    pub fn heap_deformtuple(tuple: HeapTuple, tupleDesc: TupleDesc,
                            values: *mut Datum,
                            nulls: *mut ::std::os::raw::c_char);
    pub fn heap_freetuple(htup: HeapTuple);
    pub fn heap_form_minimal_tuple(tupleDescriptor: TupleDesc,
                                   values: *mut Datum, isnull: *mut _bool)
     -> MinimalTuple;
    pub fn heap_free_minimal_tuple(mtup: MinimalTuple);
    pub fn heap_copy_minimal_tuple(mtup: MinimalTuple) -> MinimalTuple;
    pub fn heap_tuple_from_minimal_tuple(mtup: MinimalTuple) -> HeapTuple;
    pub fn minimal_tuple_from_heap_tuple(htup: HeapTuple) -> MinimalTuple;
    pub fn slist_delete(head: *mut slist_head, node: *mut slist_node);
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn bsd_signal(arg1: ::std::os::raw::c_int,
                      arg2:
                          ::std::option::Option<extern "C" fn(arg1:
                                                                  ::std::os::raw::c_int)>)
     ->
         ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int,
                                             arg2:
                                                 ::std::option::Option<extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int)>)>;
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pthread_sigmask(arg1: ::std::os::raw::c_int, arg2: *const sigset_t,
                           arg3: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigaction(arg1: ::std::os::raw::c_int,
                     arg2: *const Struct_sigaction,
                     arg3: *mut Struct_sigaction) -> ::std::os::raw::c_int;
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t)
     -> ::std::os::raw::c_int;
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn siginterrupt(arg1: ::std::os::raw::c_int,
                        arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigprocmask(arg1: ::std::os::raw::c_int, arg2: *const sigset_t,
                       arg3: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigset(arg1: ::std::os::raw::c_int,
                  arg2:
                      ::std::option::Option<extern "C" fn(arg1:
                                                              ::std::os::raw::c_int)>)
     ->
         ::std::option::Option<extern "C" fn(arg1: ::std::os::raw::c_int,
                                             arg2:
                                                 ::std::option::Option<extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int)>)>;
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn psignal(arg1: ::std::os::raw::c_uint,
                   arg2: *const ::std::os::raw::c_char);
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigvec(arg1: ::std::os::raw::c_int, arg2: *mut Struct_sigvec,
                  arg3: *mut Struct_sigvec) -> ::std::os::raw::c_int;
    pub fn __sigbits(__signo: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn forkname_to_number(forkName: *const ::std::os::raw::c_char)
     -> ForkNumber;
    pub fn forkname_chars(str: *const ::std::os::raw::c_char,
                          fork: *mut ForkNumber) -> ::std::os::raw::c_int;
    pub fn GetDatabasePath(dbNode: Oid, spcNode: Oid)
     -> *mut ::std::os::raw::c_char;
    pub fn GetRelationPath(dbNode: Oid, spcNode: Oid, relNode: Oid,
                           backendId: ::std::os::raw::c_int,
                           forkNumber: ForkNumber)
     -> *mut ::std::os::raw::c_char;
    pub fn SendSharedInvalidMessages(msgs: *const SharedInvalidationMessage,
                                     n: ::std::os::raw::c_int);
    pub fn ReceiveSharedInvalidMessages(invalFunction:
                                            ::std::option::Option<unsafe extern "C" fn(msg:
                                                                                           *mut SharedInvalidationMessage)>,
                                        resetFunction:
                                            ::std::option::Option<extern "C" fn()>);
    pub fn HandleCatchupInterrupt();
    pub fn ProcessCatchupInterrupt();
    pub fn xactGetCommittedInvalidationMessages(msgs:
                                                    *mut *mut SharedInvalidationMessage,
                                                RelcacheInitFileInval:
                                                    *mut _bool)
     -> ::std::os::raw::c_int;
    pub fn ProcessCommittedInvalidationMessages(msgs:
                                                    *mut SharedInvalidationMessage,
                                                nmsgs: ::std::os::raw::c_int,
                                                RelcacheInitFileInval: _bool,
                                                dbid: Oid, tsid: Oid);
    pub fn LocalExecuteInvalidationMessage(msg:
                                               *mut SharedInvalidationMessage);
    pub fn hash_create(tabname: *const ::std::os::raw::c_char,
                       nelem: ::std::os::raw::c_long, info: *mut HASHCTL,
                       flags: ::std::os::raw::c_int) -> *mut HTAB;
    pub fn hash_destroy(hashp: *mut HTAB);
    pub fn hash_stats(_where: *const ::std::os::raw::c_char,
                      hashp: *mut HTAB);
    pub fn hash_search(hashp: *mut HTAB,
                       keyPtr: *const ::std::os::raw::c_void,
                       action: HASHACTION, foundPtr: *mut _bool)
     -> *mut ::std::os::raw::c_void;
    pub fn get_hash_value(hashp: *mut HTAB,
                          keyPtr: *const ::std::os::raw::c_void) -> uint32;
    pub fn hash_search_with_hash_value(hashp: *mut HTAB,
                                       keyPtr: *const ::std::os::raw::c_void,
                                       hashvalue: uint32, action: HASHACTION,
                                       foundPtr: *mut _bool)
     -> *mut ::std::os::raw::c_void;
    pub fn hash_update_hash_key(hashp: *mut HTAB,
                                existingEntry: *mut ::std::os::raw::c_void,
                                newKeyPtr: *const ::std::os::raw::c_void)
     -> _bool;
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::std::os::raw::c_long;
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB);
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS)
     -> *mut ::std::os::raw::c_void;
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS);
    pub fn hash_freeze(hashp: *mut HTAB);
    pub fn hash_estimate_size(num_entries: ::std::os::raw::c_long,
                              entrysize: Size) -> Size;
    pub fn hash_select_dirsize(num_entries: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
    pub fn hash_get_shared_size(info: *mut HASHCTL,
                                flags: ::std::os::raw::c_int) -> Size;
    pub fn AtEOXact_HashTables(isCommit: _bool);
    pub fn AtEOSubXact_HashTables(isCommit: _bool,
                                  nestDepth: ::std::os::raw::c_int);
    pub fn string_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn tag_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn uint32_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn bitmap_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
    pub fn bitmap_match(key1: *const ::std::os::raw::c_void,
                        key2: *const ::std::os::raw::c_void, keysize: Size)
     -> ::std::os::raw::c_int;
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
    pub fn RelationClose(relation: Relation);
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
    pub fn RelationGetOidIndex(relation: Relation) -> Oid;
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
    pub fn RelationGetIndexAttrBitmap(relation: Relation,
                                      keyAttrs: IndexAttrBitmapKind)
     -> *mut Bitmapset;
    pub fn RelationGetExclusionInfo(indexRelation: Relation,
                                    operators: *mut *mut Oid,
                                    procs: *mut *mut Oid,
                                    strategies: *mut *mut uint16);
    pub fn RelationSetIndexList(relation: Relation, indexIds: *mut List,
                                oidIndex: Oid);
    pub fn RelationInitIndexAccessInfo(relation: Relation);
    pub fn errtable(rel: Relation) -> ::std::os::raw::c_int;
    pub fn errtablecol(rel: Relation, attnum: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn errtablecolname(rel: Relation,
                           colname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn errtableconstraint(rel: Relation,
                              conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
    pub fn RelationCacheInitialize();
    pub fn RelationCacheInitializePhase2();
    pub fn RelationCacheInitializePhase3();
    pub fn RelationBuildLocalRelation(relname: *const ::std::os::raw::c_char,
                                      relnamespace: Oid, tupDesc: TupleDesc,
                                      relid: Oid, relfilenode: Oid,
                                      reltablespace: Oid,
                                      shared_relation: _bool,
                                      mapped_relation: _bool,
                                      relpersistence: ::std::os::raw::c_char,
                                      relkind: ::std::os::raw::c_char)
     -> Relation;
    pub fn RelationSetNewRelfilenode(relation: Relation,
                                     persistence: ::std::os::raw::c_char,
                                     freezeXid: TransactionId,
                                     minmulti: MultiXactId);
    pub fn RelationForgetRelation(rid: Oid);
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
    pub fn RelationCacheInvalidate();
    pub fn RelationCloseSmgrByOid(relationId: Oid);
    pub fn AtEOXact_RelationCache(isCommit: _bool);
    pub fn AtEOSubXact_RelationCache(isCommit: _bool,
                                     mySubid: SubTransactionId,
                                     parentSubid: SubTransactionId);
    pub fn RelationIdIsInInitFile(relationId: Oid) -> _bool;
    pub fn RelationCacheInitFilePreInvalidate();
    pub fn RelationCacheInitFilePostInvalidate();
    pub fn RelationCacheInitFileRemove();
    pub fn RelationIncrementReferenceCount(rel: Relation);
    pub fn RelationDecrementReferenceCount(rel: Relation);
    pub fn pairingheap_allocate(compare: pairingheap_comparator,
                                arg: *mut ::std::os::raw::c_void)
     -> *mut pairingheap;
    pub fn pairingheap_free(heap: *mut pairingheap);
    pub fn pairingheap_add(heap: *mut pairingheap,
                           node: *mut pairingheap_node);
    pub fn pairingheap_first(heap: *mut pairingheap) -> *mut pairingheap_node;
    pub fn pairingheap_remove_first(heap: *mut pairingheap)
     -> *mut pairingheap_node;
    pub fn pairingheap_remove(heap: *mut pairingheap,
                              node: *mut pairingheap_node);
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
    pub fn __fpclassifyf(arg1: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __fpclassifyd(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __fpclassifyl(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_isfinitef(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __inline_isfinited(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_isfinitel(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_isinff(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __inline_isinfd(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_isinfl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_isnanf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __inline_isnand(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_isnanl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_isnormalf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __inline_isnormald(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_isnormall(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_signbitf(__x: ::std::os::raw::c_float)
     -> ::std::os::raw::c_int;
    pub fn __inline_signbitd(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn __inline_signbitl(__x: ::std::os::raw::c_double)
     -> ::std::os::raw::c_int;
    pub fn acosf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn acos(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn acosl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asinf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn asin(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asinl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atanf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atan(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atanl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atan2f(arg1: ::std::os::raw::c_float,
                  arg2: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atan2(arg1: ::std::os::raw::c_double,
                 arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atan2l(arg1: ::std::os::raw::c_double,
                  arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cosf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn cos(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cosl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn sin(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn tan(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn acoshf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn acosh(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn acoshl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asinhf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn asinh(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn asinhl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atanhf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn atanh(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn atanhl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn coshf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn cosh(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn coshl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinhf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn sinh(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sinhl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanhf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn tanh(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tanhl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn expf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn exp(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn expl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn exp2f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn exp2(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn exp2l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn expm1f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn expm1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn expm1l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn logf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn logl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log10f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log10(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log10l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log2f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log2(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log2l(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log1pf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn log1p(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn log1pl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn logbf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn logb(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn logbl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn modff(arg1: ::std::os::raw::c_float,
                 arg2: *mut ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn modf(arg1: ::std::os::raw::c_double,
                arg2: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn modfl(arg1: ::std::os::raw::c_double,
                 arg2: *mut ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn ldexpf(arg1: ::std::os::raw::c_float, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn ldexp(arg1: ::std::os::raw::c_double, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn ldexpl(arg1: ::std::os::raw::c_double, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn frexpf(arg1: ::std::os::raw::c_float,
                  arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn frexp(arg1: ::std::os::raw::c_double,
                 arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn frexpl(arg1: ::std::os::raw::c_double,
                  arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn ilogbf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_int;
    pub fn ilogb(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn ilogbl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn scalbnf(arg1: ::std::os::raw::c_float, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn scalbn(arg1: ::std::os::raw::c_double, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn scalbnl(arg1: ::std::os::raw::c_double,
                   arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_double;
    pub fn scalblnf(arg1: ::std::os::raw::c_float,
                    arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_float;
    pub fn scalbln(arg1: ::std::os::raw::c_double,
                   arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_double;
    pub fn scalblnl(arg1: ::std::os::raw::c_double,
                    arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_double;
    pub fn fabsf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn fabs(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fabsl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cbrtf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn cbrt(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn cbrtl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn hypotf(arg1: ::std::os::raw::c_float,
                  arg2: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn hypot(arg1: ::std::os::raw::c_double,
                 arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn hypotl(arg1: ::std::os::raw::c_double,
                  arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn powf(arg1: ::std::os::raw::c_float, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn pow(arg1: ::std::os::raw::c_double, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn powl(arg1: ::std::os::raw::c_double,
                arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sqrtf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn sqrt(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn sqrtl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn erff(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn erf(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn erfl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn erfcf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn erfc(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn erfcl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn lgammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn lgamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn lgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn tgammaf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn tgamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn tgammal(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn ceilf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn ceil(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn ceill(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn floorf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn floor(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn floorl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn nearbyintf(arg1: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn nearbyint(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nearbyintl(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn rintf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn rint(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn rintl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn lrintf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn lrint(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn lrintl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn roundf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn round(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn roundl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn lroundf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_long;
    pub fn lround(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn lroundl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn llrintf(arg1: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn llrint(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn llrintl(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn llroundf(arg1: ::std::os::raw::c_float)
     -> ::std::os::raw::c_longlong;
    pub fn llround(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn llroundl(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_longlong;
    pub fn truncf(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn trunc(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn truncl(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmodf(arg1: ::std::os::raw::c_float, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn fmod(arg1: ::std::os::raw::c_double,
                arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmodl(arg1: ::std::os::raw::c_double,
                 arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn remainderf(arg1: ::std::os::raw::c_float,
                      arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn remainder(arg1: ::std::os::raw::c_double,
                     arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn remainderl(arg1: ::std::os::raw::c_double,
                      arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn remquof(arg1: ::std::os::raw::c_float,
                   arg2: ::std::os::raw::c_float,
                   arg3: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_float;
    pub fn remquo(arg1: ::std::os::raw::c_double,
                  arg2: ::std::os::raw::c_double,
                  arg3: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn remquol(arg1: ::std::os::raw::c_double,
                   arg2: ::std::os::raw::c_double,
                   arg3: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_double;
    pub fn copysignf(arg1: ::std::os::raw::c_float,
                     arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn copysign(arg1: ::std::os::raw::c_double,
                    arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn copysignl(arg1: ::std::os::raw::c_double,
                     arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nanf(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_float;
    pub fn nan(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn nanl(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_double;
    pub fn nextafterf(arg1: ::std::os::raw::c_float,
                      arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn nextafter(arg1: ::std::os::raw::c_double,
                     arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nextafterl(arg1: ::std::os::raw::c_double,
                      arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nexttoward(arg1: ::std::os::raw::c_double,
                      arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn nexttowardf(arg1: ::std::os::raw::c_float,
                       arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_float;
    pub fn nexttowardl(arg1: ::std::os::raw::c_double,
                       arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn fdimf(arg1: ::std::os::raw::c_float, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn fdim(arg1: ::std::os::raw::c_double,
                arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fdiml(arg1: ::std::os::raw::c_double,
                 arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmaxf(arg1: ::std::os::raw::c_float, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn fmax(arg1: ::std::os::raw::c_double,
                arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmaxl(arg1: ::std::os::raw::c_double,
                 arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fminf(arg1: ::std::os::raw::c_float, arg2: ::std::os::raw::c_float)
     -> ::std::os::raw::c_float;
    pub fn fmin(arg1: ::std::os::raw::c_double,
                arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fminl(arg1: ::std::os::raw::c_double,
                 arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmaf(arg1: ::std::os::raw::c_float, arg2: ::std::os::raw::c_float,
                arg3: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn fma(arg1: ::std::os::raw::c_double, arg2: ::std::os::raw::c_double,
               arg3: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn fmal(arg1: ::std::os::raw::c_double,
                arg2: ::std::os::raw::c_double,
                arg3: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn __inff() -> ::std::os::raw::c_float;
    pub fn __inf() -> ::std::os::raw::c_double;
    pub fn __infl() -> ::std::os::raw::c_double;
    pub fn __nan() -> ::std::os::raw::c_float;
    pub fn __exp10f(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __exp10(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __sincosf(__x: ::std::os::raw::c_float,
                     __sinp: *mut ::std::os::raw::c_float,
                     __cosp: *mut ::std::os::raw::c_float);
    pub fn __sincos(__x: ::std::os::raw::c_double,
                    __sinp: *mut ::std::os::raw::c_double,
                    __cosp: *mut ::std::os::raw::c_double);
    pub fn __cospif(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __cospi(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __sinpif(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __sinpi(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __tanpif(arg1: ::std::os::raw::c_float) -> ::std::os::raw::c_float;
    pub fn __tanpi(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn __sincospif(__x: ::std::os::raw::c_float,
                       __sinp: *mut ::std::os::raw::c_float,
                       __cosp: *mut ::std::os::raw::c_float);
    pub fn __sincospi(__x: ::std::os::raw::c_double,
                      __sinp: *mut ::std::os::raw::c_double,
                      __cosp: *mut ::std::os::raw::c_double);
    pub fn __sincosf_stret(arg1: ::std::os::raw::c_float) -> Struct___float2;
    pub fn __sincos_stret(arg1: ::std::os::raw::c_double) -> Struct___double2;
    pub fn __sincospif_stret(arg1: ::std::os::raw::c_float)
     -> Struct___float2;
    pub fn __sincospi_stret(arg1: ::std::os::raw::c_double)
     -> Struct___double2;
    pub fn j0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn j1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn y0(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn y1(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn scalb(arg1: ::std::os::raw::c_double,
                 arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn rinttol(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn roundtol(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_long;
    pub fn drem(arg1: ::std::os::raw::c_double,
                arg2: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn finite(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_int;
    pub fn gamma(arg1: ::std::os::raw::c_double) -> ::std::os::raw::c_double;
    pub fn significand(arg1: ::std::os::raw::c_double)
     -> ::std::os::raw::c_double;
    pub fn matherr(arg1: *mut Struct_exception) -> ::std::os::raw::c_int;
    pub fn pg_localtime(timep: *const pg_time_t, tz: *const pg_tz)
     -> *mut Struct_pg_tm;
    pub fn pg_gmtime(timep: *const pg_time_t) -> *mut Struct_pg_tm;
    pub fn pg_next_dst_boundary(timep: *const pg_time_t,
                                before_gmtoff: *mut ::std::os::raw::c_long,
                                before_isdst: *mut ::std::os::raw::c_int,
                                boundary: *mut pg_time_t,
                                after_gmtoff: *mut ::std::os::raw::c_long,
                                after_isdst: *mut ::std::os::raw::c_int,
                                tz: *const pg_tz) -> ::std::os::raw::c_int;
    pub fn pg_interpret_timezone_abbrev(abbrev: *const ::std::os::raw::c_char,
                                        timep: *const pg_time_t,
                                        gmtoff: *mut ::std::os::raw::c_long,
                                        isdst: *mut ::std::os::raw::c_int,
                                        tz: *const pg_tz) -> _bool;
    pub fn pg_get_timezone_offset(tz: *const pg_tz,
                                  gmtoff: *mut ::std::os::raw::c_long)
     -> _bool;
    pub fn pg_get_timezone_name(tz: *mut pg_tz)
     -> *const ::std::os::raw::c_char;
    pub fn pg_tz_acceptable(tz: *mut pg_tz) -> _bool;
    pub fn pg_strftime(s: *mut ::std::os::raw::c_char, max: size_t,
                       format: *const ::std::os::raw::c_char,
                       tm: *const Struct_pg_tm) -> size_t;
    pub fn pg_timezone_initialize();
    pub fn pg_tzset(tzname: *const ::std::os::raw::c_char) -> *mut pg_tz;
    pub fn pg_tzset_offset(gmtoffset: ::std::os::raw::c_long) -> *mut pg_tz;
    pub fn pg_tzenumerate_start() -> *mut pg_tzenum;
    pub fn pg_tzenumerate_next(dir: *mut pg_tzenum) -> *mut pg_tz;
    pub fn pg_tzenumerate_end(dir: *mut pg_tzenum);
    pub fn timestamp_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_hours(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_days(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_zone_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_izone_transform(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mul_d_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn now(fcinfo: FunctionCallInfo) -> Datum;
    pub fn statement_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clock_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_conf_load_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn GetCurrentTimestamp() -> TimestampTz;
    pub fn TimestampDifference(start_time: TimestampTz,
                               stop_time: TimestampTz,
                               secs: *mut ::std::os::raw::c_long,
                               microsecs: *mut ::std::os::raw::c_int);
    pub fn TimestampDifferenceExceeds(start_time: TimestampTz,
                                      stop_time: TimestampTz,
                                      msec: ::std::os::raw::c_int) -> _bool;
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
    pub fn timestamptz_to_str(t: TimestampTz)
     -> *const ::std::os::raw::c_char;
    pub fn tm2timestamp(tm: *mut Struct_pg_tm, fsec: fsec_t,
                        tzp: *mut ::std::os::raw::c_int, dt: *mut Timestamp)
     -> ::std::os::raw::c_int;
    pub fn timestamp2tm(dt: Timestamp, tzp: *mut ::std::os::raw::c_int,
                        tm: *mut Struct_pg_tm, fsec: *mut fsec_t,
                        tzn: *mut *const ::std::os::raw::c_char,
                        attimezone: *mut pg_tz) -> ::std::os::raw::c_int;
    pub fn dt2time(dt: Timestamp, hour: *mut ::std::os::raw::c_int,
                   min: *mut ::std::os::raw::c_int,
                   sec: *mut ::std::os::raw::c_int, fsec: *mut fsec_t);
    pub fn interval2tm(span: Interval, tm: *mut Struct_pg_tm,
                       fsec: *mut fsec_t) -> ::std::os::raw::c_int;
    pub fn tm2interval(tm: *mut Struct_pg_tm, fsec: fsec_t,
                       span: *mut Interval) -> ::std::os::raw::c_int;
    pub fn SetEpochTimestamp() -> Timestamp;
    pub fn GetEpochTime(tm: *mut Struct_pg_tm);
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp)
     -> ::std::os::raw::c_int;
    pub fn isoweek2j(year: ::std::os::raw::c_int, week: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn isoweek2date(woy: ::std::os::raw::c_int,
                        year: *mut ::std::os::raw::c_int,
                        mon: *mut ::std::os::raw::c_int,
                        mday: *mut ::std::os::raw::c_int);
    pub fn isoweekdate2date(isoweek: ::std::os::raw::c_int,
                            wday: ::std::os::raw::c_int,
                            year: *mut ::std::os::raw::c_int,
                            mon: *mut ::std::os::raw::c_int,
                            mday: *mut ::std::os::raw::c_int);
    pub fn date2isoweek(year: ::std::os::raw::c_int,
                        mon: ::std::os::raw::c_int,
                        mday: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn date2isoyear(year: ::std::os::raw::c_int,
                        mon: ::std::os::raw::c_int,
                        mday: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn date2isoyearday(year: ::std::os::raw::c_int,
                           mon: ::std::os::raw::c_int,
                           mday: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn ReorderBufferAllocate() -> *mut ReorderBuffer;
    pub fn ReorderBufferFree(arg1: *mut ReorderBuffer);
    pub fn ReorderBufferGetTupleBuf(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferTupleBuf;
    pub fn ReorderBufferReturnTupleBuf(arg1: *mut ReorderBuffer,
                                       tuple: *mut ReorderBufferTupleBuf);
    pub fn ReorderBufferGetChange(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferChange;
    pub fn ReorderBufferReturnChange(arg1: *mut ReorderBuffer,
                                     arg2: *mut ReorderBufferChange);
    pub fn ReorderBufferQueueChange(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    arg3: *mut ReorderBufferChange);
    pub fn ReorderBufferCommit(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               commit_lsn: XLogRecPtr, end_lsn: XLogRecPtr,
                               commit_time: TimestampTz,
                               origin_id: RepOriginId,
                               origin_lsn: XLogRecPtr);
    pub fn ReorderBufferAssignChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr);
    pub fn ReorderBufferCommitChild(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, arg3: TransactionId,
                                    commit_lsn: XLogRecPtr,
                                    end_lsn: XLogRecPtr);
    pub fn ReorderBufferAbort(arg1: *mut ReorderBuffer, arg2: TransactionId,
                              lsn: XLogRecPtr);
    pub fn ReorderBufferAbortOld(arg1: *mut ReorderBuffer,
                                 xid: TransactionId);
    pub fn ReorderBufferForget(arg1: *mut ReorderBuffer, arg2: TransactionId,
                               lsn: XLogRecPtr);
    pub fn ReorderBufferSetBaseSnapshot(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        snap: *mut Struct_SnapshotData);
    pub fn ReorderBufferAddSnapshot(arg1: *mut ReorderBuffer,
                                    arg2: TransactionId, lsn: XLogRecPtr,
                                    snap: *mut Struct_SnapshotData);
    pub fn ReorderBufferAddNewCommandId(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        cid: CommandId);
    pub fn ReorderBufferAddNewTupleCids(arg1: *mut ReorderBuffer,
                                        arg2: TransactionId, lsn: XLogRecPtr,
                                        node: RelFileNode,
                                        pt: ItemPointerData, cmin: CommandId,
                                        cmax: CommandId, combocid: CommandId);
    pub fn ReorderBufferAddInvalidations(arg1: *mut ReorderBuffer,
                                         arg2: TransactionId, lsn: XLogRecPtr,
                                         nmsgs: Size,
                                         msgs:
                                             *mut SharedInvalidationMessage);
    pub fn ReorderBufferIsXidKnown(arg1: *mut ReorderBuffer,
                                   xid: TransactionId) -> _bool;
    pub fn ReorderBufferXidSetCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId,
                                             lsn: XLogRecPtr);
    pub fn ReorderBufferXidHasCatalogChanges(arg1: *mut ReorderBuffer,
                                             xid: TransactionId) -> _bool;
    pub fn ReorderBufferXidHasBaseSnapshot(arg1: *mut ReorderBuffer,
                                           xid: TransactionId) -> _bool;
    pub fn ReorderBufferGetOldestTXN(arg1: *mut ReorderBuffer)
     -> *mut ReorderBufferTXN;
    pub fn ReorderBufferSetRestartPoint(arg1: *mut ReorderBuffer,
                                        ptr: XLogRecPtr);
    pub fn StartupReorderBuffer();
    pub fn OutputPluginPrepareWrite(ctx: *mut Struct_LogicalDecodingContext,
                                    last_write: _bool);
    pub fn OutputPluginWrite(ctx: *mut Struct_LogicalDecodingContext,
                             last_write: _bool);
    pub fn XLogBeginInsert();
    pub fn XLogIncludeOrigin();
    pub fn XLogInsert(rmid: RmgrId, info: uint8) -> XLogRecPtr;
    pub fn XLogEnsureRecordSpace(nbuffers: ::std::os::raw::c_int,
                                 ndatas: ::std::os::raw::c_int);
    pub fn XLogRegisterData(data: *mut ::std::os::raw::c_char,
                            len: ::std::os::raw::c_int);
    pub fn XLogRegisterBuffer(block_id: uint8, buffer: Buffer, flags: uint8);
    pub fn XLogRegisterBlock(block_id: uint8, rnode: *mut RelFileNode,
                             forknum: ForkNumber, blknum: BlockNumber,
                             page: *mut ::std::os::raw::c_char, flags: uint8);
    pub fn XLogRegisterBufData(block_id: uint8,
                               data: *mut ::std::os::raw::c_char,
                               len: ::std::os::raw::c_int);
    pub fn XLogResetInsertion();
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> _bool;
    pub fn log_newpage(rnode: *mut RelFileNode, forkNum: ForkNumber,
                       blk: BlockNumber, page: *mut ::std::os::raw::c_char,
                       page_std: _bool) -> XLogRecPtr;
    pub fn log_newpage_buffer(buffer: Buffer, page_std: _bool) -> XLogRecPtr;
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: _bool)
     -> XLogRecPtr;
    pub fn InitXLogInsert();
    pub fn pg_comp_crc32c_sse42(crc: pg_crc32c,
                                data: *const ::std::os::raw::c_void,
                                len: size_t) -> pg_crc32c;
    pub fn pg_comp_crc32c_sb8(crc: pg_crc32c,
                              data: *const ::std::os::raw::c_void,
                              len: size_t) -> pg_crc32c;
    pub fn XLogReaderAllocate(pagereadfunc: XLogPageReadCB,
                              private_data: *mut ::std::os::raw::c_void)
     -> *mut XLogReaderState;
    pub fn XLogReaderFree(state: *mut XLogReaderState);
    pub fn XLogReadRecord(state: *mut XLogReaderState, recptr: XLogRecPtr,
                          errormsg: *mut *mut ::std::os::raw::c_char)
     -> *mut Struct_XLogRecord;
    pub fn DecodeXLogRecord(state: *mut XLogReaderState,
                            record: *mut XLogRecord,
                            errmsg: *mut *mut ::std::os::raw::c_char)
     -> _bool;
    pub fn RestoreBlockImage(recoder: *mut XLogReaderState, block_id: uint8,
                             dst: *mut ::std::os::raw::c_char) -> _bool;
    pub fn XLogRecGetBlockData(record: *mut XLogReaderState, block_id: uint8,
                               len: *mut Size) -> *mut ::std::os::raw::c_char;
    pub fn XLogRecGetBlockTag(record: *mut XLogReaderState, block_id: uint8,
                              rnode: *mut RelFileNode,
                              forknum: *mut ForkNumber,
                              blknum: *mut BlockNumber) -> _bool;
    pub fn closedir(arg1: *mut DIR) -> ::std::os::raw::c_int;
    pub fn opendir(arg1: *const ::std::os::raw::c_char) -> *mut DIR;
    pub fn readdir(arg1: *mut DIR) -> *mut Struct_dirent;
    pub fn readdir_r(arg1: *mut DIR, arg2: *mut Struct_dirent,
                     arg3: *mut *mut Struct_dirent) -> ::std::os::raw::c_int;
    pub fn rewinddir(arg1: *mut DIR);
    pub fn seekdir(arg1: *mut DIR, arg2: ::std::os::raw::c_long);
    pub fn telldir(arg1: *mut DIR) -> ::std::os::raw::c_long;
    pub fn fdopendir(arg1: ::std::os::raw::c_int) -> *mut DIR;
    pub fn alphasort(arg1: *mut *const Struct_dirent,
                     arg2: *mut *const Struct_dirent)
     -> ::std::os::raw::c_int;
    pub fn dirfd(dirp: *mut DIR) -> ::std::os::raw::c_int;
    pub fn scandir(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut *mut Struct_dirent,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const Struct_dirent)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut *const Struct_dirent,
                                                                  arg2:
                                                                      *mut *const Struct_dirent)
                                                 -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
    pub fn scandir_b(arg1: *const ::std::os::raw::c_char,
                     arg2: *mut *mut *mut Struct_dirent,
                     arg3: ::std::os::raw::c_void,
                     arg4: ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    pub fn getdirentries(arg1: ::std::os::raw::c_int,
                         arg2: *mut ::std::os::raw::c_char,
                         arg3: ::std::os::raw::c_int,
                         arg4: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
    pub fn __opendir2(arg1: *const ::std::os::raw::c_char,
                      arg2: ::std::os::raw::c_int) -> *mut DIR;
    pub fn PathNameOpenFile(fileName: FileName,
                            fileFlags: ::std::os::raw::c_int,
                            fileMode: ::std::os::raw::c_int) -> File;
    pub fn OpenTemporaryFile(interXact: _bool) -> File;
    pub fn FileClose(file: File);
    pub fn FilePrefetch(file: File, offset: off_t,
                        amount: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn FileRead(file: File, buffer: *mut ::std::os::raw::c_char,
                    amount: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn FileWrite(file: File, buffer: *mut ::std::os::raw::c_char,
                     amount: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn FileSync(file: File) -> ::std::os::raw::c_int;
    pub fn FileSeek(file: File, offset: off_t, whence: ::std::os::raw::c_int)
     -> off_t;
    pub fn FileTruncate(file: File, offset: off_t) -> ::std::os::raw::c_int;
    pub fn FilePathName(file: File) -> *mut ::std::os::raw::c_char;
    pub fn AllocateFile(name: *const ::std::os::raw::c_char,
                        mode: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn FreeFile(file: *mut FILE) -> ::std::os::raw::c_int;
    pub fn OpenPipeStream(command: *const ::std::os::raw::c_char,
                          mode: *const ::std::os::raw::c_char) -> *mut FILE;
    pub fn ClosePipeStream(file: *mut FILE) -> ::std::os::raw::c_int;
    pub fn AllocateDir(dirname: *const ::std::os::raw::c_char) -> *mut DIR;
    pub fn ReadDir(dir: *mut DIR, dirname: *const ::std::os::raw::c_char)
     -> *mut Struct_dirent;
    pub fn FreeDir(dir: *mut DIR) -> ::std::os::raw::c_int;
    pub fn OpenTransientFile(fileName: FileName,
                             fileFlags: ::std::os::raw::c_int,
                             fileMode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn CloseTransientFile(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn BasicOpenFile(fileName: FileName, fileFlags: ::std::os::raw::c_int,
                         fileMode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn InitFileAccess();
    pub fn set_max_safe_fds();
    pub fn closeAllVfds();
    pub fn SetTempTablespaces(tableSpaces: *mut Oid,
                              numSpaces: ::std::os::raw::c_int);
    pub fn TempTablespacesAreSet() -> _bool;
    pub fn GetNextTempTableSpace() -> Oid;
    pub fn AtEOXact_Files();
    pub fn AtEOSubXact_Files(isCommit: _bool, mySubid: SubTransactionId,
                             parentSubid: SubTransactionId);
    pub fn RemovePgTempFiles();
    pub fn pg_fsync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pg_fsync_no_writethrough(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pg_fsync_writethrough(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn pg_fdatasync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pg_flush_data(fd: ::std::os::raw::c_int, offset: off_t,
                         amount: off_t) -> ::std::os::raw::c_int;
    pub fn fsync_fname(fname: *mut ::std::os::raw::c_char, isdir: _bool);
    pub fn SyncDataDirectory();
    pub fn XLogInsertRecord(rdata: *mut Struct_XLogRecData,
                            fpw_lsn: XLogRecPtr) -> XLogRecPtr;
    pub fn XLogFlush(RecPtr: XLogRecPtr);
    pub fn XLogBackgroundFlush() -> _bool;
    pub fn XLogNeedsFlush(RecPtr: XLogRecPtr) -> _bool;
    pub fn XLogFileInit(segno: XLogSegNo, use_existent: *mut _bool,
                        use_lock: _bool) -> ::std::os::raw::c_int;
    pub fn XLogFileOpen(segno: XLogSegNo) -> ::std::os::raw::c_int;
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID);
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
    pub fn XLogSetAsyncXactLSN(record: XLogRecPtr);
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr);
    pub fn xlog_redo(record: *mut XLogReaderState);
    pub fn xlog_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn xlog_identify(info: uint8) -> *const ::std::os::raw::c_char;
    pub fn issue_xlog_fsync(fd: ::std::os::raw::c_int, segno: XLogSegNo);
    pub fn RecoveryInProgress() -> _bool;
    pub fn HotStandbyActive() -> _bool;
    pub fn HotStandbyActiveInReplay() -> _bool;
    pub fn XLogInsertAllowed() -> _bool;
    pub fn GetXLogReceiptTime(rtime: *mut TimestampTz,
                              fromStream: *mut _bool);
    pub fn GetXLogReplayRecPtr(replayTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
    pub fn RecoveryIsPaused() -> _bool;
    pub fn SetRecoveryPause(recoveryPause: _bool);
    pub fn GetLatestXTime() -> TimestampTz;
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
    pub fn XLogFileNameP(tli: TimeLineID, segno: XLogSegNo)
     -> *mut ::std::os::raw::c_char;
    pub fn UpdateControlFile();
    pub fn GetSystemIdentifier() -> uint64;
    pub fn DataChecksumsEnabled() -> _bool;
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
    pub fn XLOGShmemSize() -> Size;
    pub fn XLOGShmemInit();
    pub fn BootStrapXLOG();
    pub fn StartupXLOG();
    pub fn ShutdownXLOG(code: ::std::os::raw::c_int, arg: Datum);
    pub fn InitXLOGAccess();
    pub fn CreateCheckPoint(flags: ::std::os::raw::c_int);
    pub fn CreateRestartPoint(flags: ::std::os::raw::c_int) -> _bool;
    pub fn XLogPutNextOid(nextOid: Oid);
    pub fn XLogRestorePoint(rpName: *const ::std::os::raw::c_char)
     -> XLogRecPtr;
    pub fn UpdateFullPageWrites();
    pub fn GetFullPageWriteInfo(RedoRecPtr_p: *mut XLogRecPtr,
                                doPageWrites_p: *mut _bool);
    pub fn GetRedoRecPtr() -> XLogRecPtr;
    pub fn GetInsertRecPtr() -> XLogRecPtr;
    pub fn GetFlushRecPtr() -> XLogRecPtr;
    pub fn GetNextXidAndEpoch(xid: *mut TransactionId, epoch: *mut uint32);
    pub fn RemovePromoteSignalFiles();
    pub fn CheckPromoteSignal() -> _bool;
    pub fn WakeupRecovery();
    pub fn SetWalWriterSleeping(sleeping: _bool);
    pub fn assign_max_wal_size(newval: ::std::os::raw::c_int,
                               extra: *mut ::std::os::raw::c_void);
    pub fn assign_checkpoint_completion_target(newval:
                                                   ::std::os::raw::c_double,
                                               extra:
                                                   *mut ::std::os::raw::c_void);
    pub fn do_pg_start_backup(backupidstr: *const ::std::os::raw::c_char,
                              fast: _bool, starttli_p: *mut TimeLineID,
                              labelfile: *mut *mut ::std::os::raw::c_char,
                              tblspcdir: *mut DIR,
                              tablespaces: *mut *mut List,
                              tblspcmapfile: *mut *mut ::std::os::raw::c_char,
                              infotbssize: _bool, needtblspcmapfile: _bool)
     -> XLogRecPtr;
    pub fn do_pg_stop_backup(labelfile: *mut ::std::os::raw::c_char,
                             waitforarchive: _bool,
                             stoptli_p: *mut TimeLineID) -> XLogRecPtr;
    pub fn do_pg_abort_backup();
    pub fn s_lock(lock: *mut slock_t, file: *const ::std::os::raw::c_char,
                  line: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn set_spins_per_delay(shared_spins_per_delay: ::std::os::raw::c_int);
    pub fn update_spins_per_delay(shared_spins_per_delay:
                                      ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
    pub fn LWLockAcquire(lock: *mut LWLock, mode: LWLockMode) -> _bool;
    pub fn LWLockConditionalAcquire(lock: *mut LWLock, mode: LWLockMode)
     -> _bool;
    pub fn LWLockAcquireOrWait(lock: *mut LWLock, mode: LWLockMode) -> _bool;
    pub fn LWLockRelease(lock: *mut LWLock);
    pub fn LWLockReleaseClearVar(lock: *mut LWLock, valptr: *mut uint64,
                                 val: uint64);
    pub fn LWLockReleaseAll();
    pub fn LWLockHeldByMe(lock: *mut LWLock) -> _bool;
    pub fn LWLockWaitForVar(lock: *mut LWLock, valptr: *mut uint64,
                            oldval: uint64, newval: *mut uint64) -> _bool;
    pub fn LWLockUpdateVar(lock: *mut LWLock, valptr: *mut uint64,
                           value: uint64);
    pub fn LWLockShmemSize() -> Size;
    pub fn CreateLWLocks();
    pub fn InitLWLockAccess();
    pub fn RequestAddinLWLocks(n: ::std::os::raw::c_int);
    pub fn LWLockAssign() -> *mut LWLock;
    pub fn LWLockNewTrancheId() -> ::std::os::raw::c_int;
    pub fn LWLockRegisterTranche(tranche_id: ::std::os::raw::c_int,
                                 tranche: *mut LWLockTranche);
    pub fn LWLockInitialize(lock: *mut LWLock,
                            tranche_id: ::std::os::raw::c_int);
    pub fn InitShmemAccess(seghdr: *mut ::std::os::raw::c_void);
    pub fn InitShmemAllocation();
    pub fn ShmemAlloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn ShmemAddrIsValid(addr: *const ::std::os::raw::c_void) -> _bool;
    pub fn InitShmemIndex();
    pub fn ShmemInitHash(name: *const ::std::os::raw::c_char,
                         init_size: ::std::os::raw::c_long,
                         max_size: ::std::os::raw::c_long,
                         infoP: *mut HASHCTL,
                         hash_flags: ::std::os::raw::c_int) -> *mut HTAB;
    pub fn ShmemInitStruct(name: *const ::std::os::raw::c_char, size: Size,
                           foundPtr: *mut _bool)
     -> *mut ::std::os::raw::c_void;
    pub fn add_size(s1: Size, s2: Size) -> Size;
    pub fn mul_size(s1: Size, s2: Size) -> Size;
    pub fn RequestAddinShmemSpace(size: Size);
    pub fn SHMQueueInit(queue: *mut SHM_QUEUE);
    pub fn SHMQueueElemInit(queue: *mut SHM_QUEUE);
    pub fn SHMQueueDelete(queue: *mut SHM_QUEUE);
    pub fn SHMQueueInsertBefore(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
    pub fn SHMQueueInsertAfter(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
    pub fn SHMQueueNext(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueuePrev(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
    pub fn SHMQueueEmpty(queue: *const SHM_QUEUE) -> _bool;
    pub fn SHMQueueIsDetached(queue: *const SHM_QUEUE) -> _bool;
    pub fn SpinlockSemas() -> ::std::os::raw::c_int;
    pub fn SpinlockSemaSize() -> Size;
    pub fn ReplicationSlotsShmemSize() -> Size;
    pub fn ReplicationSlotsShmemInit();
    pub fn ReplicationSlotCreate(name: *const ::std::os::raw::c_char,
                                 db_specific: _bool,
                                 p: ReplicationSlotPersistency);
    pub fn ReplicationSlotPersist();
    pub fn ReplicationSlotDrop(name: *const ::std::os::raw::c_char);
    pub fn ReplicationSlotAcquire(name: *const ::std::os::raw::c_char);
    pub fn ReplicationSlotRelease();
    pub fn ReplicationSlotSave();
    pub fn ReplicationSlotMarkDirty();
    pub fn ReplicationSlotValidateName(name: *const ::std::os::raw::c_char,
                                       elevel: ::std::os::raw::c_int)
     -> _bool;
    pub fn ReplicationSlotsComputeRequiredXmin(already_locked: _bool);
    pub fn ReplicationSlotsComputeRequiredLSN();
    pub fn ReplicationSlotsComputeLogicalRestartLSN() -> XLogRecPtr;
    pub fn ReplicationSlotsCountDBSlots(dboid: Oid,
                                        nslots: *mut ::std::os::raw::c_int,
                                        nactive: *mut ::std::os::raw::c_int)
     -> _bool;
    pub fn StartupReplicationSlots();
    pub fn CheckPointReplicationSlots();
    pub fn CheckSlotRequirements();
    pub fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo)
     -> Datum;
    pub fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
    pub fn CheckLogicalDecodingRequirements();
    pub fn CreateInitDecodingContext(plugin: *mut ::std::os::raw::c_char,
                                     output_plugin_options: *mut List,
                                     read_page: XLogPageReadCB,
                                     prepare_write:
                                         LogicalOutputPluginWriterPrepareWrite,
                                     do_write: LogicalOutputPluginWriterWrite)
     -> *mut LogicalDecodingContext;
    pub fn CreateDecodingContext(start_lsn: XLogRecPtr,
                                 output_plugin_options: *mut List,
                                 read_page: XLogPageReadCB,
                                 prepare_write:
                                     LogicalOutputPluginWriterPrepareWrite,
                                 do_write: LogicalOutputPluginWriterWrite)
     -> *mut LogicalDecodingContext;
    pub fn DecodingContextFindStartpoint(ctx: *mut LogicalDecodingContext);
    pub fn DecodingContextReady(ctx: *mut LogicalDecodingContext) -> _bool;
    pub fn FreeDecodingContext(ctx: *mut LogicalDecodingContext);
    pub fn LogicalIncreaseXminForSlot(lsn: XLogRecPtr, xmin: TransactionId);
    pub fn LogicalIncreaseRestartDecodingForSlot(current_lsn: XLogRecPtr,
                                                 restart_lsn: XLogRecPtr);
    pub fn LogicalConfirmReceivedLocation(lsn: XLogRecPtr);
    pub fn filter_by_origin_cb_wrapper(ctx: *mut LogicalDecodingContext,
                                       origin_id: RepOriginId) -> _bool;
}
